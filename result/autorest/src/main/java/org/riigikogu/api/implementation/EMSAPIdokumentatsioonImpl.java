/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package org.riigikogu.api.implementation;

import org.riigikogu.api.EMSAPIdokumentatsioon;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.CollectionFormat;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import org.joda.time.LocalDate;
import org.riigikogu.api.models._ksusePEvakord;
import org.riigikogu.api.models.DokumenditP;
import org.riigikogu.api.models.Dokument;
import org.riigikogu.api.models.EelnUAlgataja;
import org.riigikogu.api.models.EelnUToimikBaas;
import org.riigikogu.api.models.Fail;
import org.riigikogu.api.models.FunktsiooniGrupp;
import org.riigikogu.api.models.HLetuspEv;
import org.riigikogu.api.models.IstungjRk;
import org.riigikogu.api.models.KasutajaDetailidKontaktid;
import org.riigikogu.api.models.Kasutajagrupp;
import org.riigikogu.api.models.KasutajagruppKontaktid;
import org.riigikogu.api.models.Klassifikaator;
import org.riigikogu.api.models.KlassifikaatoriVRtusDetailid;
import org.riigikogu.api.models.KollektiivnePRdumineDokument;
import org.riigikogu.api.models.KomisjoniIstung;
import org.riigikogu.api.models.Koosseis;
import org.riigikogu.api.models.PagedResourcesDokument;
import org.riigikogu.api.models.PagedResourcesDokumentMuuKSimus;
import org.riigikogu.api.models.PagedResourcesEelnUOtsing;
import org.riigikogu.api.models.PagedResourcesELToimikOtsing;
import org.riigikogu.api.models.PagedResourcesRiigikoguLiikmeHLetus;
import org.riigikogu.api.models.PagedResourcesToimikArupRimine;
import org.riigikogu.api.models.PagedResourcesToimikKirjalikKSimus;
import org.riigikogu.api.models.PagedResourcesToimikOtsing;
import org.riigikogu.api.models.PEvakord;
import org.riigikogu.api.models.PEvasNdmused;
import org.riigikogu.api.models.PEvSNdmused;
import org.riigikogu.api.models.RiigikoguLiige;
import org.riigikogu.api.models.RiigikoguLiigeHLetused;
import org.riigikogu.api.models.RiigikoguLiigeOsavTt;
import org.riigikogu.api.models.RiigikoguLiigeSNavTud;
import org.riigikogu.api.models.RiigikoguLiikmeDetailid;
import org.riigikogu.api.models.SaaliplaaniKoht;
import org.riigikogu.api.models.StenoPEvakorrapunkt;
import org.riigikogu.api.models.StenoSNavTtudeArv;
import org.riigikogu.api.models.StenoSNavTud;
import org.riigikogu.api.models.StenoViimaneSNavTt;
import org.riigikogu.api.models.TIskoguHLetusDetailid;
import org.riigikogu.api.models.TIskoguIstungHLetus;
import org.riigikogu.api.models.Toimik;
import org.riigikogu.api.models.ToimikERJK;
import org.riigikogu.api.models.ToimikuTP;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the EMSAPIdokumentatsioon class.
 */
public class EMSAPIdokumentatsioonImpl extends ServiceClient implements EMSAPIdokumentatsioon {
    /**
     * The Retrofit service to perform REST calls.
     */
    private EMSAPIdokumentatsioonService service;

    /**
     * Initializes an instance of EMSAPIdokumentatsioon client.
     */
    public EMSAPIdokumentatsioonImpl() {
        this("http://api.riigikogu.ee");
    }

    /**
     * Initializes an instance of EMSAPIdokumentatsioon client.
     *
     * @param baseUrl the base URL of the host
     */
    public EMSAPIdokumentatsioonImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of EMSAPIdokumentatsioon client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public EMSAPIdokumentatsioonImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("http://api.riigikogu.ee", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of EMSAPIdokumentatsioon client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public EMSAPIdokumentatsioonImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of EMSAPIdokumentatsioon client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public EMSAPIdokumentatsioonImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(EMSAPIdokumentatsioonService.class);
    }

    /**
     * The interface defining all the services for EMSAPIdokumentatsioon to be
     * used by Retrofit to perform actually REST calls.
     */
    interface EMSAPIdokumentatsioonService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenaryAgendaUsingGET" })
        @GET("api/agenda/plenary")
        Observable<Response<ResponseBody>> getPlenaryAgendaUsingGET(@Query("date") LocalDate dateParameter, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("querySteno") Boolean querySteno, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getUnitAgendaUsingGET" })
        @GET("api/agenda/usergroup/{uuid}")
        Observable<Response<ResponseBody>> getUnitAgendaUsingGET(@Path("uuid") String uuid, @Query("date") LocalDate dateParameter, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getClassifiersUsingGET" })
        @GET("api/classifiers")
        Observable<Response<ResponseBody>> getClassifiersUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getClassifierValueUsingGET" })
        @GET("api/classifiers/{classifierCode}/{valueCode}")
        Observable<Response<ResponseBody>> getClassifierValueUsingGET(@Path("classifierCode") String classifierCode, @Path("valueCode") String valueCode, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getClassifierValuesUsingGET" })
        @GET("api/classifiers/{code}")
        Observable<Response<ResponseBody>> getClassifierValuesUsingGET(@Path("code") String code, @Query("includeInactive") Boolean includeInactive, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getContactsUsingGET" })
        @GET("api/contacts")
        Observable<Response<ResponseBody>> getContactsUsingGET(@Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getUserDetailsUsingGET" })
        @GET("api/contacts/{uuid}")
        Observable<Response<ResponseBody>> getUserDetailsUsingGET(@Path("uuid") String uuid, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findDocumentsUsingGET" })
        @GET("api/documents")
        Observable<Response<ResponseBody>> findDocumentsUsingGET(@Query("authorReference") String authorReference, @Query("createdEnd") LocalDate createdEnd, @Query("createdStart") LocalDate createdStart, @Query("directionCode") String directionCode, @Query("documentType") String documentType, @Query("functionGroupUuid") String functionGroupUuid, @Query("functionUuid") String functionUuid, @Query("letterAuthor") String letterAuthor, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("reference") String reference, @Query("seriesUuid") String seriesUuid, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("subseriesUuid") String subseriesUuid, @Query("title") String title, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findCollectiveAddressesUsingGET" })
        @GET("api/documents/collective-addresses")
        Observable<Response<ResponseBody>> findCollectiveAddressesUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findCollectiveAddressUsingGET" })
        @GET("api/documents/collective-addresses/{uuidOrSenderRef}")
        Observable<Response<ResponseBody>> findCollectiveAddressUsingGET(@Path("uuidOrSenderRef") String uuidOrSenderRef);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findOtherQuestionsUsingGET" })
        @GET("api/documents/other-questions")
        Observable<Response<ResponseBody>> findOtherQuestionsUsingGET(@Query("applicantUuid") String applicantUuid, @Query("createdEnd") LocalDate createdEnd, @Query("createdStart") LocalDate createdStart, @Query("dateEnd") LocalDate dateEnd, @Query("dateStart") LocalDate dateStart, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("querySteno") Boolean querySteno, @Query("reference") String reference, @Query("reporterUuid") String reporterUuid, @Query("sittingDateTimeEnd") LocalDate sittingDateTimeEnd, @Query("sittingDateTimeStart") LocalDate sittingDateTimeStart, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("subTypeCode") String subTypeCode, @Query("title") String title, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getDocumentUsingGET" })
        @GET("api/documents/{uuid}")
        Observable<Response<ResponseBody>> getDocumentUsingGET(@Path("uuid") String uuid, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getEventsUsingGET" })
        @GET("api/events")
        Observable<Response<ResponseBody>> getEventsUsingGET(@Query("date") LocalDate dateParameter, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("querySteno") Boolean querySteno, @Query("startDate") LocalDate startDate, @Query("type") String type);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getEventCalendarUsingGET" })
        @GET("api/events/calendar")
        Observable<Response<ResponseBody>> getEventCalendarUsingGET(@Query("committeeGroupUuid") String committeeGroupUuid, @Query("endDate") LocalDate endDate, @Query("startDate") LocalDate startDate, @Query("type") String type);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getFileMetadataUsingGET" })
        @GET("api/files/{uuid}")
        Observable<Response<ResponseBody>> getFileMetadataUsingGET(@Path("uuid") String uuid, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon downloadFileUsingGET" })
        @GET("api/files/{uuid}/download")
        Observable<Response<ResponseBody>> downloadFileUsingGET(@Path("uuid") String uuid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getLatestHallplanUsingGET" })
        @GET("api/hallplan")
        Observable<Response<ResponseBody>> getLatestHallplanUsingGET(@Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getDocumentTreeUsingGET" })
        @GET("api/lists/document-tree")
        Observable<Response<ResponseBody>> getDocumentTreeUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getDocumentTypesUsingGET" })
        @GET("api/lists/document-types")
        Observable<Response<ResponseBody>> getDocumentTypesUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getDraftInitiatorsUsingGET" })
        @GET("api/lists/draft-initiators")
        Observable<Response<ResponseBody>> getDraftInitiatorsUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getVolumeTypesUsingGET" })
        @GET("api/lists/volume-types")
        Observable<Response<ResponseBody>> getVolumeTypesUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getMembershipsUsingGET" })
        @GET("api/memberships")
        Observable<Response<ResponseBody>> getMembershipsUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getCurrentMembershipUsingGET" })
        @GET("api/memberships/current")
        Observable<Response<ResponseBody>> getCurrentMembershipUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getMembershipUsingGET" })
        @GET("api/memberships/{number}")
        Observable<Response<ResponseBody>> getMembershipUsingGET(@Path("number") int number);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenaryMembersUsingGET" })
        @GET("api/plenary-members")
        Observable<Response<ResponseBody>> getPlenaryMembersUsingGET(@Query("committeeUuid") String committeeUuid, @Query("electoralDistrictCodes") String electoralDistrictCodes, @Query("factionUuid") String factionUuid, @Query("includeInactive") Boolean includeInactive, @Query("lang") String lang, @Query("membership") Integer membership, @Query("name") String name);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenaryMemberDetailsUsingGET" })
        @GET("api/plenary-members/{uuid}")
        Observable<Response<ResponseBody>> getPlenaryMemberDetailsUsingGET(@Path("uuid") String uuid, @Query("lang") String lang, @Query("querySteno") Boolean querySteno);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getSessionsUsingGET" })
        @GET("api/sessions")
        Observable<Response<ResponseBody>> getSessionsUsingGET(@Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getCurrentSessionUsingGET" })
        @GET("api/sessions/current")
        Observable<Response<ResponseBody>> getCurrentSessionUsingGET(@Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getFactionParticipationUsingGET" })
        @GET("api/statistics/participations/faction/{uuid}")
        Observable<Response<ResponseBody>> getFactionParticipationUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getMemberParticipationUsingGET" })
        @GET("api/statistics/participations/member/{uuid}")
        Observable<Response<ResponseBody>> getMemberParticipationUsingGET(@Path("uuid") String uuid, @Query("details") Boolean details, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenaryParticipationUsingGET" })
        @GET("api/statistics/participations/plenary")
        Observable<Response<ResponseBody>> getPlenaryParticipationUsingGET(@Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getFactionSpeechStatisticsUsingGET" })
        @GET("api/statistics/speeches/faction/{uuid}")
        Observable<Response<ResponseBody>> getFactionSpeechStatisticsUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getMemberSpeechStatisticsUsingGET" })
        @GET("api/statistics/speeches/member/{uuid}")
        Observable<Response<ResponseBody>> getMemberSpeechStatisticsUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenarySpeechStatisticsUsingGET" })
        @GET("api/statistics/speeches/plenary")
        Observable<Response<ResponseBody>> getPlenarySpeechStatisticsUsingGET(@Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getFactionVotingStatisticsUsingGET" })
        @GET("api/statistics/votings/faction/{uuid}")
        Observable<Response<ResponseBody>> getFactionVotingStatisticsUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getMemberVotingStatisticsUsingGET" })
        @GET("api/statistics/votings/member/{uuid}")
        Observable<Response<ResponseBody>> getMemberVotingStatisticsUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenaryVotingStatisticsUsingGET" })
        @GET("api/statistics/votings/plenary")
        Observable<Response<ResponseBody>> getPlenaryVotingStatisticsUsingGET(@Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getAgendaUrlsUsingGET" })
        @GET("api/steno/agenda")
        Observable<Response<ResponseBody>> getAgendaUrlsUsingGET(@Query("uuids") String uuids);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getLastVerbatimsUsingGET" })
        @GET("api/steno/lastVerbatims")
        Observable<Response<ResponseBody>> getLastVerbatimsUsingGET(@Query("count") Integer count);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getSpeechesUsingGET" })
        @GET("api/steno/speeches")
        Observable<Response<ResponseBody>> getSpeechesUsingGET(@Query("endDate") LocalDate endDate, @Query("membership") Integer membership, @Query("startDate") LocalDate startDate, @Query("userUuids") String userUuids);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getSpeechCountUsingGET" })
        @GET("api/steno/speeches/count")
        Observable<Response<ResponseBody>> getSpeechCountUsingGET(@Query("endDate") LocalDate endDate, @Query("membership") Integer membership, @Query("startDate") LocalDate startDate, @Query("type") String type, @Query("userUuid") String userUuid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getLastSpeechUsingGET" })
        @GET("api/steno/speeches/last")
        Observable<Response<ResponseBody>> getLastSpeechUsingGET(@Query("charCount") Integer charCount, @Query("membership") Integer membership, @Query("type") String type, @Query("userUuid") String userUuid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findUserGroupsUsingGET" })
        @GET("api/usergroups")
        Observable<Response<ResponseBody>> findUserGroupsUsingGET(@Query("hideInactive") Boolean hideInactive, @Query("lang") String lang, @Query("name") String name, @Query("typeCode") String typeCode);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getUserGroupUsingGET" })
        @GET("api/usergroups/{uuid}")
        Observable<Response<ResponseBody>> getUserGroupUsingGET(@Path("uuid") String uuid, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findVolumesUsingGET" })
        @GET("api/volumes")
        Observable<Response<ResponseBody>> findVolumesUsingGET(@Query("createdEndDate") LocalDate createdEndDate, @Query("createdStartDate") LocalDate createdStartDate, @Query("functionGroupUuid") String functionGroupUuid, @Query("functionUuid") String functionUuid, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("reference") String reference, @Query("seriesUuid") String seriesUuid, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("subseriesUuid") String subseriesUuid, @Query("title") String title, @Query("unpaged") Boolean unpaged, @Query("volumeType") String volumeType);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findDraftVolumesUsingGET" })
        @GET("api/volumes/drafts")
        Observable<Response<ResponseBody>> findDraftVolumesUsingGET(@Query("activeDraftStage") String activeDraftStage, @Query("amendmentsDeadlineEndDate") LocalDate amendmentsDeadlineEndDate, @Query("amendmentsDeadlineStartDate") LocalDate amendmentsDeadlineStartDate, @Query("descriptorId") Integer descriptorId, @Query("draftTypeCode") String draftTypeCode, @Query("initiatedEndDate") LocalDate initiatedEndDate, @Query("initiatedStartDate") LocalDate initiatedStartDate, @Query("initiatorUuid") String initiatorUuid, @Query("lang") String lang, @Query("leadingCommitteeUuid") String leadingCommitteeUuid, @Query("mark") Integer mark, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("proceedingStatus") String proceedingStatus, @Query("reference") String reference, @Query("responsibleMemberUuid") String responsibleMemberUuid, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("title") String title, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon testUsingGET" })
        @GET("api/volumes/drafts/test")
        Observable<Response<ResponseBody>> testUsingGET(@Query("offset") Long offset, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getDraftVolumeUsingGET" })
        @GET("api/volumes/drafts/{uuid}")
        Observable<Response<ResponseBody>> getDraftVolumeUsingGET(@Path("uuid") String uuid, @Query("lang") String lang, @Query("querySteno") Boolean querySteno);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findErjkProtocolsUsingGET" })
        @GET("api/volumes/erjk-protocols")
        Observable<Response<ResponseBody>> findErjkProtocolsUsingGET(@Query("sort") String sort, @Query("sorted") Boolean sorted, @Query("unsorted") Boolean unsorted);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findErjkProtocolUsingGET" })
        @GET("api/volumes/erjk-protocols/{uuid}")
        Observable<Response<ResponseBody>> findErjkProtocolUsingGET(@Path("uuid") String uuid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findEuropeanUnionDocumentsUsingGET" })
        @GET("api/volumes/eu")
        Observable<Response<ResponseBody>> findEuropeanUnionDocumentsUsingGET(@Query("createdEndDate") LocalDate createdEndDate, @Query("createdStartDate") LocalDate createdStartDate, @Query("documentType") String documentType, @Query("elMark") String elMark, @Query("elTypeCode") String elTypeCode, @Query("lang") String lang, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("opinionCommitteeUuid") String opinionCommitteeUuid, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("receiveDateEnd") LocalDate receiveDateEnd, @Query("receiveDateStart") LocalDate receiveDateStart, @Query("reference") String reference, @Query("responsibleCommitteeUuid") String responsibleCommitteeUuid, @Query("sectorCode") String sectorCode, @Query("sectorCommitteeUuid") String sectorCommitteeUuid, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("title") String title, @Query("titleEn") String titleEn, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findInterpellationsUsingGET" })
        @GET("api/volumes/interpellations")
        Observable<Response<ResponseBody>> findInterpellationsUsingGET(@Query("enquirerUuid") String enquirerUuid, @Query("lang") String lang, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findWrittenQuestionsUsingGET" })
        @GET("api/volumes/written-questions")
        Observable<Response<ResponseBody>> findWrittenQuestionsUsingGET(@Query("enquirerUuid") String enquirerUuid, @Query("lang") String lang, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getVolumeUsingGET" })
        @GET("api/volumes/{uuid}")
        Observable<Response<ResponseBody>> getVolumeUsingGET(@Path("uuid") String uuid, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getVotingsUsingGET" })
        @GET("api/votings")
        Observable<Response<ResponseBody>> getVotingsUsingGET(@Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getVotingCalendarUsingGET" })
        @GET("api/votings/calendar")
        Observable<Response<ResponseBody>> getVotingCalendarUsingGET(@Query("endDate") LocalDate endDate, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findCommitteeMemberVotingsUsingGET" })
        @GET("api/votings/committees")
        Observable<Response<ResponseBody>> findCommitteeMemberVotingsUsingGET(@Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate, @Query("userUuid") String userUuid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findCommitteeVotingsUsingGET" })
        @GET("api/votings/committees/{uuid}")
        Observable<Response<ResponseBody>> findCommitteeVotingsUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getLastVotingUsingGET" })
        @GET("api/votings/last")
        Observable<Response<ResponseBody>> getLastVotingUsingGET(@Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenaryMemberVotingsUsingGET" })
        @GET("api/votings/plenary-member/{uuid}")
        Observable<Response<ResponseBody>> getPlenaryMemberVotingsUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("offset") Long offset, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("startDate") LocalDate startDate, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getVotingUsingGET" })
        @GET("api/votings/{uuid}")
        Observable<Response<ResponseBody>> getVotingUsingGET(@Path("uuid") String uuid, @Query("lang") String lang);

    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PEvakord object if successful.
     */
    public PEvakord getPlenaryAgendaUsingGET() {
        return getPlenaryAgendaUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PEvakord> getPlenaryAgendaUsingGETAsync(final ServiceCallback<PEvakord> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryAgendaUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PEvakord object
     */
    public Observable<PEvakord> getPlenaryAgendaUsingGETAsync() {
        return getPlenaryAgendaUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PEvakord>, PEvakord>() {
            @Override
            public PEvakord call(ServiceResponse<PEvakord> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PEvakord object
     */
    public Observable<ServiceResponse<PEvakord>> getPlenaryAgendaUsingGETWithServiceResponseAsync() {
        final LocalDate dateParameter = null;
        final LocalDate endDate = null;
        final String lang = null;
        final Boolean querySteno = null;
        final LocalDate startDate = null;
        return service.getPlenaryAgendaUsingGET(dateParameter, endDate, lang, querySteno, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PEvakord>>>() {
                @Override
                public Observable<ServiceResponse<PEvakord>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PEvakord> clientResponse = getPlenaryAgendaUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PEvakord object if successful.
     */
    public PEvakord getPlenaryAgendaUsingGET(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate) {
        return getPlenaryAgendaUsingGETWithServiceResponseAsync(dateParameter, endDate, lang, querySteno, startDate).toBlocking().single().body();
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PEvakord> getPlenaryAgendaUsingGETAsync(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate, final ServiceCallback<PEvakord> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryAgendaUsingGETWithServiceResponseAsync(dateParameter, endDate, lang, querySteno, startDate), serviceCallback);
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PEvakord object
     */
    public Observable<PEvakord> getPlenaryAgendaUsingGETAsync(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate) {
        return getPlenaryAgendaUsingGETWithServiceResponseAsync(dateParameter, endDate, lang, querySteno, startDate).map(new Func1<ServiceResponse<PEvakord>, PEvakord>() {
            @Override
            public PEvakord call(ServiceResponse<PEvakord> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PEvakord object
     */
    public Observable<ServiceResponse<PEvakord>> getPlenaryAgendaUsingGETWithServiceResponseAsync(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate) {
        return service.getPlenaryAgendaUsingGET(dateParameter, endDate, lang, querySteno, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PEvakord>>>() {
                @Override
                public Observable<ServiceResponse<PEvakord>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PEvakord> clientResponse = getPlenaryAgendaUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PEvakord> getPlenaryAgendaUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PEvakord, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PEvakord>() { }.getType())
                .build(response);
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the _ksusePEvakord object if successful.
     */
    public _ksusePEvakord getUnitAgendaUsingGET(String uuid) {
        return getUnitAgendaUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<_ksusePEvakord> getUnitAgendaUsingGETAsync(String uuid, final ServiceCallback<_ksusePEvakord> serviceCallback) {
        return ServiceFuture.fromResponse(getUnitAgendaUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the _ksusePEvakord object
     */
    public Observable<_ksusePEvakord> getUnitAgendaUsingGETAsync(String uuid) {
        return getUnitAgendaUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<_ksusePEvakord>, _ksusePEvakord>() {
            @Override
            public _ksusePEvakord call(ServiceResponse<_ksusePEvakord> response) {
                return response.body();
            }
        });
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the _ksusePEvakord object
     */
    public Observable<ServiceResponse<_ksusePEvakord>> getUnitAgendaUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final LocalDate dateParameter = null;
        final LocalDate endDate = null;
        final String lang = null;
        final LocalDate startDate = null;
        return service.getUnitAgendaUsingGET(uuid, dateParameter, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<_ksusePEvakord>>>() {
                @Override
                public Observable<ServiceResponse<_ksusePEvakord>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<_ksusePEvakord> clientResponse = getUnitAgendaUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the _ksusePEvakord object if successful.
     */
    public _ksusePEvakord getUnitAgendaUsingGET(String uuid, LocalDate dateParameter, LocalDate endDate, String lang, LocalDate startDate) {
        return getUnitAgendaUsingGETWithServiceResponseAsync(uuid, dateParameter, endDate, lang, startDate).toBlocking().single().body();
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<_ksusePEvakord> getUnitAgendaUsingGETAsync(String uuid, LocalDate dateParameter, LocalDate endDate, String lang, LocalDate startDate, final ServiceCallback<_ksusePEvakord> serviceCallback) {
        return ServiceFuture.fromResponse(getUnitAgendaUsingGETWithServiceResponseAsync(uuid, dateParameter, endDate, lang, startDate), serviceCallback);
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the _ksusePEvakord object
     */
    public Observable<_ksusePEvakord> getUnitAgendaUsingGETAsync(String uuid, LocalDate dateParameter, LocalDate endDate, String lang, LocalDate startDate) {
        return getUnitAgendaUsingGETWithServiceResponseAsync(uuid, dateParameter, endDate, lang, startDate).map(new Func1<ServiceResponse<_ksusePEvakord>, _ksusePEvakord>() {
            @Override
            public _ksusePEvakord call(ServiceResponse<_ksusePEvakord> response) {
                return response.body();
            }
        });
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the _ksusePEvakord object
     */
    public Observable<ServiceResponse<_ksusePEvakord>> getUnitAgendaUsingGETWithServiceResponseAsync(String uuid, LocalDate dateParameter, LocalDate endDate, String lang, LocalDate startDate) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getUnitAgendaUsingGET(uuid, dateParameter, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<_ksusePEvakord>>>() {
                @Override
                public Observable<ServiceResponse<_ksusePEvakord>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<_ksusePEvakord> clientResponse = getUnitAgendaUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<_ksusePEvakord> getUnitAgendaUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<_ksusePEvakord, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<_ksusePEvakord>() { }.getType())
                .build(response);
    }

    /**
     * Klassifikaatorid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Klassifikaator&gt; object if successful.
     */
    public List<Klassifikaator> getClassifiersUsingGET() {
        return getClassifiersUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Klassifikaatorid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Klassifikaator>> getClassifiersUsingGETAsync(final ServiceCallback<List<Klassifikaator>> serviceCallback) {
        return ServiceFuture.fromResponse(getClassifiersUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Klassifikaatorid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Klassifikaator&gt; object
     */
    public Observable<List<Klassifikaator>> getClassifiersUsingGETAsync() {
        return getClassifiersUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Klassifikaator>>, List<Klassifikaator>>() {
            @Override
            public List<Klassifikaator> call(ServiceResponse<List<Klassifikaator>> response) {
                return response.body();
            }
        });
    }

    /**
     * Klassifikaatorid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Klassifikaator&gt; object
     */
    public Observable<ServiceResponse<List<Klassifikaator>>> getClassifiersUsingGETWithServiceResponseAsync() {
        return service.getClassifiersUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Klassifikaator>>>>() {
                @Override
                public Observable<ServiceResponse<List<Klassifikaator>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Klassifikaator>> clientResponse = getClassifiersUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Klassifikaator>> getClassifiersUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Klassifikaator>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Klassifikaator>>() { }.getType())
                .build(response);
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the KlassifikaatoriVRtusDetailid object if successful.
     */
    public KlassifikaatoriVRtusDetailid getClassifierValueUsingGET(String classifierCode, String valueCode) {
        return getClassifierValueUsingGETWithServiceResponseAsync(classifierCode, valueCode).toBlocking().single().body();
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<KlassifikaatoriVRtusDetailid> getClassifierValueUsingGETAsync(String classifierCode, String valueCode, final ServiceCallback<KlassifikaatoriVRtusDetailid> serviceCallback) {
        return ServiceFuture.fromResponse(getClassifierValueUsingGETWithServiceResponseAsync(classifierCode, valueCode), serviceCallback);
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KlassifikaatoriVRtusDetailid object
     */
    public Observable<KlassifikaatoriVRtusDetailid> getClassifierValueUsingGETAsync(String classifierCode, String valueCode) {
        return getClassifierValueUsingGETWithServiceResponseAsync(classifierCode, valueCode).map(new Func1<ServiceResponse<KlassifikaatoriVRtusDetailid>, KlassifikaatoriVRtusDetailid>() {
            @Override
            public KlassifikaatoriVRtusDetailid call(ServiceResponse<KlassifikaatoriVRtusDetailid> response) {
                return response.body();
            }
        });
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KlassifikaatoriVRtusDetailid object
     */
    public Observable<ServiceResponse<KlassifikaatoriVRtusDetailid>> getClassifierValueUsingGETWithServiceResponseAsync(String classifierCode, String valueCode) {
        if (classifierCode == null) {
            throw new IllegalArgumentException("Parameter classifierCode is required and cannot be null.");
        }
        if (valueCode == null) {
            throw new IllegalArgumentException("Parameter valueCode is required and cannot be null.");
        }
        final String lang = null;
        return service.getClassifierValueUsingGET(classifierCode, valueCode, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<KlassifikaatoriVRtusDetailid>>>() {
                @Override
                public Observable<ServiceResponse<KlassifikaatoriVRtusDetailid>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<KlassifikaatoriVRtusDetailid> clientResponse = getClassifierValueUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the KlassifikaatoriVRtusDetailid object if successful.
     */
    public KlassifikaatoriVRtusDetailid getClassifierValueUsingGET(String classifierCode, String valueCode, String lang) {
        return getClassifierValueUsingGETWithServiceResponseAsync(classifierCode, valueCode, lang).toBlocking().single().body();
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<KlassifikaatoriVRtusDetailid> getClassifierValueUsingGETAsync(String classifierCode, String valueCode, String lang, final ServiceCallback<KlassifikaatoriVRtusDetailid> serviceCallback) {
        return ServiceFuture.fromResponse(getClassifierValueUsingGETWithServiceResponseAsync(classifierCode, valueCode, lang), serviceCallback);
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KlassifikaatoriVRtusDetailid object
     */
    public Observable<KlassifikaatoriVRtusDetailid> getClassifierValueUsingGETAsync(String classifierCode, String valueCode, String lang) {
        return getClassifierValueUsingGETWithServiceResponseAsync(classifierCode, valueCode, lang).map(new Func1<ServiceResponse<KlassifikaatoriVRtusDetailid>, KlassifikaatoriVRtusDetailid>() {
            @Override
            public KlassifikaatoriVRtusDetailid call(ServiceResponse<KlassifikaatoriVRtusDetailid> response) {
                return response.body();
            }
        });
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KlassifikaatoriVRtusDetailid object
     */
    public Observable<ServiceResponse<KlassifikaatoriVRtusDetailid>> getClassifierValueUsingGETWithServiceResponseAsync(String classifierCode, String valueCode, String lang) {
        if (classifierCode == null) {
            throw new IllegalArgumentException("Parameter classifierCode is required and cannot be null.");
        }
        if (valueCode == null) {
            throw new IllegalArgumentException("Parameter valueCode is required and cannot be null.");
        }
        return service.getClassifierValueUsingGET(classifierCode, valueCode, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<KlassifikaatoriVRtusDetailid>>>() {
                @Override
                public Observable<ServiceResponse<KlassifikaatoriVRtusDetailid>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<KlassifikaatoriVRtusDetailid> clientResponse = getClassifierValueUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<KlassifikaatoriVRtusDetailid> getClassifierValueUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<KlassifikaatoriVRtusDetailid, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<KlassifikaatoriVRtusDetailid>() { }.getType())
                .build(response);
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;KlassifikaatoriVRtusDetailid&gt; object if successful.
     */
    public List<KlassifikaatoriVRtusDetailid> getClassifierValuesUsingGET(String code) {
        return getClassifierValuesUsingGETWithServiceResponseAsync(code).toBlocking().single().body();
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<KlassifikaatoriVRtusDetailid>> getClassifierValuesUsingGETAsync(String code, final ServiceCallback<List<KlassifikaatoriVRtusDetailid>> serviceCallback) {
        return ServiceFuture.fromResponse(getClassifierValuesUsingGETWithServiceResponseAsync(code), serviceCallback);
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KlassifikaatoriVRtusDetailid&gt; object
     */
    public Observable<List<KlassifikaatoriVRtusDetailid>> getClassifierValuesUsingGETAsync(String code) {
        return getClassifierValuesUsingGETWithServiceResponseAsync(code).map(new Func1<ServiceResponse<List<KlassifikaatoriVRtusDetailid>>, List<KlassifikaatoriVRtusDetailid>>() {
            @Override
            public List<KlassifikaatoriVRtusDetailid> call(ServiceResponse<List<KlassifikaatoriVRtusDetailid>> response) {
                return response.body();
            }
        });
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KlassifikaatoriVRtusDetailid&gt; object
     */
    public Observable<ServiceResponse<List<KlassifikaatoriVRtusDetailid>>> getClassifierValuesUsingGETWithServiceResponseAsync(String code) {
        if (code == null) {
            throw new IllegalArgumentException("Parameter code is required and cannot be null.");
        }
        final Boolean includeInactive = null;
        final String lang = null;
        return service.getClassifierValuesUsingGET(code, includeInactive, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<KlassifikaatoriVRtusDetailid>>>>() {
                @Override
                public Observable<ServiceResponse<List<KlassifikaatoriVRtusDetailid>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<KlassifikaatoriVRtusDetailid>> clientResponse = getClassifierValuesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @param includeInactive Kaasa mitteaktiivsed väärtused? (true/false)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;KlassifikaatoriVRtusDetailid&gt; object if successful.
     */
    public List<KlassifikaatoriVRtusDetailid> getClassifierValuesUsingGET(String code, Boolean includeInactive, String lang) {
        return getClassifierValuesUsingGETWithServiceResponseAsync(code, includeInactive, lang).toBlocking().single().body();
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @param includeInactive Kaasa mitteaktiivsed väärtused? (true/false)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<KlassifikaatoriVRtusDetailid>> getClassifierValuesUsingGETAsync(String code, Boolean includeInactive, String lang, final ServiceCallback<List<KlassifikaatoriVRtusDetailid>> serviceCallback) {
        return ServiceFuture.fromResponse(getClassifierValuesUsingGETWithServiceResponseAsync(code, includeInactive, lang), serviceCallback);
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @param includeInactive Kaasa mitteaktiivsed väärtused? (true/false)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KlassifikaatoriVRtusDetailid&gt; object
     */
    public Observable<List<KlassifikaatoriVRtusDetailid>> getClassifierValuesUsingGETAsync(String code, Boolean includeInactive, String lang) {
        return getClassifierValuesUsingGETWithServiceResponseAsync(code, includeInactive, lang).map(new Func1<ServiceResponse<List<KlassifikaatoriVRtusDetailid>>, List<KlassifikaatoriVRtusDetailid>>() {
            @Override
            public List<KlassifikaatoriVRtusDetailid> call(ServiceResponse<List<KlassifikaatoriVRtusDetailid>> response) {
                return response.body();
            }
        });
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @param includeInactive Kaasa mitteaktiivsed väärtused? (true/false)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KlassifikaatoriVRtusDetailid&gt; object
     */
    public Observable<ServiceResponse<List<KlassifikaatoriVRtusDetailid>>> getClassifierValuesUsingGETWithServiceResponseAsync(String code, Boolean includeInactive, String lang) {
        if (code == null) {
            throw new IllegalArgumentException("Parameter code is required and cannot be null.");
        }
        return service.getClassifierValuesUsingGET(code, includeInactive, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<KlassifikaatoriVRtusDetailid>>>>() {
                @Override
                public Observable<ServiceResponse<List<KlassifikaatoriVRtusDetailid>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<KlassifikaatoriVRtusDetailid>> clientResponse = getClassifierValuesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<KlassifikaatoriVRtusDetailid>> getClassifierValuesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<KlassifikaatoriVRtusDetailid>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<KlassifikaatoriVRtusDetailid>>() { }.getType())
                .build(response);
    }

    /**
     * Kontaktide nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;KasutajagruppKontaktid&gt; object if successful.
     */
    public List<KasutajagruppKontaktid> getContactsUsingGET() {
        return getContactsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Kontaktide nimekiri.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<KasutajagruppKontaktid>> getContactsUsingGETAsync(final ServiceCallback<List<KasutajagruppKontaktid>> serviceCallback) {
        return ServiceFuture.fromResponse(getContactsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Kontaktide nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KasutajagruppKontaktid&gt; object
     */
    public Observable<List<KasutajagruppKontaktid>> getContactsUsingGETAsync() {
        return getContactsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<KasutajagruppKontaktid>>, List<KasutajagruppKontaktid>>() {
            @Override
            public List<KasutajagruppKontaktid> call(ServiceResponse<List<KasutajagruppKontaktid>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kontaktide nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KasutajagruppKontaktid&gt; object
     */
    public Observable<ServiceResponse<List<KasutajagruppKontaktid>>> getContactsUsingGETWithServiceResponseAsync() {
        final String lang = null;
        return service.getContactsUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<KasutajagruppKontaktid>>>>() {
                @Override
                public Observable<ServiceResponse<List<KasutajagruppKontaktid>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<KasutajagruppKontaktid>> clientResponse = getContactsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Kontaktide nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;KasutajagruppKontaktid&gt; object if successful.
     */
    public List<KasutajagruppKontaktid> getContactsUsingGET(String lang) {
        return getContactsUsingGETWithServiceResponseAsync(lang).toBlocking().single().body();
    }

    /**
     * Kontaktide nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<KasutajagruppKontaktid>> getContactsUsingGETAsync(String lang, final ServiceCallback<List<KasutajagruppKontaktid>> serviceCallback) {
        return ServiceFuture.fromResponse(getContactsUsingGETWithServiceResponseAsync(lang), serviceCallback);
    }

    /**
     * Kontaktide nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KasutajagruppKontaktid&gt; object
     */
    public Observable<List<KasutajagruppKontaktid>> getContactsUsingGETAsync(String lang) {
        return getContactsUsingGETWithServiceResponseAsync(lang).map(new Func1<ServiceResponse<List<KasutajagruppKontaktid>>, List<KasutajagruppKontaktid>>() {
            @Override
            public List<KasutajagruppKontaktid> call(ServiceResponse<List<KasutajagruppKontaktid>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kontaktide nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KasutajagruppKontaktid&gt; object
     */
    public Observable<ServiceResponse<List<KasutajagruppKontaktid>>> getContactsUsingGETWithServiceResponseAsync(String lang) {
        return service.getContactsUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<KasutajagruppKontaktid>>>>() {
                @Override
                public Observable<ServiceResponse<List<KasutajagruppKontaktid>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<KasutajagruppKontaktid>> clientResponse = getContactsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<KasutajagruppKontaktid>> getContactsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<KasutajagruppKontaktid>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<KasutajagruppKontaktid>>() { }.getType())
                .build(response);
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the KasutajaDetailidKontaktid object if successful.
     */
    public KasutajaDetailidKontaktid getUserDetailsUsingGET(String uuid) {
        return getUserDetailsUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<KasutajaDetailidKontaktid> getUserDetailsUsingGETAsync(String uuid, final ServiceCallback<KasutajaDetailidKontaktid> serviceCallback) {
        return ServiceFuture.fromResponse(getUserDetailsUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KasutajaDetailidKontaktid object
     */
    public Observable<KasutajaDetailidKontaktid> getUserDetailsUsingGETAsync(String uuid) {
        return getUserDetailsUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<KasutajaDetailidKontaktid>, KasutajaDetailidKontaktid>() {
            @Override
            public KasutajaDetailidKontaktid call(ServiceResponse<KasutajaDetailidKontaktid> response) {
                return response.body();
            }
        });
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KasutajaDetailidKontaktid object
     */
    public Observable<ServiceResponse<KasutajaDetailidKontaktid>> getUserDetailsUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getUserDetailsUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<KasutajaDetailidKontaktid>>>() {
                @Override
                public Observable<ServiceResponse<KasutajaDetailidKontaktid>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<KasutajaDetailidKontaktid> clientResponse = getUserDetailsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the KasutajaDetailidKontaktid object if successful.
     */
    public KasutajaDetailidKontaktid getUserDetailsUsingGET(String uuid, String lang) {
        return getUserDetailsUsingGETWithServiceResponseAsync(uuid, lang).toBlocking().single().body();
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<KasutajaDetailidKontaktid> getUserDetailsUsingGETAsync(String uuid, String lang, final ServiceCallback<KasutajaDetailidKontaktid> serviceCallback) {
        return ServiceFuture.fromResponse(getUserDetailsUsingGETWithServiceResponseAsync(uuid, lang), serviceCallback);
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KasutajaDetailidKontaktid object
     */
    public Observable<KasutajaDetailidKontaktid> getUserDetailsUsingGETAsync(String uuid, String lang) {
        return getUserDetailsUsingGETWithServiceResponseAsync(uuid, lang).map(new Func1<ServiceResponse<KasutajaDetailidKontaktid>, KasutajaDetailidKontaktid>() {
            @Override
            public KasutajaDetailidKontaktid call(ServiceResponse<KasutajaDetailidKontaktid> response) {
                return response.body();
            }
        });
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KasutajaDetailidKontaktid object
     */
    public Observable<ServiceResponse<KasutajaDetailidKontaktid>> getUserDetailsUsingGETWithServiceResponseAsync(String uuid, String lang) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getUserDetailsUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<KasutajaDetailidKontaktid>>>() {
                @Override
                public Observable<ServiceResponse<KasutajaDetailidKontaktid>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<KasutajaDetailidKontaktid> clientResponse = getUserDetailsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<KasutajaDetailidKontaktid> getUserDetailsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<KasutajaDetailidKontaktid, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<KasutajaDetailidKontaktid>() { }.getType())
                .build(response);
    }

    /**
     * Dokumentide otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesDokument object if successful.
     */
    public PagedResourcesDokument findDocumentsUsingGET() {
        return findDocumentsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Dokumentide otsing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesDokument> findDocumentsUsingGETAsync(final ServiceCallback<PagedResourcesDokument> serviceCallback) {
        return ServiceFuture.fromResponse(findDocumentsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Dokumentide otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesDokument object
     */
    public Observable<PagedResourcesDokument> findDocumentsUsingGETAsync() {
        return findDocumentsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesDokument>, PagedResourcesDokument>() {
            @Override
            public PagedResourcesDokument call(ServiceResponse<PagedResourcesDokument> response) {
                return response.body();
            }
        });
    }

    /**
     * Dokumentide otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesDokument object
     */
    public Observable<ServiceResponse<PagedResourcesDokument>> findDocumentsUsingGETWithServiceResponseAsync() {
        final String authorReference = null;
        final LocalDate createdEnd = null;
        final LocalDate createdStart = null;
        final String directionCode = null;
        final String documentType = null;
        final String functionGroupUuid = null;
        final String functionUuid = null;
        final String letterAuthor = null;
        final Integer membership = null;
        final Long offset = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final String reference = null;
        final String seriesUuid = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final String subseriesUuid = null;
        final String title = null;
        final Boolean unpaged = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findDocumentsUsingGET(authorReference, createdEnd, createdStart, directionCode, documentType, functionGroupUuid, functionUuid, letterAuthor, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sortConverted, sortsorted, sortunsorted, subseriesUuid, title, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesDokument>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesDokument>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesDokument> clientResponse = findDocumentsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Dokumentide otsing.
     *
     * @param authorReference [Kiri] Autori viit
     * @param createdEnd Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStart Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param directionCode [Kiri] Suund (klassifikaator 'kirjaSuund'). Possible values include: 'SISEMINE', 'SISSE', 'VALJA'
     * @param documentType Dokumendi liik. Possible values include: 'yldine', 'lugemiseTekst', 'muudatusettepanek', 'muudatusettepanekugaLiitumine', 'meLoetelu', 'plenaryAgendaItemDocument', 'unitAgendaItemDocument', 'infoAgendaItemDocument', 'interpellationsAgendaItemDocument', 'algtekst', 'lopptekst', 'seletuskiri', 'protokoll', 'interpellationsDocument', 'interpellationsAnswerDocument', 'opinionDocument', 'applicationDocument', 'excursionDocument', 'translationDocument', 'writtenQuestionDocument', 'writtenQuestionAnswerDocument', 'letterDocument', 'directiveDocument', 'pressReleaseDocument', 'decisionDocument', 'otherQuestionDocument', 'officialJourneyDocument', 'orderDocument', 'orderImplementationDocument', 'contractDocument', 'pursueDocument', 'elDocument', 'commissionOpinionDocument', 'vabariigiPresidendiOtsus', 'lisadokumendid', 'aruanne', 'taiskoguToonadalaProtokoll', 'riigikoguSeisukoht', 'uuring', 'meAllkirjastamine', 'jobDescriptionDocument', 'collectiveAddressDocument'
     * @param functionGroupUuid Funktsioonigrupi UUID
     * @param functionUuid Funktsiooni UUID
     * @param letterAuthor [Kiri] Autor
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesDokument object if successful.
     */
    public PagedResourcesDokument findDocumentsUsingGET(String authorReference, LocalDate createdEnd, LocalDate createdStart, String directionCode, String documentType, String functionGroupUuid, String functionUuid, String letterAuthor, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged) {
        return findDocumentsUsingGETWithServiceResponseAsync(authorReference, createdEnd, createdStart, directionCode, documentType, functionGroupUuid, functionUuid, letterAuthor, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sort, sortsorted, sortunsorted, subseriesUuid, title, unpaged).toBlocking().single().body();
    }

    /**
     * Dokumentide otsing.
     *
     * @param authorReference [Kiri] Autori viit
     * @param createdEnd Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStart Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param directionCode [Kiri] Suund (klassifikaator 'kirjaSuund'). Possible values include: 'SISEMINE', 'SISSE', 'VALJA'
     * @param documentType Dokumendi liik. Possible values include: 'yldine', 'lugemiseTekst', 'muudatusettepanek', 'muudatusettepanekugaLiitumine', 'meLoetelu', 'plenaryAgendaItemDocument', 'unitAgendaItemDocument', 'infoAgendaItemDocument', 'interpellationsAgendaItemDocument', 'algtekst', 'lopptekst', 'seletuskiri', 'protokoll', 'interpellationsDocument', 'interpellationsAnswerDocument', 'opinionDocument', 'applicationDocument', 'excursionDocument', 'translationDocument', 'writtenQuestionDocument', 'writtenQuestionAnswerDocument', 'letterDocument', 'directiveDocument', 'pressReleaseDocument', 'decisionDocument', 'otherQuestionDocument', 'officialJourneyDocument', 'orderDocument', 'orderImplementationDocument', 'contractDocument', 'pursueDocument', 'elDocument', 'commissionOpinionDocument', 'vabariigiPresidendiOtsus', 'lisadokumendid', 'aruanne', 'taiskoguToonadalaProtokoll', 'riigikoguSeisukoht', 'uuring', 'meAllkirjastamine', 'jobDescriptionDocument', 'collectiveAddressDocument'
     * @param functionGroupUuid Funktsioonigrupi UUID
     * @param functionUuid Funktsiooni UUID
     * @param letterAuthor [Kiri] Autor
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesDokument> findDocumentsUsingGETAsync(String authorReference, LocalDate createdEnd, LocalDate createdStart, String directionCode, String documentType, String functionGroupUuid, String functionUuid, String letterAuthor, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged, final ServiceCallback<PagedResourcesDokument> serviceCallback) {
        return ServiceFuture.fromResponse(findDocumentsUsingGETWithServiceResponseAsync(authorReference, createdEnd, createdStart, directionCode, documentType, functionGroupUuid, functionUuid, letterAuthor, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sort, sortsorted, sortunsorted, subseriesUuid, title, unpaged), serviceCallback);
    }

    /**
     * Dokumentide otsing.
     *
     * @param authorReference [Kiri] Autori viit
     * @param createdEnd Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStart Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param directionCode [Kiri] Suund (klassifikaator 'kirjaSuund'). Possible values include: 'SISEMINE', 'SISSE', 'VALJA'
     * @param documentType Dokumendi liik. Possible values include: 'yldine', 'lugemiseTekst', 'muudatusettepanek', 'muudatusettepanekugaLiitumine', 'meLoetelu', 'plenaryAgendaItemDocument', 'unitAgendaItemDocument', 'infoAgendaItemDocument', 'interpellationsAgendaItemDocument', 'algtekst', 'lopptekst', 'seletuskiri', 'protokoll', 'interpellationsDocument', 'interpellationsAnswerDocument', 'opinionDocument', 'applicationDocument', 'excursionDocument', 'translationDocument', 'writtenQuestionDocument', 'writtenQuestionAnswerDocument', 'letterDocument', 'directiveDocument', 'pressReleaseDocument', 'decisionDocument', 'otherQuestionDocument', 'officialJourneyDocument', 'orderDocument', 'orderImplementationDocument', 'contractDocument', 'pursueDocument', 'elDocument', 'commissionOpinionDocument', 'vabariigiPresidendiOtsus', 'lisadokumendid', 'aruanne', 'taiskoguToonadalaProtokoll', 'riigikoguSeisukoht', 'uuring', 'meAllkirjastamine', 'jobDescriptionDocument', 'collectiveAddressDocument'
     * @param functionGroupUuid Funktsioonigrupi UUID
     * @param functionUuid Funktsiooni UUID
     * @param letterAuthor [Kiri] Autor
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesDokument object
     */
    public Observable<PagedResourcesDokument> findDocumentsUsingGETAsync(String authorReference, LocalDate createdEnd, LocalDate createdStart, String directionCode, String documentType, String functionGroupUuid, String functionUuid, String letterAuthor, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged) {
        return findDocumentsUsingGETWithServiceResponseAsync(authorReference, createdEnd, createdStart, directionCode, documentType, functionGroupUuid, functionUuid, letterAuthor, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sort, sortsorted, sortunsorted, subseriesUuid, title, unpaged).map(new Func1<ServiceResponse<PagedResourcesDokument>, PagedResourcesDokument>() {
            @Override
            public PagedResourcesDokument call(ServiceResponse<PagedResourcesDokument> response) {
                return response.body();
            }
        });
    }

    /**
     * Dokumentide otsing.
     *
     * @param authorReference [Kiri] Autori viit
     * @param createdEnd Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStart Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param directionCode [Kiri] Suund (klassifikaator 'kirjaSuund'). Possible values include: 'SISEMINE', 'SISSE', 'VALJA'
     * @param documentType Dokumendi liik. Possible values include: 'yldine', 'lugemiseTekst', 'muudatusettepanek', 'muudatusettepanekugaLiitumine', 'meLoetelu', 'plenaryAgendaItemDocument', 'unitAgendaItemDocument', 'infoAgendaItemDocument', 'interpellationsAgendaItemDocument', 'algtekst', 'lopptekst', 'seletuskiri', 'protokoll', 'interpellationsDocument', 'interpellationsAnswerDocument', 'opinionDocument', 'applicationDocument', 'excursionDocument', 'translationDocument', 'writtenQuestionDocument', 'writtenQuestionAnswerDocument', 'letterDocument', 'directiveDocument', 'pressReleaseDocument', 'decisionDocument', 'otherQuestionDocument', 'officialJourneyDocument', 'orderDocument', 'orderImplementationDocument', 'contractDocument', 'pursueDocument', 'elDocument', 'commissionOpinionDocument', 'vabariigiPresidendiOtsus', 'lisadokumendid', 'aruanne', 'taiskoguToonadalaProtokoll', 'riigikoguSeisukoht', 'uuring', 'meAllkirjastamine', 'jobDescriptionDocument', 'collectiveAddressDocument'
     * @param functionGroupUuid Funktsioonigrupi UUID
     * @param functionUuid Funktsiooni UUID
     * @param letterAuthor [Kiri] Autor
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesDokument object
     */
    public Observable<ServiceResponse<PagedResourcesDokument>> findDocumentsUsingGETWithServiceResponseAsync(String authorReference, LocalDate createdEnd, LocalDate createdStart, String directionCode, String documentType, String functionGroupUuid, String functionUuid, String letterAuthor, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findDocumentsUsingGET(authorReference, createdEnd, createdStart, directionCode, documentType, functionGroupUuid, functionUuid, letterAuthor, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sortConverted, sortsorted, sortunsorted, subseriesUuid, title, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesDokument>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesDokument>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesDokument> clientResponse = findDocumentsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesDokument> findDocumentsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesDokument, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesDokument>() { }.getType())
                .build(response);
    }

    /**
     * Kollektiivsed pöördumised.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;KollektiivnePRdumineDokument&gt; object if successful.
     */
    public List<KollektiivnePRdumineDokument> findCollectiveAddressesUsingGET() {
        return findCollectiveAddressesUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Kollektiivsed pöördumised.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<KollektiivnePRdumineDokument>> findCollectiveAddressesUsingGETAsync(final ServiceCallback<List<KollektiivnePRdumineDokument>> serviceCallback) {
        return ServiceFuture.fromResponse(findCollectiveAddressesUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Kollektiivsed pöördumised.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KollektiivnePRdumineDokument&gt; object
     */
    public Observable<List<KollektiivnePRdumineDokument>> findCollectiveAddressesUsingGETAsync() {
        return findCollectiveAddressesUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<KollektiivnePRdumineDokument>>, List<KollektiivnePRdumineDokument>>() {
            @Override
            public List<KollektiivnePRdumineDokument> call(ServiceResponse<List<KollektiivnePRdumineDokument>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kollektiivsed pöördumised.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KollektiivnePRdumineDokument&gt; object
     */
    public Observable<ServiceResponse<List<KollektiivnePRdumineDokument>>> findCollectiveAddressesUsingGETWithServiceResponseAsync() {
        return service.findCollectiveAddressesUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<KollektiivnePRdumineDokument>>>>() {
                @Override
                public Observable<ServiceResponse<List<KollektiivnePRdumineDokument>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<KollektiivnePRdumineDokument>> clientResponse = findCollectiveAddressesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<KollektiivnePRdumineDokument>> findCollectiveAddressesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<KollektiivnePRdumineDokument>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<KollektiivnePRdumineDokument>>() { }.getType())
                .build(response);
    }

    /**
     * Kollektiivse pöördumise detailid.
     *
     * @param uuidOrSenderRef Dokumendi UUID või saatja viit
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the KollektiivnePRdumineDokument object if successful.
     */
    public KollektiivnePRdumineDokument findCollectiveAddressUsingGET(String uuidOrSenderRef) {
        return findCollectiveAddressUsingGETWithServiceResponseAsync(uuidOrSenderRef).toBlocking().single().body();
    }

    /**
     * Kollektiivse pöördumise detailid.
     *
     * @param uuidOrSenderRef Dokumendi UUID või saatja viit
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<KollektiivnePRdumineDokument> findCollectiveAddressUsingGETAsync(String uuidOrSenderRef, final ServiceCallback<KollektiivnePRdumineDokument> serviceCallback) {
        return ServiceFuture.fromResponse(findCollectiveAddressUsingGETWithServiceResponseAsync(uuidOrSenderRef), serviceCallback);
    }

    /**
     * Kollektiivse pöördumise detailid.
     *
     * @param uuidOrSenderRef Dokumendi UUID või saatja viit
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KollektiivnePRdumineDokument object
     */
    public Observable<KollektiivnePRdumineDokument> findCollectiveAddressUsingGETAsync(String uuidOrSenderRef) {
        return findCollectiveAddressUsingGETWithServiceResponseAsync(uuidOrSenderRef).map(new Func1<ServiceResponse<KollektiivnePRdumineDokument>, KollektiivnePRdumineDokument>() {
            @Override
            public KollektiivnePRdumineDokument call(ServiceResponse<KollektiivnePRdumineDokument> response) {
                return response.body();
            }
        });
    }

    /**
     * Kollektiivse pöördumise detailid.
     *
     * @param uuidOrSenderRef Dokumendi UUID või saatja viit
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the KollektiivnePRdumineDokument object
     */
    public Observable<ServiceResponse<KollektiivnePRdumineDokument>> findCollectiveAddressUsingGETWithServiceResponseAsync(String uuidOrSenderRef) {
        if (uuidOrSenderRef == null) {
            throw new IllegalArgumentException("Parameter uuidOrSenderRef is required and cannot be null.");
        }
        return service.findCollectiveAddressUsingGET(uuidOrSenderRef)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<KollektiivnePRdumineDokument>>>() {
                @Override
                public Observable<ServiceResponse<KollektiivnePRdumineDokument>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<KollektiivnePRdumineDokument> clientResponse = findCollectiveAddressUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<KollektiivnePRdumineDokument> findCollectiveAddressUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<KollektiivnePRdumineDokument, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<KollektiivnePRdumineDokument>() { }.getType())
                .build(response);
    }

    /**
     * Muud küsimused.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesDokumentMuuKSimus object if successful.
     */
    public PagedResourcesDokumentMuuKSimus findOtherQuestionsUsingGET() {
        return findOtherQuestionsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Muud küsimused.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesDokumentMuuKSimus> findOtherQuestionsUsingGETAsync(final ServiceCallback<PagedResourcesDokumentMuuKSimus> serviceCallback) {
        return ServiceFuture.fromResponse(findOtherQuestionsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Muud küsimused.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesDokumentMuuKSimus object
     */
    public Observable<PagedResourcesDokumentMuuKSimus> findOtherQuestionsUsingGETAsync() {
        return findOtherQuestionsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesDokumentMuuKSimus>, PagedResourcesDokumentMuuKSimus>() {
            @Override
            public PagedResourcesDokumentMuuKSimus call(ServiceResponse<PagedResourcesDokumentMuuKSimus> response) {
                return response.body();
            }
        });
    }

    /**
     * Muud küsimused.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesDokumentMuuKSimus object
     */
    public Observable<ServiceResponse<PagedResourcesDokumentMuuKSimus>> findOtherQuestionsUsingGETWithServiceResponseAsync() {
        final String applicantUuid = null;
        final LocalDate createdEnd = null;
        final LocalDate createdStart = null;
        final LocalDate dateEnd = null;
        final LocalDate dateStart = null;
        final Integer membership = null;
        final Long offset = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final Boolean querySteno = null;
        final String reference = null;
        final String reporterUuid = null;
        final LocalDate sittingDateTimeEnd = null;
        final LocalDate sittingDateTimeStart = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final List<String> subTypeCode = null;
        final String title = null;
        final Boolean unpaged = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);String subTypeCodeConverted = this.serializerAdapter().serializeList(subTypeCode, CollectionFormat.MULTI);
        return service.findOtherQuestionsUsingGET(applicantUuid, createdEnd, createdStart, dateEnd, dateStart, membership, offset, page, pageNumber, pageSize, paged, querySteno, reference, reporterUuid, sittingDateTimeEnd, sittingDateTimeStart, size, sortConverted, sortsorted, sortunsorted, subTypeCodeConverted, title, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesDokumentMuuKSimus>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesDokumentMuuKSimus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesDokumentMuuKSimus> clientResponse = findOtherQuestionsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Muud küsimused.
     *
     * @param applicantUuid Esitaja UUID
     * @param createdEnd Loomise lõppkuupäev (yyyy-MM-dd)
     * @param createdStart Loomise alguskuupäev (yyyy-MM-dd)
     * @param dateEnd Dokumendi kuupäeva lõpp (yyyy-MM-dd)
     * @param dateStart Dokumendi kuupäeva algus (yyyy-MM-dd)
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param reference Viit
     * @param reporterUuid Ettekandja UUID
     * @param sittingDateTimeEnd Seotud täiskogu istungi kuupäeva lõpp (yyyy-MM-dd)
     * @param sittingDateTimeStart Seotud täiskogu istungi kuupäeva algus (yyyy-MM-dd)
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subTypeCode Alamtüübi kood. Lubatud mitu väärtust.
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesDokumentMuuKSimus object if successful.
     */
    public PagedResourcesDokumentMuuKSimus findOtherQuestionsUsingGET(String applicantUuid, LocalDate createdEnd, LocalDate createdStart, LocalDate dateEnd, LocalDate dateStart, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Boolean querySteno, String reference, String reporterUuid, LocalDate sittingDateTimeEnd, LocalDate sittingDateTimeStart, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, List<String> subTypeCode, String title, Boolean unpaged) {
        return findOtherQuestionsUsingGETWithServiceResponseAsync(applicantUuid, createdEnd, createdStart, dateEnd, dateStart, membership, offset, page, pageNumber, pageSize, paged, querySteno, reference, reporterUuid, sittingDateTimeEnd, sittingDateTimeStart, size, sort, sortsorted, sortunsorted, subTypeCode, title, unpaged).toBlocking().single().body();
    }

    /**
     * Muud küsimused.
     *
     * @param applicantUuid Esitaja UUID
     * @param createdEnd Loomise lõppkuupäev (yyyy-MM-dd)
     * @param createdStart Loomise alguskuupäev (yyyy-MM-dd)
     * @param dateEnd Dokumendi kuupäeva lõpp (yyyy-MM-dd)
     * @param dateStart Dokumendi kuupäeva algus (yyyy-MM-dd)
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param reference Viit
     * @param reporterUuid Ettekandja UUID
     * @param sittingDateTimeEnd Seotud täiskogu istungi kuupäeva lõpp (yyyy-MM-dd)
     * @param sittingDateTimeStart Seotud täiskogu istungi kuupäeva algus (yyyy-MM-dd)
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subTypeCode Alamtüübi kood. Lubatud mitu väärtust.
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesDokumentMuuKSimus> findOtherQuestionsUsingGETAsync(String applicantUuid, LocalDate createdEnd, LocalDate createdStart, LocalDate dateEnd, LocalDate dateStart, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Boolean querySteno, String reference, String reporterUuid, LocalDate sittingDateTimeEnd, LocalDate sittingDateTimeStart, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, List<String> subTypeCode, String title, Boolean unpaged, final ServiceCallback<PagedResourcesDokumentMuuKSimus> serviceCallback) {
        return ServiceFuture.fromResponse(findOtherQuestionsUsingGETWithServiceResponseAsync(applicantUuid, createdEnd, createdStart, dateEnd, dateStart, membership, offset, page, pageNumber, pageSize, paged, querySteno, reference, reporterUuid, sittingDateTimeEnd, sittingDateTimeStart, size, sort, sortsorted, sortunsorted, subTypeCode, title, unpaged), serviceCallback);
    }

    /**
     * Muud küsimused.
     *
     * @param applicantUuid Esitaja UUID
     * @param createdEnd Loomise lõppkuupäev (yyyy-MM-dd)
     * @param createdStart Loomise alguskuupäev (yyyy-MM-dd)
     * @param dateEnd Dokumendi kuupäeva lõpp (yyyy-MM-dd)
     * @param dateStart Dokumendi kuupäeva algus (yyyy-MM-dd)
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param reference Viit
     * @param reporterUuid Ettekandja UUID
     * @param sittingDateTimeEnd Seotud täiskogu istungi kuupäeva lõpp (yyyy-MM-dd)
     * @param sittingDateTimeStart Seotud täiskogu istungi kuupäeva algus (yyyy-MM-dd)
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subTypeCode Alamtüübi kood. Lubatud mitu väärtust.
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesDokumentMuuKSimus object
     */
    public Observable<PagedResourcesDokumentMuuKSimus> findOtherQuestionsUsingGETAsync(String applicantUuid, LocalDate createdEnd, LocalDate createdStart, LocalDate dateEnd, LocalDate dateStart, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Boolean querySteno, String reference, String reporterUuid, LocalDate sittingDateTimeEnd, LocalDate sittingDateTimeStart, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, List<String> subTypeCode, String title, Boolean unpaged) {
        return findOtherQuestionsUsingGETWithServiceResponseAsync(applicantUuid, createdEnd, createdStart, dateEnd, dateStart, membership, offset, page, pageNumber, pageSize, paged, querySteno, reference, reporterUuid, sittingDateTimeEnd, sittingDateTimeStart, size, sort, sortsorted, sortunsorted, subTypeCode, title, unpaged).map(new Func1<ServiceResponse<PagedResourcesDokumentMuuKSimus>, PagedResourcesDokumentMuuKSimus>() {
            @Override
            public PagedResourcesDokumentMuuKSimus call(ServiceResponse<PagedResourcesDokumentMuuKSimus> response) {
                return response.body();
            }
        });
    }

    /**
     * Muud küsimused.
     *
     * @param applicantUuid Esitaja UUID
     * @param createdEnd Loomise lõppkuupäev (yyyy-MM-dd)
     * @param createdStart Loomise alguskuupäev (yyyy-MM-dd)
     * @param dateEnd Dokumendi kuupäeva lõpp (yyyy-MM-dd)
     * @param dateStart Dokumendi kuupäeva algus (yyyy-MM-dd)
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param reference Viit
     * @param reporterUuid Ettekandja UUID
     * @param sittingDateTimeEnd Seotud täiskogu istungi kuupäeva lõpp (yyyy-MM-dd)
     * @param sittingDateTimeStart Seotud täiskogu istungi kuupäeva algus (yyyy-MM-dd)
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subTypeCode Alamtüübi kood. Lubatud mitu väärtust.
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesDokumentMuuKSimus object
     */
    public Observable<ServiceResponse<PagedResourcesDokumentMuuKSimus>> findOtherQuestionsUsingGETWithServiceResponseAsync(String applicantUuid, LocalDate createdEnd, LocalDate createdStart, LocalDate dateEnd, LocalDate dateStart, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Boolean querySteno, String reference, String reporterUuid, LocalDate sittingDateTimeEnd, LocalDate sittingDateTimeStart, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, List<String> subTypeCode, String title, Boolean unpaged) {
        Validator.validate(sort);
        Validator.validate(subTypeCode);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);String subTypeCodeConverted = this.serializerAdapter().serializeList(subTypeCode, CollectionFormat.MULTI);
        return service.findOtherQuestionsUsingGET(applicantUuid, createdEnd, createdStart, dateEnd, dateStart, membership, offset, page, pageNumber, pageSize, paged, querySteno, reference, reporterUuid, sittingDateTimeEnd, sittingDateTimeStart, size, sortConverted, sortsorted, sortunsorted, subTypeCodeConverted, title, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesDokumentMuuKSimus>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesDokumentMuuKSimus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesDokumentMuuKSimus> clientResponse = findOtherQuestionsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesDokumentMuuKSimus> findOtherQuestionsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesDokumentMuuKSimus, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesDokumentMuuKSimus>() { }.getType())
                .build(response);
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Dokument object if successful.
     */
    public Dokument getDocumentUsingGET(String uuid) {
        return getDocumentUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Dokument> getDocumentUsingGETAsync(String uuid, final ServiceCallback<Dokument> serviceCallback) {
        return ServiceFuture.fromResponse(getDocumentUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Dokument object
     */
    public Observable<Dokument> getDocumentUsingGETAsync(String uuid) {
        return getDocumentUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<Dokument>, Dokument>() {
            @Override
            public Dokument call(ServiceResponse<Dokument> response) {
                return response.body();
            }
        });
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Dokument object
     */
    public Observable<ServiceResponse<Dokument>> getDocumentUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getDocumentUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Dokument>>>() {
                @Override
                public Observable<ServiceResponse<Dokument>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Dokument> clientResponse = getDocumentUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Dokument object if successful.
     */
    public Dokument getDocumentUsingGET(String uuid, String lang) {
        return getDocumentUsingGETWithServiceResponseAsync(uuid, lang).toBlocking().single().body();
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Dokument> getDocumentUsingGETAsync(String uuid, String lang, final ServiceCallback<Dokument> serviceCallback) {
        return ServiceFuture.fromResponse(getDocumentUsingGETWithServiceResponseAsync(uuid, lang), serviceCallback);
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Dokument object
     */
    public Observable<Dokument> getDocumentUsingGETAsync(String uuid, String lang) {
        return getDocumentUsingGETWithServiceResponseAsync(uuid, lang).map(new Func1<ServiceResponse<Dokument>, Dokument>() {
            @Override
            public Dokument call(ServiceResponse<Dokument> response) {
                return response.body();
            }
        });
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Dokument object
     */
    public Observable<ServiceResponse<Dokument>> getDocumentUsingGETWithServiceResponseAsync(String uuid, String lang) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getDocumentUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Dokument>>>() {
                @Override
                public Observable<ServiceResponse<Dokument>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Dokument> clientResponse = getDocumentUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Dokument> getDocumentUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Dokument, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Dokument>() { }.getType())
                .build(response);
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PEvasNdmused&gt; object if successful.
     */
    public List<PEvasNdmused> getEventsUsingGET() {
        return getEventsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PEvasNdmused>> getEventsUsingGETAsync(final ServiceCallback<List<PEvasNdmused>> serviceCallback) {
        return ServiceFuture.fromResponse(getEventsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PEvasNdmused&gt; object
     */
    public Observable<List<PEvasNdmused>> getEventsUsingGETAsync() {
        return getEventsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<PEvasNdmused>>, List<PEvasNdmused>>() {
            @Override
            public List<PEvasNdmused> call(ServiceResponse<List<PEvasNdmused>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PEvasNdmused&gt; object
     */
    public Observable<ServiceResponse<List<PEvasNdmused>>> getEventsUsingGETWithServiceResponseAsync() {
        final LocalDate dateParameter = null;
        final LocalDate endDate = null;
        final String lang = null;
        final Boolean querySteno = null;
        final LocalDate startDate = null;
        final String type = null;
        return service.getEventsUsingGET(dateParameter, endDate, lang, querySteno, startDate, type)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PEvasNdmused>>>>() {
                @Override
                public Observable<ServiceResponse<List<PEvasNdmused>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PEvasNdmused>> clientResponse = getEventsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille sündmusi soovitakse
     * @param endDate Kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param startDate Kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PEvasNdmused&gt; object if successful.
     */
    public List<PEvasNdmused> getEventsUsingGET(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate, String type) {
        return getEventsUsingGETWithServiceResponseAsync(dateParameter, endDate, lang, querySteno, startDate, type).toBlocking().single().body();
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille sündmusi soovitakse
     * @param endDate Kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param startDate Kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PEvasNdmused>> getEventsUsingGETAsync(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate, String type, final ServiceCallback<List<PEvasNdmused>> serviceCallback) {
        return ServiceFuture.fromResponse(getEventsUsingGETWithServiceResponseAsync(dateParameter, endDate, lang, querySteno, startDate, type), serviceCallback);
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille sündmusi soovitakse
     * @param endDate Kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param startDate Kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PEvasNdmused&gt; object
     */
    public Observable<List<PEvasNdmused>> getEventsUsingGETAsync(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate, String type) {
        return getEventsUsingGETWithServiceResponseAsync(dateParameter, endDate, lang, querySteno, startDate, type).map(new Func1<ServiceResponse<List<PEvasNdmused>>, List<PEvasNdmused>>() {
            @Override
            public List<PEvasNdmused> call(ServiceResponse<List<PEvasNdmused>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille sündmusi soovitakse
     * @param endDate Kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param startDate Kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PEvasNdmused&gt; object
     */
    public Observable<ServiceResponse<List<PEvasNdmused>>> getEventsUsingGETWithServiceResponseAsync(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate, String type) {
        return service.getEventsUsingGET(dateParameter, endDate, lang, querySteno, startDate, type)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PEvasNdmused>>>>() {
                @Override
                public Observable<ServiceResponse<List<PEvasNdmused>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PEvasNdmused>> clientResponse = getEventsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PEvasNdmused>> getEventsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<PEvasNdmused>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<PEvasNdmused>>() { }.getType())
                .build(response);
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PEvSNdmused&gt; object if successful.
     */
    public List<PEvSNdmused> getEventCalendarUsingGET(LocalDate endDate, LocalDate startDate) {
        return getEventCalendarUsingGETWithServiceResponseAsync(endDate, startDate).toBlocking().single().body();
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PEvSNdmused>> getEventCalendarUsingGETAsync(LocalDate endDate, LocalDate startDate, final ServiceCallback<List<PEvSNdmused>> serviceCallback) {
        return ServiceFuture.fromResponse(getEventCalendarUsingGETWithServiceResponseAsync(endDate, startDate), serviceCallback);
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PEvSNdmused&gt; object
     */
    public Observable<List<PEvSNdmused>> getEventCalendarUsingGETAsync(LocalDate endDate, LocalDate startDate) {
        return getEventCalendarUsingGETWithServiceResponseAsync(endDate, startDate).map(new Func1<ServiceResponse<List<PEvSNdmused>>, List<PEvSNdmused>>() {
            @Override
            public List<PEvSNdmused> call(ServiceResponse<List<PEvSNdmused>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PEvSNdmused&gt; object
     */
    public Observable<ServiceResponse<List<PEvSNdmused>>> getEventCalendarUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        final String committeeGroupUuid = null;
        final String type = null;
        return service.getEventCalendarUsingGET(committeeGroupUuid, endDate, startDate, type)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PEvSNdmused>>>>() {
                @Override
                public Observable<ServiceResponse<List<PEvSNdmused>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PEvSNdmused>> clientResponse = getEventCalendarUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param committeeGroupUuid Komisjoni UUID, mille päevakorra sündmusi soovitakse. Asjakohane kui "type=committee"
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PEvSNdmused&gt; object if successful.
     */
    public List<PEvSNdmused> getEventCalendarUsingGET(LocalDate endDate, LocalDate startDate, String committeeGroupUuid, String type) {
        return getEventCalendarUsingGETWithServiceResponseAsync(endDate, startDate, committeeGroupUuid, type).toBlocking().single().body();
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param committeeGroupUuid Komisjoni UUID, mille päevakorra sündmusi soovitakse. Asjakohane kui "type=committee"
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PEvSNdmused>> getEventCalendarUsingGETAsync(LocalDate endDate, LocalDate startDate, String committeeGroupUuid, String type, final ServiceCallback<List<PEvSNdmused>> serviceCallback) {
        return ServiceFuture.fromResponse(getEventCalendarUsingGETWithServiceResponseAsync(endDate, startDate, committeeGroupUuid, type), serviceCallback);
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param committeeGroupUuid Komisjoni UUID, mille päevakorra sündmusi soovitakse. Asjakohane kui "type=committee"
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PEvSNdmused&gt; object
     */
    public Observable<List<PEvSNdmused>> getEventCalendarUsingGETAsync(LocalDate endDate, LocalDate startDate, String committeeGroupUuid, String type) {
        return getEventCalendarUsingGETWithServiceResponseAsync(endDate, startDate, committeeGroupUuid, type).map(new Func1<ServiceResponse<List<PEvSNdmused>>, List<PEvSNdmused>>() {
            @Override
            public List<PEvSNdmused> call(ServiceResponse<List<PEvSNdmused>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param committeeGroupUuid Komisjoni UUID, mille päevakorra sündmusi soovitakse. Asjakohane kui "type=committee"
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PEvSNdmused&gt; object
     */
    public Observable<ServiceResponse<List<PEvSNdmused>>> getEventCalendarUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String committeeGroupUuid, String type) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        return service.getEventCalendarUsingGET(committeeGroupUuid, endDate, startDate, type)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PEvSNdmused>>>>() {
                @Override
                public Observable<ServiceResponse<List<PEvSNdmused>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PEvSNdmused>> clientResponse = getEventCalendarUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PEvSNdmused>> getEventCalendarUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<PEvSNdmused>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<PEvSNdmused>>() { }.getType())
                .build(response);
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Fail object if successful.
     */
    public Fail getFileMetadataUsingGET(String uuid) {
        return getFileMetadataUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Fail> getFileMetadataUsingGETAsync(String uuid, final ServiceCallback<Fail> serviceCallback) {
        return ServiceFuture.fromResponse(getFileMetadataUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Fail object
     */
    public Observable<Fail> getFileMetadataUsingGETAsync(String uuid) {
        return getFileMetadataUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<Fail>, Fail>() {
            @Override
            public Fail call(ServiceResponse<Fail> response) {
                return response.body();
            }
        });
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Fail object
     */
    public Observable<ServiceResponse<Fail>> getFileMetadataUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getFileMetadataUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Fail>>>() {
                @Override
                public Observable<ServiceResponse<Fail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Fail> clientResponse = getFileMetadataUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Fail object if successful.
     */
    public Fail getFileMetadataUsingGET(String uuid, String lang) {
        return getFileMetadataUsingGETWithServiceResponseAsync(uuid, lang).toBlocking().single().body();
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Fail> getFileMetadataUsingGETAsync(String uuid, String lang, final ServiceCallback<Fail> serviceCallback) {
        return ServiceFuture.fromResponse(getFileMetadataUsingGETWithServiceResponseAsync(uuid, lang), serviceCallback);
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Fail object
     */
    public Observable<Fail> getFileMetadataUsingGETAsync(String uuid, String lang) {
        return getFileMetadataUsingGETWithServiceResponseAsync(uuid, lang).map(new Func1<ServiceResponse<Fail>, Fail>() {
            @Override
            public Fail call(ServiceResponse<Fail> response) {
                return response.body();
            }
        });
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Fail object
     */
    public Observable<ServiceResponse<Fail>> getFileMetadataUsingGETWithServiceResponseAsync(String uuid, String lang) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getFileMetadataUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Fail>>>() {
                @Override
                public Observable<ServiceResponse<Fail>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Fail> clientResponse = getFileMetadataUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Fail> getFileMetadataUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Fail, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Fail>() { }.getType())
                .build(response);
    }

    /**
     * Faili allalaadimine.
     *
     * @param uuid Faili UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the byte[] object if successful.
     */
    public byte[] downloadFileUsingGET(String uuid) {
        return downloadFileUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Faili allalaadimine.
     *
     * @param uuid Faili UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<byte[]> downloadFileUsingGETAsync(String uuid, final ServiceCallback<byte[]> serviceCallback) {
        return ServiceFuture.fromResponse(downloadFileUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Faili allalaadimine.
     *
     * @param uuid Faili UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the byte[] object
     */
    public Observable<byte[]> downloadFileUsingGETAsync(String uuid) {
        return downloadFileUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<byte[]>, byte[]>() {
            @Override
            public byte[] call(ServiceResponse<byte[]> response) {
                return response.body();
            }
        });
    }

    /**
     * Faili allalaadimine.
     *
     * @param uuid Faili UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the byte[] object
     */
    public Observable<ServiceResponse<byte[]>> downloadFileUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.downloadFileUsingGET(uuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<byte[]>>>() {
                @Override
                public Observable<ServiceResponse<byte[]>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<byte[]> clientResponse = downloadFileUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<byte[]> downloadFileUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<byte[], RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<byte[]>() { }.getType())
                .build(response);
    }

    /**
     * Saaliplaan.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;SaaliplaaniKoht&gt; object if successful.
     */
    public List<SaaliplaaniKoht> getLatestHallplanUsingGET() {
        return getLatestHallplanUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Saaliplaan.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SaaliplaaniKoht>> getLatestHallplanUsingGETAsync(final ServiceCallback<List<SaaliplaaniKoht>> serviceCallback) {
        return ServiceFuture.fromResponse(getLatestHallplanUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Saaliplaan.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SaaliplaaniKoht&gt; object
     */
    public Observable<List<SaaliplaaniKoht>> getLatestHallplanUsingGETAsync() {
        return getLatestHallplanUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<SaaliplaaniKoht>>, List<SaaliplaaniKoht>>() {
            @Override
            public List<SaaliplaaniKoht> call(ServiceResponse<List<SaaliplaaniKoht>> response) {
                return response.body();
            }
        });
    }

    /**
     * Saaliplaan.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SaaliplaaniKoht&gt; object
     */
    public Observable<ServiceResponse<List<SaaliplaaniKoht>>> getLatestHallplanUsingGETWithServiceResponseAsync() {
        final String lang = null;
        return service.getLatestHallplanUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<SaaliplaaniKoht>>>>() {
                @Override
                public Observable<ServiceResponse<List<SaaliplaaniKoht>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<SaaliplaaniKoht>> clientResponse = getLatestHallplanUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Saaliplaan.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;SaaliplaaniKoht&gt; object if successful.
     */
    public List<SaaliplaaniKoht> getLatestHallplanUsingGET(String lang) {
        return getLatestHallplanUsingGETWithServiceResponseAsync(lang).toBlocking().single().body();
    }

    /**
     * Saaliplaan.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SaaliplaaniKoht>> getLatestHallplanUsingGETAsync(String lang, final ServiceCallback<List<SaaliplaaniKoht>> serviceCallback) {
        return ServiceFuture.fromResponse(getLatestHallplanUsingGETWithServiceResponseAsync(lang), serviceCallback);
    }

    /**
     * Saaliplaan.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SaaliplaaniKoht&gt; object
     */
    public Observable<List<SaaliplaaniKoht>> getLatestHallplanUsingGETAsync(String lang) {
        return getLatestHallplanUsingGETWithServiceResponseAsync(lang).map(new Func1<ServiceResponse<List<SaaliplaaniKoht>>, List<SaaliplaaniKoht>>() {
            @Override
            public List<SaaliplaaniKoht> call(ServiceResponse<List<SaaliplaaniKoht>> response) {
                return response.body();
            }
        });
    }

    /**
     * Saaliplaan.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SaaliplaaniKoht&gt; object
     */
    public Observable<ServiceResponse<List<SaaliplaaniKoht>>> getLatestHallplanUsingGETWithServiceResponseAsync(String lang) {
        return service.getLatestHallplanUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<SaaliplaaniKoht>>>>() {
                @Override
                public Observable<ServiceResponse<List<SaaliplaaniKoht>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<SaaliplaaniKoht>> clientResponse = getLatestHallplanUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<SaaliplaaniKoht>> getLatestHallplanUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<SaaliplaaniKoht>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<SaaliplaaniKoht>>() { }.getType())
                .build(response);
    }

    /**
     * Dokumendipuu (hierarhia).
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FunktsiooniGrupp&gt; object if successful.
     */
    public List<FunktsiooniGrupp> getDocumentTreeUsingGET() {
        return getDocumentTreeUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Dokumendipuu (hierarhia).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FunktsiooniGrupp>> getDocumentTreeUsingGETAsync(final ServiceCallback<List<FunktsiooniGrupp>> serviceCallback) {
        return ServiceFuture.fromResponse(getDocumentTreeUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Dokumendipuu (hierarhia).
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FunktsiooniGrupp&gt; object
     */
    public Observable<List<FunktsiooniGrupp>> getDocumentTreeUsingGETAsync() {
        return getDocumentTreeUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<FunktsiooniGrupp>>, List<FunktsiooniGrupp>>() {
            @Override
            public List<FunktsiooniGrupp> call(ServiceResponse<List<FunktsiooniGrupp>> response) {
                return response.body();
            }
        });
    }

    /**
     * Dokumendipuu (hierarhia).
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FunktsiooniGrupp&gt; object
     */
    public Observable<ServiceResponse<List<FunktsiooniGrupp>>> getDocumentTreeUsingGETWithServiceResponseAsync() {
        return service.getDocumentTreeUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FunktsiooniGrupp>>>>() {
                @Override
                public Observable<ServiceResponse<List<FunktsiooniGrupp>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FunktsiooniGrupp>> clientResponse = getDocumentTreeUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<FunktsiooniGrupp>> getDocumentTreeUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<FunktsiooniGrupp>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<FunktsiooniGrupp>>() { }.getType())
                .build(response);
    }

    /**
     * Dokumendi liigid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DokumenditP&gt; object if successful.
     */
    public List<DokumenditP> getDocumentTypesUsingGET() {
        return getDocumentTypesUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Dokumendi liigid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DokumenditP>> getDocumentTypesUsingGETAsync(final ServiceCallback<List<DokumenditP>> serviceCallback) {
        return ServiceFuture.fromResponse(getDocumentTypesUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Dokumendi liigid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DokumenditP&gt; object
     */
    public Observable<List<DokumenditP>> getDocumentTypesUsingGETAsync() {
        return getDocumentTypesUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<DokumenditP>>, List<DokumenditP>>() {
            @Override
            public List<DokumenditP> call(ServiceResponse<List<DokumenditP>> response) {
                return response.body();
            }
        });
    }

    /**
     * Dokumendi liigid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DokumenditP&gt; object
     */
    public Observable<ServiceResponse<List<DokumenditP>>> getDocumentTypesUsingGETWithServiceResponseAsync() {
        return service.getDocumentTypesUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DokumenditP>>>>() {
                @Override
                public Observable<ServiceResponse<List<DokumenditP>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DokumenditP>> clientResponse = getDocumentTypesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DokumenditP>> getDocumentTypesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<DokumenditP>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DokumenditP>>() { }.getType())
                .build(response);
    }

    /**
     * Eelnõu algatajad.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EelnUAlgataja&gt; object if successful.
     */
    public List<EelnUAlgataja> getDraftInitiatorsUsingGET() {
        return getDraftInitiatorsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Eelnõu algatajad.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EelnUAlgataja>> getDraftInitiatorsUsingGETAsync(final ServiceCallback<List<EelnUAlgataja>> serviceCallback) {
        return ServiceFuture.fromResponse(getDraftInitiatorsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Eelnõu algatajad.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EelnUAlgataja&gt; object
     */
    public Observable<List<EelnUAlgataja>> getDraftInitiatorsUsingGETAsync() {
        return getDraftInitiatorsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<EelnUAlgataja>>, List<EelnUAlgataja>>() {
            @Override
            public List<EelnUAlgataja> call(ServiceResponse<List<EelnUAlgataja>> response) {
                return response.body();
            }
        });
    }

    /**
     * Eelnõu algatajad.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EelnUAlgataja&gt; object
     */
    public Observable<ServiceResponse<List<EelnUAlgataja>>> getDraftInitiatorsUsingGETWithServiceResponseAsync() {
        return service.getDraftInitiatorsUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EelnUAlgataja>>>>() {
                @Override
                public Observable<ServiceResponse<List<EelnUAlgataja>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EelnUAlgataja>> clientResponse = getDraftInitiatorsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EelnUAlgataja>> getDraftInitiatorsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<EelnUAlgataja>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<EelnUAlgataja>>() { }.getType())
                .build(response);
    }

    /**
     * Toimiku liigid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ToimikuTP&gt; object if successful.
     */
    public List<ToimikuTP> getVolumeTypesUsingGET() {
        return getVolumeTypesUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Toimiku liigid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ToimikuTP>> getVolumeTypesUsingGETAsync(final ServiceCallback<List<ToimikuTP>> serviceCallback) {
        return ServiceFuture.fromResponse(getVolumeTypesUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Toimiku liigid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ToimikuTP&gt; object
     */
    public Observable<List<ToimikuTP>> getVolumeTypesUsingGETAsync() {
        return getVolumeTypesUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<ToimikuTP>>, List<ToimikuTP>>() {
            @Override
            public List<ToimikuTP> call(ServiceResponse<List<ToimikuTP>> response) {
                return response.body();
            }
        });
    }

    /**
     * Toimiku liigid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ToimikuTP&gt; object
     */
    public Observable<ServiceResponse<List<ToimikuTP>>> getVolumeTypesUsingGETWithServiceResponseAsync() {
        return service.getVolumeTypesUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ToimikuTP>>>>() {
                @Override
                public Observable<ServiceResponse<List<ToimikuTP>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ToimikuTP>> clientResponse = getVolumeTypesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ToimikuTP>> getVolumeTypesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<ToimikuTP>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ToimikuTP>>() { }.getType())
                .build(response);
    }

    /**
     * Kõik koosseisud.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Koosseis&gt; object if successful.
     */
    public List<Koosseis> getMembershipsUsingGET() {
        return getMembershipsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Kõik koosseisud.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Koosseis>> getMembershipsUsingGETAsync(final ServiceCallback<List<Koosseis>> serviceCallback) {
        return ServiceFuture.fromResponse(getMembershipsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Kõik koosseisud.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Koosseis&gt; object
     */
    public Observable<List<Koosseis>> getMembershipsUsingGETAsync() {
        return getMembershipsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Koosseis>>, List<Koosseis>>() {
            @Override
            public List<Koosseis> call(ServiceResponse<List<Koosseis>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kõik koosseisud.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Koosseis&gt; object
     */
    public Observable<ServiceResponse<List<Koosseis>>> getMembershipsUsingGETWithServiceResponseAsync() {
        return service.getMembershipsUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Koosseis>>>>() {
                @Override
                public Observable<ServiceResponse<List<Koosseis>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Koosseis>> clientResponse = getMembershipsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Koosseis>> getMembershipsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Koosseis>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Koosseis>>() { }.getType())
                .build(response);
    }

    /**
     * Praegune koosseis.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Koosseis object if successful.
     */
    public Koosseis getCurrentMembershipUsingGET() {
        return getCurrentMembershipUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Praegune koosseis.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Koosseis> getCurrentMembershipUsingGETAsync(final ServiceCallback<Koosseis> serviceCallback) {
        return ServiceFuture.fromResponse(getCurrentMembershipUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Praegune koosseis.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Koosseis object
     */
    public Observable<Koosseis> getCurrentMembershipUsingGETAsync() {
        return getCurrentMembershipUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<Koosseis>, Koosseis>() {
            @Override
            public Koosseis call(ServiceResponse<Koosseis> response) {
                return response.body();
            }
        });
    }

    /**
     * Praegune koosseis.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Koosseis object
     */
    public Observable<ServiceResponse<Koosseis>> getCurrentMembershipUsingGETWithServiceResponseAsync() {
        return service.getCurrentMembershipUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Koosseis>>>() {
                @Override
                public Observable<ServiceResponse<Koosseis>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Koosseis> clientResponse = getCurrentMembershipUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Koosseis> getCurrentMembershipUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Koosseis, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Koosseis>() { }.getType())
                .build(response);
    }

    /**
     * Koosseis.
     *
     * @param number Koosseisu number
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Koosseis object if successful.
     */
    public Koosseis getMembershipUsingGET(int number) {
        return getMembershipUsingGETWithServiceResponseAsync(number).toBlocking().single().body();
    }

    /**
     * Koosseis.
     *
     * @param number Koosseisu number
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Koosseis> getMembershipUsingGETAsync(int number, final ServiceCallback<Koosseis> serviceCallback) {
        return ServiceFuture.fromResponse(getMembershipUsingGETWithServiceResponseAsync(number), serviceCallback);
    }

    /**
     * Koosseis.
     *
     * @param number Koosseisu number
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Koosseis object
     */
    public Observable<Koosseis> getMembershipUsingGETAsync(int number) {
        return getMembershipUsingGETWithServiceResponseAsync(number).map(new Func1<ServiceResponse<Koosseis>, Koosseis>() {
            @Override
            public Koosseis call(ServiceResponse<Koosseis> response) {
                return response.body();
            }
        });
    }

    /**
     * Koosseis.
     *
     * @param number Koosseisu number
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Koosseis object
     */
    public Observable<ServiceResponse<Koosseis>> getMembershipUsingGETWithServiceResponseAsync(int number) {
        return service.getMembershipUsingGET(number)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Koosseis>>>() {
                @Override
                public Observable<ServiceResponse<Koosseis>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Koosseis> clientResponse = getMembershipUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Koosseis> getMembershipUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Koosseis, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Koosseis>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiige&gt; object if successful.
     */
    public List<RiigikoguLiige> getPlenaryMembersUsingGET() {
        return getPlenaryMembersUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiige>> getPlenaryMembersUsingGETAsync(final ServiceCallback<List<RiigikoguLiige>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryMembersUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiige&gt; object
     */
    public Observable<List<RiigikoguLiige>> getPlenaryMembersUsingGETAsync() {
        return getPlenaryMembersUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<RiigikoguLiige>>, List<RiigikoguLiige>>() {
            @Override
            public List<RiigikoguLiige> call(ServiceResponse<List<RiigikoguLiige>> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiige&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiige>>> getPlenaryMembersUsingGETWithServiceResponseAsync() {
        final List<String> committeeUuid = null;
        final List<String> electoralDistrictCodes = null;
        final List<String> factionUuid = null;
        final Boolean includeInactive = null;
        final String lang = null;
        final Integer membership = null;
        final String name = null;
        String committeeUuidConverted = this.serializerAdapter().serializeList(committeeUuid, CollectionFormat.MULTI);String electoralDistrictCodesConverted = this.serializerAdapter().serializeList(electoralDistrictCodes, CollectionFormat.MULTI);String factionUuidConverted = this.serializerAdapter().serializeList(factionUuid, CollectionFormat.MULTI);
        return service.getPlenaryMembersUsingGET(committeeUuidConverted, electoralDistrictCodesConverted, factionUuidConverted, includeInactive, lang, membership, name)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiige>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiige>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiige>> clientResponse = getPlenaryMembersUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @param committeeUuid Komisjoni UUID. Lubatud mitu väärtust
     * @param electoralDistrictCodes Valimisringkonna kood (klassifikaator 'valimisringkond'). Lubatud mitu väärtust
     * @param factionUuid Fraktsiooni UUID. Lubatud mitu väärtust
     * @param includeInactive Kaasa mitteaktiivsed liikmed
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseis
     * @param name Liikme nimi. Otsitakse otsisõna sisaldumist nii ees- kui perekonnanimes
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiige&gt; object if successful.
     */
    public List<RiigikoguLiige> getPlenaryMembersUsingGET(List<String> committeeUuid, List<String> electoralDistrictCodes, List<String> factionUuid, Boolean includeInactive, String lang, Integer membership, String name) {
        return getPlenaryMembersUsingGETWithServiceResponseAsync(committeeUuid, electoralDistrictCodes, factionUuid, includeInactive, lang, membership, name).toBlocking().single().body();
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @param committeeUuid Komisjoni UUID. Lubatud mitu väärtust
     * @param electoralDistrictCodes Valimisringkonna kood (klassifikaator 'valimisringkond'). Lubatud mitu väärtust
     * @param factionUuid Fraktsiooni UUID. Lubatud mitu väärtust
     * @param includeInactive Kaasa mitteaktiivsed liikmed
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseis
     * @param name Liikme nimi. Otsitakse otsisõna sisaldumist nii ees- kui perekonnanimes
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiige>> getPlenaryMembersUsingGETAsync(List<String> committeeUuid, List<String> electoralDistrictCodes, List<String> factionUuid, Boolean includeInactive, String lang, Integer membership, String name, final ServiceCallback<List<RiigikoguLiige>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryMembersUsingGETWithServiceResponseAsync(committeeUuid, electoralDistrictCodes, factionUuid, includeInactive, lang, membership, name), serviceCallback);
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @param committeeUuid Komisjoni UUID. Lubatud mitu väärtust
     * @param electoralDistrictCodes Valimisringkonna kood (klassifikaator 'valimisringkond'). Lubatud mitu väärtust
     * @param factionUuid Fraktsiooni UUID. Lubatud mitu väärtust
     * @param includeInactive Kaasa mitteaktiivsed liikmed
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseis
     * @param name Liikme nimi. Otsitakse otsisõna sisaldumist nii ees- kui perekonnanimes
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiige&gt; object
     */
    public Observable<List<RiigikoguLiige>> getPlenaryMembersUsingGETAsync(List<String> committeeUuid, List<String> electoralDistrictCodes, List<String> factionUuid, Boolean includeInactive, String lang, Integer membership, String name) {
        return getPlenaryMembersUsingGETWithServiceResponseAsync(committeeUuid, electoralDistrictCodes, factionUuid, includeInactive, lang, membership, name).map(new Func1<ServiceResponse<List<RiigikoguLiige>>, List<RiigikoguLiige>>() {
            @Override
            public List<RiigikoguLiige> call(ServiceResponse<List<RiigikoguLiige>> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @param committeeUuid Komisjoni UUID. Lubatud mitu väärtust
     * @param electoralDistrictCodes Valimisringkonna kood (klassifikaator 'valimisringkond'). Lubatud mitu väärtust
     * @param factionUuid Fraktsiooni UUID. Lubatud mitu väärtust
     * @param includeInactive Kaasa mitteaktiivsed liikmed
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseis
     * @param name Liikme nimi. Otsitakse otsisõna sisaldumist nii ees- kui perekonnanimes
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiige&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiige>>> getPlenaryMembersUsingGETWithServiceResponseAsync(List<String> committeeUuid, List<String> electoralDistrictCodes, List<String> factionUuid, Boolean includeInactive, String lang, Integer membership, String name) {
        Validator.validate(committeeUuid);
        Validator.validate(electoralDistrictCodes);
        Validator.validate(factionUuid);
        String committeeUuidConverted = this.serializerAdapter().serializeList(committeeUuid, CollectionFormat.MULTI);String electoralDistrictCodesConverted = this.serializerAdapter().serializeList(electoralDistrictCodes, CollectionFormat.MULTI);String factionUuidConverted = this.serializerAdapter().serializeList(factionUuid, CollectionFormat.MULTI);
        return service.getPlenaryMembersUsingGET(committeeUuidConverted, electoralDistrictCodesConverted, factionUuidConverted, includeInactive, lang, membership, name)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiige>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiige>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiige>> clientResponse = getPlenaryMembersUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<RiigikoguLiige>> getPlenaryMembersUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<RiigikoguLiige>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RiigikoguLiige>>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RiigikoguLiikmeDetailid object if successful.
     */
    public RiigikoguLiikmeDetailid getPlenaryMemberDetailsUsingGET(String uuid) {
        return getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RiigikoguLiikmeDetailid> getPlenaryMemberDetailsUsingGETAsync(String uuid, final ServiceCallback<RiigikoguLiikmeDetailid> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiikmeDetailid object
     */
    public Observable<RiigikoguLiikmeDetailid> getPlenaryMemberDetailsUsingGETAsync(String uuid) {
        return getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<RiigikoguLiikmeDetailid>, RiigikoguLiikmeDetailid>() {
            @Override
            public RiigikoguLiikmeDetailid call(ServiceResponse<RiigikoguLiikmeDetailid> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiikmeDetailid object
     */
    public Observable<ServiceResponse<RiigikoguLiikmeDetailid>> getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        final Boolean querySteno = null;
        return service.getPlenaryMemberDetailsUsingGET(uuid, lang, querySteno)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RiigikoguLiikmeDetailid>>>() {
                @Override
                public Observable<ServiceResponse<RiigikoguLiikmeDetailid>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RiigikoguLiikmeDetailid> clientResponse = getPlenaryMemberDetailsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest liikme viimane kõne? (true/false)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RiigikoguLiikmeDetailid object if successful.
     */
    public RiigikoguLiikmeDetailid getPlenaryMemberDetailsUsingGET(String uuid, String lang, Boolean querySteno) {
        return getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(uuid, lang, querySteno).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest liikme viimane kõne? (true/false)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RiigikoguLiikmeDetailid> getPlenaryMemberDetailsUsingGETAsync(String uuid, String lang, Boolean querySteno, final ServiceCallback<RiigikoguLiikmeDetailid> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(uuid, lang, querySteno), serviceCallback);
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest liikme viimane kõne? (true/false)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiikmeDetailid object
     */
    public Observable<RiigikoguLiikmeDetailid> getPlenaryMemberDetailsUsingGETAsync(String uuid, String lang, Boolean querySteno) {
        return getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(uuid, lang, querySteno).map(new Func1<ServiceResponse<RiigikoguLiikmeDetailid>, RiigikoguLiikmeDetailid>() {
            @Override
            public RiigikoguLiikmeDetailid call(ServiceResponse<RiigikoguLiikmeDetailid> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest liikme viimane kõne? (true/false)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiikmeDetailid object
     */
    public Observable<ServiceResponse<RiigikoguLiikmeDetailid>> getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(String uuid, String lang, Boolean querySteno) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getPlenaryMemberDetailsUsingGET(uuid, lang, querySteno)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RiigikoguLiikmeDetailid>>>() {
                @Override
                public Observable<ServiceResponse<RiigikoguLiikmeDetailid>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RiigikoguLiikmeDetailid> clientResponse = getPlenaryMemberDetailsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RiigikoguLiikmeDetailid> getPlenaryMemberDetailsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RiigikoguLiikmeDetailid, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RiigikoguLiikmeDetailid>() { }.getType())
                .build(response);
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;IstungjRk&gt; object if successful.
     */
    public List<IstungjRk> getSessionsUsingGET() {
        return getSessionsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IstungjRk>> getSessionsUsingGETAsync(final ServiceCallback<List<IstungjRk>> serviceCallback) {
        return ServiceFuture.fromResponse(getSessionsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IstungjRk&gt; object
     */
    public Observable<List<IstungjRk>> getSessionsUsingGETAsync() {
        return getSessionsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<IstungjRk>>, List<IstungjRk>>() {
            @Override
            public List<IstungjRk> call(ServiceResponse<List<IstungjRk>> response) {
                return response.body();
            }
        });
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IstungjRk&gt; object
     */
    public Observable<ServiceResponse<List<IstungjRk>>> getSessionsUsingGETWithServiceResponseAsync() {
        final String lang = null;
        return service.getSessionsUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<IstungjRk>>>>() {
                @Override
                public Observable<ServiceResponse<List<IstungjRk>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<IstungjRk>> clientResponse = getSessionsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;IstungjRk&gt; object if successful.
     */
    public List<IstungjRk> getSessionsUsingGET(String lang) {
        return getSessionsUsingGETWithServiceResponseAsync(lang).toBlocking().single().body();
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<IstungjRk>> getSessionsUsingGETAsync(String lang, final ServiceCallback<List<IstungjRk>> serviceCallback) {
        return ServiceFuture.fromResponse(getSessionsUsingGETWithServiceResponseAsync(lang), serviceCallback);
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IstungjRk&gt; object
     */
    public Observable<List<IstungjRk>> getSessionsUsingGETAsync(String lang) {
        return getSessionsUsingGETWithServiceResponseAsync(lang).map(new Func1<ServiceResponse<List<IstungjRk>>, List<IstungjRk>>() {
            @Override
            public List<IstungjRk> call(ServiceResponse<List<IstungjRk>> response) {
                return response.body();
            }
        });
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;IstungjRk&gt; object
     */
    public Observable<ServiceResponse<List<IstungjRk>>> getSessionsUsingGETWithServiceResponseAsync(String lang) {
        return service.getSessionsUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<IstungjRk>>>>() {
                @Override
                public Observable<ServiceResponse<List<IstungjRk>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<IstungjRk>> clientResponse = getSessionsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<IstungjRk>> getSessionsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<IstungjRk>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<IstungjRk>>() { }.getType())
                .build(response);
    }

    /**
     * Praegune istungjärk.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IstungjRk object if successful.
     */
    public IstungjRk getCurrentSessionUsingGET() {
        return getCurrentSessionUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Praegune istungjärk.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IstungjRk> getCurrentSessionUsingGETAsync(final ServiceCallback<IstungjRk> serviceCallback) {
        return ServiceFuture.fromResponse(getCurrentSessionUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Praegune istungjärk.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IstungjRk object
     */
    public Observable<IstungjRk> getCurrentSessionUsingGETAsync() {
        return getCurrentSessionUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<IstungjRk>, IstungjRk>() {
            @Override
            public IstungjRk call(ServiceResponse<IstungjRk> response) {
                return response.body();
            }
        });
    }

    /**
     * Praegune istungjärk.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IstungjRk object
     */
    public Observable<ServiceResponse<IstungjRk>> getCurrentSessionUsingGETWithServiceResponseAsync() {
        final String lang = null;
        return service.getCurrentSessionUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IstungjRk>>>() {
                @Override
                public Observable<ServiceResponse<IstungjRk>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IstungjRk> clientResponse = getCurrentSessionUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Praegune istungjärk.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the IstungjRk object if successful.
     */
    public IstungjRk getCurrentSessionUsingGET(String lang) {
        return getCurrentSessionUsingGETWithServiceResponseAsync(lang).toBlocking().single().body();
    }

    /**
     * Praegune istungjärk.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<IstungjRk> getCurrentSessionUsingGETAsync(String lang, final ServiceCallback<IstungjRk> serviceCallback) {
        return ServiceFuture.fromResponse(getCurrentSessionUsingGETWithServiceResponseAsync(lang), serviceCallback);
    }

    /**
     * Praegune istungjärk.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IstungjRk object
     */
    public Observable<IstungjRk> getCurrentSessionUsingGETAsync(String lang) {
        return getCurrentSessionUsingGETWithServiceResponseAsync(lang).map(new Func1<ServiceResponse<IstungjRk>, IstungjRk>() {
            @Override
            public IstungjRk call(ServiceResponse<IstungjRk> response) {
                return response.body();
            }
        });
    }

    /**
     * Praegune istungjärk.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the IstungjRk object
     */
    public Observable<ServiceResponse<IstungjRk>> getCurrentSessionUsingGETWithServiceResponseAsync(String lang) {
        return service.getCurrentSessionUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IstungjRk>>>() {
                @Override
                public Observable<ServiceResponse<IstungjRk>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IstungjRk> clientResponse = getCurrentSessionUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IstungjRk> getCurrentSessionUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<IstungjRk, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IstungjRk>() { }.getType())
                .build(response);
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiigeOsavTt&gt; object if successful.
     */
    public List<RiigikoguLiigeOsavTt> getFactionParticipationUsingGET(LocalDate endDate, LocalDate startDate, String uuid) {
        return getFactionParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid).toBlocking().single().body();
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiigeOsavTt>> getFactionParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, final ServiceCallback<List<RiigikoguLiigeOsavTt>> serviceCallback) {
        return ServiceFuture.fromResponse(getFactionParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid), serviceCallback);
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeOsavTt&gt; object
     */
    public Observable<List<RiigikoguLiigeOsavTt>> getFactionParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        return getFactionParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid).map(new Func1<ServiceResponse<List<RiigikoguLiigeOsavTt>>, List<RiigikoguLiigeOsavTt>>() {
            @Override
            public List<RiigikoguLiigeOsavTt> call(ServiceResponse<List<RiigikoguLiigeOsavTt>> response) {
                return response.body();
            }
        });
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeOsavTt&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiigeOsavTt>>> getFactionParticipationUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getFactionParticipationUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiigeOsavTt>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiigeOsavTt>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiigeOsavTt>> clientResponse = getFactionParticipationUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiigeOsavTt&gt; object if successful.
     */
    public List<RiigikoguLiigeOsavTt> getFactionParticipationUsingGET(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getFactionParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).toBlocking().single().body();
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiigeOsavTt>> getFactionParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang, final ServiceCallback<List<RiigikoguLiigeOsavTt>> serviceCallback) {
        return ServiceFuture.fromResponse(getFactionParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang), serviceCallback);
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeOsavTt&gt; object
     */
    public Observable<List<RiigikoguLiigeOsavTt>> getFactionParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getFactionParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).map(new Func1<ServiceResponse<List<RiigikoguLiigeOsavTt>>, List<RiigikoguLiigeOsavTt>>() {
            @Override
            public List<RiigikoguLiigeOsavTt> call(ServiceResponse<List<RiigikoguLiigeOsavTt>> response) {
                return response.body();
            }
        });
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeOsavTt&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiigeOsavTt>>> getFactionParticipationUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getFactionParticipationUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiigeOsavTt>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiigeOsavTt>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiigeOsavTt>> clientResponse = getFactionParticipationUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<RiigikoguLiigeOsavTt>> getFactionParticipationUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<RiigikoguLiigeOsavTt>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RiigikoguLiigeOsavTt>>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RiigikoguLiigeOsavTt object if successful.
     */
    public RiigikoguLiigeOsavTt getMemberParticipationUsingGET(LocalDate endDate, LocalDate startDate, String uuid) {
        return getMemberParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RiigikoguLiigeOsavTt> getMemberParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, final ServiceCallback<RiigikoguLiigeOsavTt> serviceCallback) {
        return ServiceFuture.fromResponse(getMemberParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid), serviceCallback);
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiigeOsavTt object
     */
    public Observable<RiigikoguLiigeOsavTt> getMemberParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        return getMemberParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid).map(new Func1<ServiceResponse<RiigikoguLiigeOsavTt>, RiigikoguLiigeOsavTt>() {
            @Override
            public RiigikoguLiigeOsavTt call(ServiceResponse<RiigikoguLiigeOsavTt> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiigeOsavTt object
     */
    public Observable<ServiceResponse<RiigikoguLiigeOsavTt>> getMemberParticipationUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final Boolean details = null;
        final String lang = null;
        return service.getMemberParticipationUsingGET(uuid, details, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RiigikoguLiigeOsavTt>>>() {
                @Override
                public Observable<ServiceResponse<RiigikoguLiigeOsavTt>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RiigikoguLiigeOsavTt> clientResponse = getMemberParticipationUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param details details
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RiigikoguLiigeOsavTt object if successful.
     */
    public RiigikoguLiigeOsavTt getMemberParticipationUsingGET(LocalDate endDate, LocalDate startDate, String uuid, Boolean details, String lang) {
        return getMemberParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid, details, lang).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param details details
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RiigikoguLiigeOsavTt> getMemberParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, Boolean details, String lang, final ServiceCallback<RiigikoguLiigeOsavTt> serviceCallback) {
        return ServiceFuture.fromResponse(getMemberParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid, details, lang), serviceCallback);
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param details details
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiigeOsavTt object
     */
    public Observable<RiigikoguLiigeOsavTt> getMemberParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, Boolean details, String lang) {
        return getMemberParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid, details, lang).map(new Func1<ServiceResponse<RiigikoguLiigeOsavTt>, RiigikoguLiigeOsavTt>() {
            @Override
            public RiigikoguLiigeOsavTt call(ServiceResponse<RiigikoguLiigeOsavTt> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param details details
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiigeOsavTt object
     */
    public Observable<ServiceResponse<RiigikoguLiigeOsavTt>> getMemberParticipationUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid, Boolean details, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getMemberParticipationUsingGET(uuid, details, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RiigikoguLiigeOsavTt>>>() {
                @Override
                public Observable<ServiceResponse<RiigikoguLiigeOsavTt>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RiigikoguLiigeOsavTt> clientResponse = getMemberParticipationUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RiigikoguLiigeOsavTt> getMemberParticipationUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RiigikoguLiigeOsavTt, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RiigikoguLiigeOsavTt>() { }.getType())
                .build(response);
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiigeOsavTt&gt; object if successful.
     */
    public List<RiigikoguLiigeOsavTt> getPlenaryParticipationUsingGET(LocalDate endDate, LocalDate startDate) {
        return getPlenaryParticipationUsingGETWithServiceResponseAsync(endDate, startDate).toBlocking().single().body();
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiigeOsavTt>> getPlenaryParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, final ServiceCallback<List<RiigikoguLiigeOsavTt>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryParticipationUsingGETWithServiceResponseAsync(endDate, startDate), serviceCallback);
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeOsavTt&gt; object
     */
    public Observable<List<RiigikoguLiigeOsavTt>> getPlenaryParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate) {
        return getPlenaryParticipationUsingGETWithServiceResponseAsync(endDate, startDate).map(new Func1<ServiceResponse<List<RiigikoguLiigeOsavTt>>, List<RiigikoguLiigeOsavTt>>() {
            @Override
            public List<RiigikoguLiigeOsavTt> call(ServiceResponse<List<RiigikoguLiigeOsavTt>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeOsavTt&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiigeOsavTt>>> getPlenaryParticipationUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        final String lang = null;
        return service.getPlenaryParticipationUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiigeOsavTt>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiigeOsavTt>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiigeOsavTt>> clientResponse = getPlenaryParticipationUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiigeOsavTt&gt; object if successful.
     */
    public List<RiigikoguLiigeOsavTt> getPlenaryParticipationUsingGET(LocalDate endDate, LocalDate startDate, String lang) {
        return getPlenaryParticipationUsingGETWithServiceResponseAsync(endDate, startDate, lang).toBlocking().single().body();
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiigeOsavTt>> getPlenaryParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang, final ServiceCallback<List<RiigikoguLiigeOsavTt>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryParticipationUsingGETWithServiceResponseAsync(endDate, startDate, lang), serviceCallback);
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeOsavTt&gt; object
     */
    public Observable<List<RiigikoguLiigeOsavTt>> getPlenaryParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang) {
        return getPlenaryParticipationUsingGETWithServiceResponseAsync(endDate, startDate, lang).map(new Func1<ServiceResponse<List<RiigikoguLiigeOsavTt>>, List<RiigikoguLiigeOsavTt>>() {
            @Override
            public List<RiigikoguLiigeOsavTt> call(ServiceResponse<List<RiigikoguLiigeOsavTt>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeOsavTt&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiigeOsavTt>>> getPlenaryParticipationUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        return service.getPlenaryParticipationUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiigeOsavTt>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiigeOsavTt>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiigeOsavTt>> clientResponse = getPlenaryParticipationUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<RiigikoguLiigeOsavTt>> getPlenaryParticipationUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<RiigikoguLiigeOsavTt>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RiigikoguLiigeOsavTt>>() { }.getType())
                .build(response);
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiigeSNavTud&gt; object if successful.
     */
    public List<RiigikoguLiigeSNavTud> getFactionSpeechStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid) {
        return getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).toBlocking().single().body();
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiigeSNavTud>> getFactionSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, final ServiceCallback<List<RiigikoguLiigeSNavTud>> serviceCallback) {
        return ServiceFuture.fromResponse(getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid), serviceCallback);
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeSNavTud&gt; object
     */
    public Observable<List<RiigikoguLiigeSNavTud>> getFactionSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        return getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).map(new Func1<ServiceResponse<List<RiigikoguLiigeSNavTud>>, List<RiigikoguLiigeSNavTud>>() {
            @Override
            public List<RiigikoguLiigeSNavTud> call(ServiceResponse<List<RiigikoguLiigeSNavTud>> response) {
                return response.body();
            }
        });
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeSNavTud&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiigeSNavTud>>> getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getFactionSpeechStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiigeSNavTud>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiigeSNavTud>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiigeSNavTud>> clientResponse = getFactionSpeechStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiigeSNavTud&gt; object if successful.
     */
    public List<RiigikoguLiigeSNavTud> getFactionSpeechStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).toBlocking().single().body();
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiigeSNavTud>> getFactionSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang, final ServiceCallback<List<RiigikoguLiigeSNavTud>> serviceCallback) {
        return ServiceFuture.fromResponse(getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang), serviceCallback);
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeSNavTud&gt; object
     */
    public Observable<List<RiigikoguLiigeSNavTud>> getFactionSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).map(new Func1<ServiceResponse<List<RiigikoguLiigeSNavTud>>, List<RiigikoguLiigeSNavTud>>() {
            @Override
            public List<RiigikoguLiigeSNavTud> call(ServiceResponse<List<RiigikoguLiigeSNavTud>> response) {
                return response.body();
            }
        });
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeSNavTud&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiigeSNavTud>>> getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getFactionSpeechStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiigeSNavTud>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiigeSNavTud>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiigeSNavTud>> clientResponse = getFactionSpeechStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<RiigikoguLiigeSNavTud>> getFactionSpeechStatisticsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<RiigikoguLiigeSNavTud>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RiigikoguLiigeSNavTud>>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RiigikoguLiigeSNavTud object if successful.
     */
    public RiigikoguLiigeSNavTud getMemberSpeechStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid) {
        return getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RiigikoguLiigeSNavTud> getMemberSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, final ServiceCallback<RiigikoguLiigeSNavTud> serviceCallback) {
        return ServiceFuture.fromResponse(getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid), serviceCallback);
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiigeSNavTud object
     */
    public Observable<RiigikoguLiigeSNavTud> getMemberSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        return getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).map(new Func1<ServiceResponse<RiigikoguLiigeSNavTud>, RiigikoguLiigeSNavTud>() {
            @Override
            public RiigikoguLiigeSNavTud call(ServiceResponse<RiigikoguLiigeSNavTud> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiigeSNavTud object
     */
    public Observable<ServiceResponse<RiigikoguLiigeSNavTud>> getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getMemberSpeechStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RiigikoguLiigeSNavTud>>>() {
                @Override
                public Observable<ServiceResponse<RiigikoguLiigeSNavTud>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RiigikoguLiigeSNavTud> clientResponse = getMemberSpeechStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RiigikoguLiigeSNavTud object if successful.
     */
    public RiigikoguLiigeSNavTud getMemberSpeechStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RiigikoguLiigeSNavTud> getMemberSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang, final ServiceCallback<RiigikoguLiigeSNavTud> serviceCallback) {
        return ServiceFuture.fromResponse(getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang), serviceCallback);
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiigeSNavTud object
     */
    public Observable<RiigikoguLiigeSNavTud> getMemberSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).map(new Func1<ServiceResponse<RiigikoguLiigeSNavTud>, RiigikoguLiigeSNavTud>() {
            @Override
            public RiigikoguLiigeSNavTud call(ServiceResponse<RiigikoguLiigeSNavTud> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiigeSNavTud object
     */
    public Observable<ServiceResponse<RiigikoguLiigeSNavTud>> getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getMemberSpeechStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RiigikoguLiigeSNavTud>>>() {
                @Override
                public Observable<ServiceResponse<RiigikoguLiigeSNavTud>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RiigikoguLiigeSNavTud> clientResponse = getMemberSpeechStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RiigikoguLiigeSNavTud> getMemberSpeechStatisticsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RiigikoguLiigeSNavTud, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RiigikoguLiigeSNavTud>() { }.getType())
                .build(response);
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiigeSNavTud&gt; object if successful.
     */
    public List<RiigikoguLiigeSNavTud> getPlenarySpeechStatisticsUsingGET(LocalDate endDate, LocalDate startDate) {
        return getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate).toBlocking().single().body();
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiigeSNavTud>> getPlenarySpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, final ServiceCallback<List<RiigikoguLiigeSNavTud>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate), serviceCallback);
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeSNavTud&gt; object
     */
    public Observable<List<RiigikoguLiigeSNavTud>> getPlenarySpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate) {
        return getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate).map(new Func1<ServiceResponse<List<RiigikoguLiigeSNavTud>>, List<RiigikoguLiigeSNavTud>>() {
            @Override
            public List<RiigikoguLiigeSNavTud> call(ServiceResponse<List<RiigikoguLiigeSNavTud>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeSNavTud&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiigeSNavTud>>> getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        final String lang = null;
        return service.getPlenarySpeechStatisticsUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiigeSNavTud>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiigeSNavTud>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiigeSNavTud>> clientResponse = getPlenarySpeechStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiigeSNavTud&gt; object if successful.
     */
    public List<RiigikoguLiigeSNavTud> getPlenarySpeechStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String lang) {
        return getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, lang).toBlocking().single().body();
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiigeSNavTud>> getPlenarySpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang, final ServiceCallback<List<RiigikoguLiigeSNavTud>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, lang), serviceCallback);
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeSNavTud&gt; object
     */
    public Observable<List<RiigikoguLiigeSNavTud>> getPlenarySpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang) {
        return getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, lang).map(new Func1<ServiceResponse<List<RiigikoguLiigeSNavTud>>, List<RiigikoguLiigeSNavTud>>() {
            @Override
            public List<RiigikoguLiigeSNavTud> call(ServiceResponse<List<RiigikoguLiigeSNavTud>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeSNavTud&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiigeSNavTud>>> getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        return service.getPlenarySpeechStatisticsUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiigeSNavTud>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiigeSNavTud>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiigeSNavTud>> clientResponse = getPlenarySpeechStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<RiigikoguLiigeSNavTud>> getPlenarySpeechStatisticsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<RiigikoguLiigeSNavTud>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RiigikoguLiigeSNavTud>>() { }.getType())
                .build(response);
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiigeHLetused&gt; object if successful.
     */
    public List<RiigikoguLiigeHLetused> getFactionVotingStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid) {
        return getFactionVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).toBlocking().single().body();
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiigeHLetused>> getFactionVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, final ServiceCallback<List<RiigikoguLiigeHLetused>> serviceCallback) {
        return ServiceFuture.fromResponse(getFactionVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid), serviceCallback);
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeHLetused&gt; object
     */
    public Observable<List<RiigikoguLiigeHLetused>> getFactionVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        return getFactionVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).map(new Func1<ServiceResponse<List<RiigikoguLiigeHLetused>>, List<RiigikoguLiigeHLetused>>() {
            @Override
            public List<RiigikoguLiigeHLetused> call(ServiceResponse<List<RiigikoguLiigeHLetused>> response) {
                return response.body();
            }
        });
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeHLetused&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiigeHLetused>>> getFactionVotingStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getFactionVotingStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiigeHLetused>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiigeHLetused>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiigeHLetused>> clientResponse = getFactionVotingStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiigeHLetused&gt; object if successful.
     */
    public List<RiigikoguLiigeHLetused> getFactionVotingStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getFactionVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).toBlocking().single().body();
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiigeHLetused>> getFactionVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang, final ServiceCallback<List<RiigikoguLiigeHLetused>> serviceCallback) {
        return ServiceFuture.fromResponse(getFactionVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang), serviceCallback);
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeHLetused&gt; object
     */
    public Observable<List<RiigikoguLiigeHLetused>> getFactionVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getFactionVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).map(new Func1<ServiceResponse<List<RiigikoguLiigeHLetused>>, List<RiigikoguLiigeHLetused>>() {
            @Override
            public List<RiigikoguLiigeHLetused> call(ServiceResponse<List<RiigikoguLiigeHLetused>> response) {
                return response.body();
            }
        });
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeHLetused&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiigeHLetused>>> getFactionVotingStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getFactionVotingStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiigeHLetused>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiigeHLetused>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiigeHLetused>> clientResponse = getFactionVotingStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<RiigikoguLiigeHLetused>> getFactionVotingStatisticsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<RiigikoguLiigeHLetused>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RiigikoguLiigeHLetused>>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RiigikoguLiigeHLetused object if successful.
     */
    public RiigikoguLiigeHLetused getMemberVotingStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid) {
        return getMemberVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RiigikoguLiigeHLetused> getMemberVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, final ServiceCallback<RiigikoguLiigeHLetused> serviceCallback) {
        return ServiceFuture.fromResponse(getMemberVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid), serviceCallback);
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiigeHLetused object
     */
    public Observable<RiigikoguLiigeHLetused> getMemberVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        return getMemberVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).map(new Func1<ServiceResponse<RiigikoguLiigeHLetused>, RiigikoguLiigeHLetused>() {
            @Override
            public RiigikoguLiigeHLetused call(ServiceResponse<RiigikoguLiigeHLetused> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiigeHLetused object
     */
    public Observable<ServiceResponse<RiigikoguLiigeHLetused>> getMemberVotingStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getMemberVotingStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RiigikoguLiigeHLetused>>>() {
                @Override
                public Observable<ServiceResponse<RiigikoguLiigeHLetused>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RiigikoguLiigeHLetused> clientResponse = getMemberVotingStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RiigikoguLiigeHLetused object if successful.
     */
    public RiigikoguLiigeHLetused getMemberVotingStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getMemberVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RiigikoguLiigeHLetused> getMemberVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang, final ServiceCallback<RiigikoguLiigeHLetused> serviceCallback) {
        return ServiceFuture.fromResponse(getMemberVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang), serviceCallback);
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiigeHLetused object
     */
    public Observable<RiigikoguLiigeHLetused> getMemberVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getMemberVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).map(new Func1<ServiceResponse<RiigikoguLiigeHLetused>, RiigikoguLiigeHLetused>() {
            @Override
            public RiigikoguLiigeHLetused call(ServiceResponse<RiigikoguLiigeHLetused> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RiigikoguLiigeHLetused object
     */
    public Observable<ServiceResponse<RiigikoguLiigeHLetused>> getMemberVotingStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getMemberVotingStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RiigikoguLiigeHLetused>>>() {
                @Override
                public Observable<ServiceResponse<RiigikoguLiigeHLetused>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RiigikoguLiigeHLetused> clientResponse = getMemberVotingStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RiigikoguLiigeHLetused> getMemberVotingStatisticsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RiigikoguLiigeHLetused, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RiigikoguLiigeHLetused>() { }.getType())
                .build(response);
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiigeHLetused&gt; object if successful.
     */
    public List<RiigikoguLiigeHLetused> getPlenaryVotingStatisticsUsingGET(LocalDate endDate, LocalDate startDate) {
        return getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate).toBlocking().single().body();
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiigeHLetused>> getPlenaryVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, final ServiceCallback<List<RiigikoguLiigeHLetused>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate), serviceCallback);
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeHLetused&gt; object
     */
    public Observable<List<RiigikoguLiigeHLetused>> getPlenaryVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate) {
        return getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate).map(new Func1<ServiceResponse<List<RiigikoguLiigeHLetused>>, List<RiigikoguLiigeHLetused>>() {
            @Override
            public List<RiigikoguLiigeHLetused> call(ServiceResponse<List<RiigikoguLiigeHLetused>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeHLetused&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiigeHLetused>>> getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        final String lang = null;
        return service.getPlenaryVotingStatisticsUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiigeHLetused>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiigeHLetused>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiigeHLetused>> clientResponse = getPlenaryVotingStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RiigikoguLiigeHLetused&gt; object if successful.
     */
    public List<RiigikoguLiigeHLetused> getPlenaryVotingStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String lang) {
        return getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, lang).toBlocking().single().body();
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RiigikoguLiigeHLetused>> getPlenaryVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang, final ServiceCallback<List<RiigikoguLiigeHLetused>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, lang), serviceCallback);
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeHLetused&gt; object
     */
    public Observable<List<RiigikoguLiigeHLetused>> getPlenaryVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang) {
        return getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, lang).map(new Func1<ServiceResponse<List<RiigikoguLiigeHLetused>>, List<RiigikoguLiigeHLetused>>() {
            @Override
            public List<RiigikoguLiigeHLetused> call(ServiceResponse<List<RiigikoguLiigeHLetused>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RiigikoguLiigeHLetused&gt; object
     */
    public Observable<ServiceResponse<List<RiigikoguLiigeHLetused>>> getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        return service.getPlenaryVotingStatisticsUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RiigikoguLiigeHLetused>>>>() {
                @Override
                public Observable<ServiceResponse<List<RiigikoguLiigeHLetused>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RiigikoguLiigeHLetused>> clientResponse = getPlenaryVotingStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<RiigikoguLiigeHLetused>> getPlenaryVotingStatisticsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<RiigikoguLiigeHLetused>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RiigikoguLiigeHLetused>>() { }.getType())
                .build(response);
    }

    /**
     * Päevakorrapunktide steno lingid.
     * Steno XML-RPC teenus: getStenoTekstPaevakordUrl.
     *
     * @param uuids Päevakorrapunktide UUID-d (komaga eraldatud)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;StenoPEvakorrapunkt&gt; object if successful.
     */
    public List<StenoPEvakorrapunkt> getAgendaUrlsUsingGET(String uuids) {
        return getAgendaUrlsUsingGETWithServiceResponseAsync(uuids).toBlocking().single().body();
    }

    /**
     * Päevakorrapunktide steno lingid.
     * Steno XML-RPC teenus: getStenoTekstPaevakordUrl.
     *
     * @param uuids Päevakorrapunktide UUID-d (komaga eraldatud)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StenoPEvakorrapunkt>> getAgendaUrlsUsingGETAsync(String uuids, final ServiceCallback<List<StenoPEvakorrapunkt>> serviceCallback) {
        return ServiceFuture.fromResponse(getAgendaUrlsUsingGETWithServiceResponseAsync(uuids), serviceCallback);
    }

    /**
     * Päevakorrapunktide steno lingid.
     * Steno XML-RPC teenus: getStenoTekstPaevakordUrl.
     *
     * @param uuids Päevakorrapunktide UUID-d (komaga eraldatud)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;StenoPEvakorrapunkt&gt; object
     */
    public Observable<List<StenoPEvakorrapunkt>> getAgendaUrlsUsingGETAsync(String uuids) {
        return getAgendaUrlsUsingGETWithServiceResponseAsync(uuids).map(new Func1<ServiceResponse<List<StenoPEvakorrapunkt>>, List<StenoPEvakorrapunkt>>() {
            @Override
            public List<StenoPEvakorrapunkt> call(ServiceResponse<List<StenoPEvakorrapunkt>> response) {
                return response.body();
            }
        });
    }

    /**
     * Päevakorrapunktide steno lingid.
     * Steno XML-RPC teenus: getStenoTekstPaevakordUrl.
     *
     * @param uuids Päevakorrapunktide UUID-d (komaga eraldatud)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;StenoPEvakorrapunkt&gt; object
     */
    public Observable<ServiceResponse<List<StenoPEvakorrapunkt>>> getAgendaUrlsUsingGETWithServiceResponseAsync(String uuids) {
        if (uuids == null) {
            throw new IllegalArgumentException("Parameter uuids is required and cannot be null.");
        }
        return service.getAgendaUrlsUsingGET(uuids)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<StenoPEvakorrapunkt>>>>() {
                @Override
                public Observable<ServiceResponse<List<StenoPEvakorrapunkt>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<StenoPEvakorrapunkt>> clientResponse = getAgendaUrlsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<StenoPEvakorrapunkt>> getAgendaUrlsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<StenoPEvakorrapunkt>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<StenoPEvakorrapunkt>>() { }.getType())
                .build(response);
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getLastVerbatimsUsingGET() {
        return getLastVerbatimsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getLastVerbatimsUsingGETAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getLastVerbatimsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getLastVerbatimsUsingGETAsync() {
        return getLastVerbatimsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getLastVerbatimsUsingGETWithServiceResponseAsync() {
        final Integer count = null;
        return service.getLastVerbatimsUsingGET(count)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getLastVerbatimsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @param count Tagastatavate stenogrammide arv
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getLastVerbatimsUsingGET(Integer count) {
        return getLastVerbatimsUsingGETWithServiceResponseAsync(count).toBlocking().single().body();
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @param count Tagastatavate stenogrammide arv
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getLastVerbatimsUsingGETAsync(Integer count, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getLastVerbatimsUsingGETWithServiceResponseAsync(count), serviceCallback);
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @param count Tagastatavate stenogrammide arv
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getLastVerbatimsUsingGETAsync(Integer count) {
        return getLastVerbatimsUsingGETWithServiceResponseAsync(count).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @param count Tagastatavate stenogrammide arv
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getLastVerbatimsUsingGETWithServiceResponseAsync(Integer count) {
        return service.getLastVerbatimsUsingGET(count)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getLastVerbatimsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getLastVerbatimsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .build(response);
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;StenoSNavTud&gt; object if successful.
     */
    public List<StenoSNavTud> getSpeechesUsingGET(LocalDate endDate, LocalDate startDate, String userUuids) {
        return getSpeechesUsingGETWithServiceResponseAsync(endDate, startDate, userUuids).toBlocking().single().body();
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StenoSNavTud>> getSpeechesUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuids, final ServiceCallback<List<StenoSNavTud>> serviceCallback) {
        return ServiceFuture.fromResponse(getSpeechesUsingGETWithServiceResponseAsync(endDate, startDate, userUuids), serviceCallback);
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;StenoSNavTud&gt; object
     */
    public Observable<List<StenoSNavTud>> getSpeechesUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuids) {
        return getSpeechesUsingGETWithServiceResponseAsync(endDate, startDate, userUuids).map(new Func1<ServiceResponse<List<StenoSNavTud>>, List<StenoSNavTud>>() {
            @Override
            public List<StenoSNavTud> call(ServiceResponse<List<StenoSNavTud>> response) {
                return response.body();
            }
        });
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;StenoSNavTud&gt; object
     */
    public Observable<ServiceResponse<List<StenoSNavTud>>> getSpeechesUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String userUuids) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (userUuids == null) {
            throw new IllegalArgumentException("Parameter userUuids is required and cannot be null.");
        }
        final Integer membership = null;
        return service.getSpeechesUsingGET(endDate, membership, startDate, userUuids)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<StenoSNavTud>>>>() {
                @Override
                public Observable<ServiceResponse<List<StenoSNavTud>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<StenoSNavTud>> clientResponse = getSpeechesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @param membership Koosseisu number
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;StenoSNavTud&gt; object if successful.
     */
    public List<StenoSNavTud> getSpeechesUsingGET(LocalDate endDate, LocalDate startDate, String userUuids, Integer membership) {
        return getSpeechesUsingGETWithServiceResponseAsync(endDate, startDate, userUuids, membership).toBlocking().single().body();
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @param membership Koosseisu number
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StenoSNavTud>> getSpeechesUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuids, Integer membership, final ServiceCallback<List<StenoSNavTud>> serviceCallback) {
        return ServiceFuture.fromResponse(getSpeechesUsingGETWithServiceResponseAsync(endDate, startDate, userUuids, membership), serviceCallback);
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @param membership Koosseisu number
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;StenoSNavTud&gt; object
     */
    public Observable<List<StenoSNavTud>> getSpeechesUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuids, Integer membership) {
        return getSpeechesUsingGETWithServiceResponseAsync(endDate, startDate, userUuids, membership).map(new Func1<ServiceResponse<List<StenoSNavTud>>, List<StenoSNavTud>>() {
            @Override
            public List<StenoSNavTud> call(ServiceResponse<List<StenoSNavTud>> response) {
                return response.body();
            }
        });
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @param membership Koosseisu number
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;StenoSNavTud&gt; object
     */
    public Observable<ServiceResponse<List<StenoSNavTud>>> getSpeechesUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String userUuids, Integer membership) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (userUuids == null) {
            throw new IllegalArgumentException("Parameter userUuids is required and cannot be null.");
        }
        return service.getSpeechesUsingGET(endDate, membership, startDate, userUuids)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<StenoSNavTud>>>>() {
                @Override
                public Observable<ServiceResponse<List<StenoSNavTud>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<StenoSNavTud>> clientResponse = getSpeechesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<StenoSNavTud>> getSpeechesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<StenoSNavTud>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<StenoSNavTud>>() { }.getType())
                .build(response);
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StenoSNavTtudeArv object if successful.
     */
    public StenoSNavTtudeArv getSpeechCountUsingGET(LocalDate endDate, LocalDate startDate, String userUuid) {
        return getSpeechCountUsingGETWithServiceResponseAsync(endDate, startDate, userUuid).toBlocking().single().body();
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StenoSNavTtudeArv> getSpeechCountUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuid, final ServiceCallback<StenoSNavTtudeArv> serviceCallback) {
        return ServiceFuture.fromResponse(getSpeechCountUsingGETWithServiceResponseAsync(endDate, startDate, userUuid), serviceCallback);
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StenoSNavTtudeArv object
     */
    public Observable<StenoSNavTtudeArv> getSpeechCountUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuid) {
        return getSpeechCountUsingGETWithServiceResponseAsync(endDate, startDate, userUuid).map(new Func1<ServiceResponse<StenoSNavTtudeArv>, StenoSNavTtudeArv>() {
            @Override
            public StenoSNavTtudeArv call(ServiceResponse<StenoSNavTtudeArv> response) {
                return response.body();
            }
        });
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StenoSNavTtudeArv object
     */
    public Observable<ServiceResponse<StenoSNavTtudeArv>> getSpeechCountUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String userUuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (userUuid == null) {
            throw new IllegalArgumentException("Parameter userUuid is required and cannot be null.");
        }
        final Integer membership = null;
        final String type = null;
        return service.getSpeechCountUsingGET(endDate, membership, startDate, type, userUuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StenoSNavTtudeArv>>>() {
                @Override
                public Observable<ServiceResponse<StenoSNavTtudeArv>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StenoSNavTtudeArv> clientResponse = getSpeechCountUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StenoSNavTtudeArv object if successful.
     */
    public StenoSNavTtudeArv getSpeechCountUsingGET(LocalDate endDate, LocalDate startDate, String userUuid, Integer membership, String type) {
        return getSpeechCountUsingGETWithServiceResponseAsync(endDate, startDate, userUuid, membership, type).toBlocking().single().body();
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StenoSNavTtudeArv> getSpeechCountUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuid, Integer membership, String type, final ServiceCallback<StenoSNavTtudeArv> serviceCallback) {
        return ServiceFuture.fromResponse(getSpeechCountUsingGETWithServiceResponseAsync(endDate, startDate, userUuid, membership, type), serviceCallback);
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StenoSNavTtudeArv object
     */
    public Observable<StenoSNavTtudeArv> getSpeechCountUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuid, Integer membership, String type) {
        return getSpeechCountUsingGETWithServiceResponseAsync(endDate, startDate, userUuid, membership, type).map(new Func1<ServiceResponse<StenoSNavTtudeArv>, StenoSNavTtudeArv>() {
            @Override
            public StenoSNavTtudeArv call(ServiceResponse<StenoSNavTtudeArv> response) {
                return response.body();
            }
        });
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StenoSNavTtudeArv object
     */
    public Observable<ServiceResponse<StenoSNavTtudeArv>> getSpeechCountUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String userUuid, Integer membership, String type) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (userUuid == null) {
            throw new IllegalArgumentException("Parameter userUuid is required and cannot be null.");
        }
        return service.getSpeechCountUsingGET(endDate, membership, startDate, type, userUuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StenoSNavTtudeArv>>>() {
                @Override
                public Observable<ServiceResponse<StenoSNavTtudeArv>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StenoSNavTtudeArv> clientResponse = getSpeechCountUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StenoSNavTtudeArv> getSpeechCountUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<StenoSNavTtudeArv, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<StenoSNavTtudeArv>() { }.getType())
                .build(response);
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StenoViimaneSNavTt object if successful.
     */
    public StenoViimaneSNavTt getLastSpeechUsingGET(String userUuid) {
        return getLastSpeechUsingGETWithServiceResponseAsync(userUuid).toBlocking().single().body();
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StenoViimaneSNavTt> getLastSpeechUsingGETAsync(String userUuid, final ServiceCallback<StenoViimaneSNavTt> serviceCallback) {
        return ServiceFuture.fromResponse(getLastSpeechUsingGETWithServiceResponseAsync(userUuid), serviceCallback);
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StenoViimaneSNavTt object
     */
    public Observable<StenoViimaneSNavTt> getLastSpeechUsingGETAsync(String userUuid) {
        return getLastSpeechUsingGETWithServiceResponseAsync(userUuid).map(new Func1<ServiceResponse<StenoViimaneSNavTt>, StenoViimaneSNavTt>() {
            @Override
            public StenoViimaneSNavTt call(ServiceResponse<StenoViimaneSNavTt> response) {
                return response.body();
            }
        });
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StenoViimaneSNavTt object
     */
    public Observable<ServiceResponse<StenoViimaneSNavTt>> getLastSpeechUsingGETWithServiceResponseAsync(String userUuid) {
        if (userUuid == null) {
            throw new IllegalArgumentException("Parameter userUuid is required and cannot be null.");
        }
        final Integer charCount = null;
        final Integer membership = null;
        final String type = null;
        return service.getLastSpeechUsingGET(charCount, membership, type, userUuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StenoViimaneSNavTt>>>() {
                @Override
                public Observable<ServiceResponse<StenoViimaneSNavTt>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StenoViimaneSNavTt> clientResponse = getLastSpeechUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @param charCount Tähemärkide arv
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StenoViimaneSNavTt object if successful.
     */
    public StenoViimaneSNavTt getLastSpeechUsingGET(String userUuid, Integer charCount, Integer membership, String type) {
        return getLastSpeechUsingGETWithServiceResponseAsync(userUuid, charCount, membership, type).toBlocking().single().body();
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @param charCount Tähemärkide arv
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StenoViimaneSNavTt> getLastSpeechUsingGETAsync(String userUuid, Integer charCount, Integer membership, String type, final ServiceCallback<StenoViimaneSNavTt> serviceCallback) {
        return ServiceFuture.fromResponse(getLastSpeechUsingGETWithServiceResponseAsync(userUuid, charCount, membership, type), serviceCallback);
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @param charCount Tähemärkide arv
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StenoViimaneSNavTt object
     */
    public Observable<StenoViimaneSNavTt> getLastSpeechUsingGETAsync(String userUuid, Integer charCount, Integer membership, String type) {
        return getLastSpeechUsingGETWithServiceResponseAsync(userUuid, charCount, membership, type).map(new Func1<ServiceResponse<StenoViimaneSNavTt>, StenoViimaneSNavTt>() {
            @Override
            public StenoViimaneSNavTt call(ServiceResponse<StenoViimaneSNavTt> response) {
                return response.body();
            }
        });
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @param charCount Tähemärkide arv
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StenoViimaneSNavTt object
     */
    public Observable<ServiceResponse<StenoViimaneSNavTt>> getLastSpeechUsingGETWithServiceResponseAsync(String userUuid, Integer charCount, Integer membership, String type) {
        if (userUuid == null) {
            throw new IllegalArgumentException("Parameter userUuid is required and cannot be null.");
        }
        return service.getLastSpeechUsingGET(charCount, membership, type, userUuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StenoViimaneSNavTt>>>() {
                @Override
                public Observable<ServiceResponse<StenoViimaneSNavTt>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StenoViimaneSNavTt> clientResponse = getLastSpeechUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StenoViimaneSNavTt> getLastSpeechUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<StenoViimaneSNavTt, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<StenoViimaneSNavTt>() { }.getType())
                .build(response);
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Kasutajagrupp&gt; object if successful.
     */
    public List<Kasutajagrupp> findUserGroupsUsingGET() {
        return findUserGroupsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Kasutajagrupp>> findUserGroupsUsingGETAsync(final ServiceCallback<List<Kasutajagrupp>> serviceCallback) {
        return ServiceFuture.fromResponse(findUserGroupsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Kasutajagrupp&gt; object
     */
    public Observable<List<Kasutajagrupp>> findUserGroupsUsingGETAsync() {
        return findUserGroupsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Kasutajagrupp>>, List<Kasutajagrupp>>() {
            @Override
            public List<Kasutajagrupp> call(ServiceResponse<List<Kasutajagrupp>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Kasutajagrupp&gt; object
     */
    public Observable<ServiceResponse<List<Kasutajagrupp>>> findUserGroupsUsingGETWithServiceResponseAsync() {
        final Boolean hideInactive = null;
        final String lang = null;
        final String name = null;
        final String typeCode = null;
        return service.findUserGroupsUsingGET(hideInactive, lang, name, typeCode)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Kasutajagrupp>>>>() {
                @Override
                public Observable<ServiceResponse<List<Kasutajagrupp>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Kasutajagrupp>> clientResponse = findUserGroupsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @param hideInactive hideInactive
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param name Nimi
     * @param typeCode Tüübi kood (klassifikaator 'kasutajagrupiTuup'). Possible values include: 'UURIMISKOMISJON', 'VANA_FRAKTSIOON', 'VANA_ERIKOMISJON', 'VANA_ALALINE_KOMISJON', 'ALALINE_KOMISJON', 'ERIKOMISJON', 'RIIGIKOGU_JUHATUS', 'ESIMEHE_BÜROO', 'OSAKOND', 'VALIMISRINGKOND', 'TOETUSRYHM', 'ASUTUSE_YKSUS', 'PARLAMENDIRYHM', 'YHENDUS', 'FRAKTSIOON', 'DELEGATSIOON', 'RIIGIKOGU_TAISKOGU', 'ERAKOND', 'AMETNIK', 'TALITUS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Kasutajagrupp&gt; object if successful.
     */
    public List<Kasutajagrupp> findUserGroupsUsingGET(Boolean hideInactive, String lang, String name, String typeCode) {
        return findUserGroupsUsingGETWithServiceResponseAsync(hideInactive, lang, name, typeCode).toBlocking().single().body();
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @param hideInactive hideInactive
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param name Nimi
     * @param typeCode Tüübi kood (klassifikaator 'kasutajagrupiTuup'). Possible values include: 'UURIMISKOMISJON', 'VANA_FRAKTSIOON', 'VANA_ERIKOMISJON', 'VANA_ALALINE_KOMISJON', 'ALALINE_KOMISJON', 'ERIKOMISJON', 'RIIGIKOGU_JUHATUS', 'ESIMEHE_BÜROO', 'OSAKOND', 'VALIMISRINGKOND', 'TOETUSRYHM', 'ASUTUSE_YKSUS', 'PARLAMENDIRYHM', 'YHENDUS', 'FRAKTSIOON', 'DELEGATSIOON', 'RIIGIKOGU_TAISKOGU', 'ERAKOND', 'AMETNIK', 'TALITUS'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Kasutajagrupp>> findUserGroupsUsingGETAsync(Boolean hideInactive, String lang, String name, String typeCode, final ServiceCallback<List<Kasutajagrupp>> serviceCallback) {
        return ServiceFuture.fromResponse(findUserGroupsUsingGETWithServiceResponseAsync(hideInactive, lang, name, typeCode), serviceCallback);
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @param hideInactive hideInactive
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param name Nimi
     * @param typeCode Tüübi kood (klassifikaator 'kasutajagrupiTuup'). Possible values include: 'UURIMISKOMISJON', 'VANA_FRAKTSIOON', 'VANA_ERIKOMISJON', 'VANA_ALALINE_KOMISJON', 'ALALINE_KOMISJON', 'ERIKOMISJON', 'RIIGIKOGU_JUHATUS', 'ESIMEHE_BÜROO', 'OSAKOND', 'VALIMISRINGKOND', 'TOETUSRYHM', 'ASUTUSE_YKSUS', 'PARLAMENDIRYHM', 'YHENDUS', 'FRAKTSIOON', 'DELEGATSIOON', 'RIIGIKOGU_TAISKOGU', 'ERAKOND', 'AMETNIK', 'TALITUS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Kasutajagrupp&gt; object
     */
    public Observable<List<Kasutajagrupp>> findUserGroupsUsingGETAsync(Boolean hideInactive, String lang, String name, String typeCode) {
        return findUserGroupsUsingGETWithServiceResponseAsync(hideInactive, lang, name, typeCode).map(new Func1<ServiceResponse<List<Kasutajagrupp>>, List<Kasutajagrupp>>() {
            @Override
            public List<Kasutajagrupp> call(ServiceResponse<List<Kasutajagrupp>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @param hideInactive hideInactive
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param name Nimi
     * @param typeCode Tüübi kood (klassifikaator 'kasutajagrupiTuup'). Possible values include: 'UURIMISKOMISJON', 'VANA_FRAKTSIOON', 'VANA_ERIKOMISJON', 'VANA_ALALINE_KOMISJON', 'ALALINE_KOMISJON', 'ERIKOMISJON', 'RIIGIKOGU_JUHATUS', 'ESIMEHE_BÜROO', 'OSAKOND', 'VALIMISRINGKOND', 'TOETUSRYHM', 'ASUTUSE_YKSUS', 'PARLAMENDIRYHM', 'YHENDUS', 'FRAKTSIOON', 'DELEGATSIOON', 'RIIGIKOGU_TAISKOGU', 'ERAKOND', 'AMETNIK', 'TALITUS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Kasutajagrupp&gt; object
     */
    public Observable<ServiceResponse<List<Kasutajagrupp>>> findUserGroupsUsingGETWithServiceResponseAsync(Boolean hideInactive, String lang, String name, String typeCode) {
        return service.findUserGroupsUsingGET(hideInactive, lang, name, typeCode)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Kasutajagrupp>>>>() {
                @Override
                public Observable<ServiceResponse<List<Kasutajagrupp>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Kasutajagrupp>> clientResponse = findUserGroupsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Kasutajagrupp>> findUserGroupsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Kasutajagrupp>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Kasutajagrupp>>() { }.getType())
                .build(response);
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Kasutajagrupp object if successful.
     */
    public Kasutajagrupp getUserGroupUsingGET(String uuid) {
        return getUserGroupUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Kasutajagrupp> getUserGroupUsingGETAsync(String uuid, final ServiceCallback<Kasutajagrupp> serviceCallback) {
        return ServiceFuture.fromResponse(getUserGroupUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Kasutajagrupp object
     */
    public Observable<Kasutajagrupp> getUserGroupUsingGETAsync(String uuid) {
        return getUserGroupUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<Kasutajagrupp>, Kasutajagrupp>() {
            @Override
            public Kasutajagrupp call(ServiceResponse<Kasutajagrupp> response) {
                return response.body();
            }
        });
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Kasutajagrupp object
     */
    public Observable<ServiceResponse<Kasutajagrupp>> getUserGroupUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getUserGroupUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Kasutajagrupp>>>() {
                @Override
                public Observable<ServiceResponse<Kasutajagrupp>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Kasutajagrupp> clientResponse = getUserGroupUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Kasutajagrupp object if successful.
     */
    public Kasutajagrupp getUserGroupUsingGET(String uuid, String lang) {
        return getUserGroupUsingGETWithServiceResponseAsync(uuid, lang).toBlocking().single().body();
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Kasutajagrupp> getUserGroupUsingGETAsync(String uuid, String lang, final ServiceCallback<Kasutajagrupp> serviceCallback) {
        return ServiceFuture.fromResponse(getUserGroupUsingGETWithServiceResponseAsync(uuid, lang), serviceCallback);
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Kasutajagrupp object
     */
    public Observable<Kasutajagrupp> getUserGroupUsingGETAsync(String uuid, String lang) {
        return getUserGroupUsingGETWithServiceResponseAsync(uuid, lang).map(new Func1<ServiceResponse<Kasutajagrupp>, Kasutajagrupp>() {
            @Override
            public Kasutajagrupp call(ServiceResponse<Kasutajagrupp> response) {
                return response.body();
            }
        });
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Kasutajagrupp object
     */
    public Observable<ServiceResponse<Kasutajagrupp>> getUserGroupUsingGETWithServiceResponseAsync(String uuid, String lang) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getUserGroupUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Kasutajagrupp>>>() {
                @Override
                public Observable<ServiceResponse<Kasutajagrupp>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Kasutajagrupp> clientResponse = getUserGroupUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Kasutajagrupp> getUserGroupUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Kasutajagrupp, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Kasutajagrupp>() { }.getType())
                .build(response);
    }

    /**
     * Toimikute otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesToimikOtsing object if successful.
     */
    public PagedResourcesToimikOtsing findVolumesUsingGET() {
        return findVolumesUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Toimikute otsing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesToimikOtsing> findVolumesUsingGETAsync(final ServiceCallback<PagedResourcesToimikOtsing> serviceCallback) {
        return ServiceFuture.fromResponse(findVolumesUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Toimikute otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesToimikOtsing object
     */
    public Observable<PagedResourcesToimikOtsing> findVolumesUsingGETAsync() {
        return findVolumesUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesToimikOtsing>, PagedResourcesToimikOtsing>() {
            @Override
            public PagedResourcesToimikOtsing call(ServiceResponse<PagedResourcesToimikOtsing> response) {
                return response.body();
            }
        });
    }

    /**
     * Toimikute otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesToimikOtsing object
     */
    public Observable<ServiceResponse<PagedResourcesToimikOtsing>> findVolumesUsingGETWithServiceResponseAsync() {
        final LocalDate createdEndDate = null;
        final LocalDate createdStartDate = null;
        final String functionGroupUuid = null;
        final String functionUuid = null;
        final Integer membership = null;
        final Long offset = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final String reference = null;
        final String seriesUuid = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final String subseriesUuid = null;
        final String title = null;
        final Boolean unpaged = null;
        final String volumeType = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findVolumesUsingGET(createdEndDate, createdStartDate, functionGroupUuid, functionUuid, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sortConverted, sortsorted, sortunsorted, subseriesUuid, title, unpaged, volumeType)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesToimikOtsing>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesToimikOtsing>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesToimikOtsing> clientResponse = findVolumesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param functionGroupUuid Funktsioonigrupi UUID
     * @param functionUuid Funktsiooni UUID
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param volumeType Toimiku tüüp. Possible values include: 'letterVolume', 'elVolume', 'dokumenditoimik', 'unitSittingVolume', 'officialJourneyVolume', 'opinionVolume', 'plenarySittingVolume', 'infoSittingVolume', 'interpellationsVolume', 'eelnou', 'writtenQuestionVolume', 'researchVolume', 'procurementVolume', 'visitVolume'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesToimikOtsing object if successful.
     */
    public PagedResourcesToimikOtsing findVolumesUsingGET(LocalDate createdEndDate, LocalDate createdStartDate, String functionGroupUuid, String functionUuid, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged, String volumeType) {
        return findVolumesUsingGETWithServiceResponseAsync(createdEndDate, createdStartDate, functionGroupUuid, functionUuid, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sort, sortsorted, sortunsorted, subseriesUuid, title, unpaged, volumeType).toBlocking().single().body();
    }

    /**
     * Toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param functionGroupUuid Funktsioonigrupi UUID
     * @param functionUuid Funktsiooni UUID
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param volumeType Toimiku tüüp. Possible values include: 'letterVolume', 'elVolume', 'dokumenditoimik', 'unitSittingVolume', 'officialJourneyVolume', 'opinionVolume', 'plenarySittingVolume', 'infoSittingVolume', 'interpellationsVolume', 'eelnou', 'writtenQuestionVolume', 'researchVolume', 'procurementVolume', 'visitVolume'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesToimikOtsing> findVolumesUsingGETAsync(LocalDate createdEndDate, LocalDate createdStartDate, String functionGroupUuid, String functionUuid, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged, String volumeType, final ServiceCallback<PagedResourcesToimikOtsing> serviceCallback) {
        return ServiceFuture.fromResponse(findVolumesUsingGETWithServiceResponseAsync(createdEndDate, createdStartDate, functionGroupUuid, functionUuid, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sort, sortsorted, sortunsorted, subseriesUuid, title, unpaged, volumeType), serviceCallback);
    }

    /**
     * Toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param functionGroupUuid Funktsioonigrupi UUID
     * @param functionUuid Funktsiooni UUID
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param volumeType Toimiku tüüp. Possible values include: 'letterVolume', 'elVolume', 'dokumenditoimik', 'unitSittingVolume', 'officialJourneyVolume', 'opinionVolume', 'plenarySittingVolume', 'infoSittingVolume', 'interpellationsVolume', 'eelnou', 'writtenQuestionVolume', 'researchVolume', 'procurementVolume', 'visitVolume'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesToimikOtsing object
     */
    public Observable<PagedResourcesToimikOtsing> findVolumesUsingGETAsync(LocalDate createdEndDate, LocalDate createdStartDate, String functionGroupUuid, String functionUuid, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged, String volumeType) {
        return findVolumesUsingGETWithServiceResponseAsync(createdEndDate, createdStartDate, functionGroupUuid, functionUuid, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sort, sortsorted, sortunsorted, subseriesUuid, title, unpaged, volumeType).map(new Func1<ServiceResponse<PagedResourcesToimikOtsing>, PagedResourcesToimikOtsing>() {
            @Override
            public PagedResourcesToimikOtsing call(ServiceResponse<PagedResourcesToimikOtsing> response) {
                return response.body();
            }
        });
    }

    /**
     * Toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param functionGroupUuid Funktsioonigrupi UUID
     * @param functionUuid Funktsiooni UUID
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param volumeType Toimiku tüüp. Possible values include: 'letterVolume', 'elVolume', 'dokumenditoimik', 'unitSittingVolume', 'officialJourneyVolume', 'opinionVolume', 'plenarySittingVolume', 'infoSittingVolume', 'interpellationsVolume', 'eelnou', 'writtenQuestionVolume', 'researchVolume', 'procurementVolume', 'visitVolume'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesToimikOtsing object
     */
    public Observable<ServiceResponse<PagedResourcesToimikOtsing>> findVolumesUsingGETWithServiceResponseAsync(LocalDate createdEndDate, LocalDate createdStartDate, String functionGroupUuid, String functionUuid, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged, String volumeType) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findVolumesUsingGET(createdEndDate, createdStartDate, functionGroupUuid, functionUuid, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sortConverted, sortsorted, sortunsorted, subseriesUuid, title, unpaged, volumeType)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesToimikOtsing>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesToimikOtsing>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesToimikOtsing> clientResponse = findVolumesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesToimikOtsing> findVolumesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesToimikOtsing, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesToimikOtsing>() { }.getType())
                .build(response);
    }

    /**
     * Eelnõude otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesEelnUOtsing object if successful.
     */
    public PagedResourcesEelnUOtsing findDraftVolumesUsingGET() {
        return findDraftVolumesUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Eelnõude otsing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesEelnUOtsing> findDraftVolumesUsingGETAsync(final ServiceCallback<PagedResourcesEelnUOtsing> serviceCallback) {
        return ServiceFuture.fromResponse(findDraftVolumesUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Eelnõude otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesEelnUOtsing object
     */
    public Observable<PagedResourcesEelnUOtsing> findDraftVolumesUsingGETAsync() {
        return findDraftVolumesUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesEelnUOtsing>, PagedResourcesEelnUOtsing>() {
            @Override
            public PagedResourcesEelnUOtsing call(ServiceResponse<PagedResourcesEelnUOtsing> response) {
                return response.body();
            }
        });
    }

    /**
     * Eelnõude otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesEelnUOtsing object
     */
    public Observable<ServiceResponse<PagedResourcesEelnUOtsing>> findDraftVolumesUsingGETWithServiceResponseAsync() {
        final String activeDraftStage = null;
        final LocalDate amendmentsDeadlineEndDate = null;
        final LocalDate amendmentsDeadlineStartDate = null;
        final Integer descriptorId = null;
        final String draftTypeCode = null;
        final LocalDate initiatedEndDate = null;
        final LocalDate initiatedStartDate = null;
        final String initiatorUuid = null;
        final String lang = null;
        final String leadingCommitteeUuid = null;
        final Integer mark = null;
        final Integer membership = null;
        final Long offset = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final String proceedingStatus = null;
        final String reference = null;
        final String responsibleMemberUuid = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final String title = null;
        final Boolean unpaged = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findDraftVolumesUsingGET(activeDraftStage, amendmentsDeadlineEndDate, amendmentsDeadlineStartDate, descriptorId, draftTypeCode, initiatedEndDate, initiatedStartDate, initiatorUuid, lang, leadingCommitteeUuid, mark, membership, offset, page, pageNumber, pageSize, paged, proceedingStatus, reference, responsibleMemberUuid, size, sortConverted, sortsorted, sortunsorted, title, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesEelnUOtsing>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesEelnUOtsing>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesEelnUOtsing> clientResponse = findDraftVolumesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Eelnõude otsing.
     *
     * @param activeDraftStage Aktiivne menetlusetapp
     * @param amendmentsDeadlineEndDate Muudatuseteepanekute tähtaja vahemiku lõpp (yyyy-MM-dd)
     * @param amendmentsDeadlineStartDate Muudatuseteepanekute tähtaja vahemiku algus (yyyy-MM-dd)
     * @param descriptorId Märksõna ID
     * @param draftTypeCode Eelnõu liik (klassifikaator 'eelnouLiik'). Possible values include: 'UA', 'DE', 'PE', 'AE', 'TK', 'SE', 'OE'
     * @param initiatedEndDate Algatamise kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param initiatedStartDate Algatamise kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param initiatorUuid Algataja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param leadingCommitteeUuid Juhtivkomisjoni UUID
     * @param mark Registreerimise number
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param proceedingStatus Menetluse staatus. Possible values include: 'IN_PROCESS', 'PROCESSED'
     * @param reference Viit
     * @param responsibleMemberUuid Juhtivkomisjoni esindaja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesEelnUOtsing object if successful.
     */
    public PagedResourcesEelnUOtsing findDraftVolumesUsingGET(String activeDraftStage, LocalDate amendmentsDeadlineEndDate, LocalDate amendmentsDeadlineStartDate, Integer descriptorId, String draftTypeCode, LocalDate initiatedEndDate, LocalDate initiatedStartDate, String initiatorUuid, String lang, String leadingCommitteeUuid, Integer mark, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String proceedingStatus, String reference, String responsibleMemberUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, Boolean unpaged) {
        return findDraftVolumesUsingGETWithServiceResponseAsync(activeDraftStage, amendmentsDeadlineEndDate, amendmentsDeadlineStartDate, descriptorId, draftTypeCode, initiatedEndDate, initiatedStartDate, initiatorUuid, lang, leadingCommitteeUuid, mark, membership, offset, page, pageNumber, pageSize, paged, proceedingStatus, reference, responsibleMemberUuid, size, sort, sortsorted, sortunsorted, title, unpaged).toBlocking().single().body();
    }

    /**
     * Eelnõude otsing.
     *
     * @param activeDraftStage Aktiivne menetlusetapp
     * @param amendmentsDeadlineEndDate Muudatuseteepanekute tähtaja vahemiku lõpp (yyyy-MM-dd)
     * @param amendmentsDeadlineStartDate Muudatuseteepanekute tähtaja vahemiku algus (yyyy-MM-dd)
     * @param descriptorId Märksõna ID
     * @param draftTypeCode Eelnõu liik (klassifikaator 'eelnouLiik'). Possible values include: 'UA', 'DE', 'PE', 'AE', 'TK', 'SE', 'OE'
     * @param initiatedEndDate Algatamise kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param initiatedStartDate Algatamise kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param initiatorUuid Algataja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param leadingCommitteeUuid Juhtivkomisjoni UUID
     * @param mark Registreerimise number
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param proceedingStatus Menetluse staatus. Possible values include: 'IN_PROCESS', 'PROCESSED'
     * @param reference Viit
     * @param responsibleMemberUuid Juhtivkomisjoni esindaja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesEelnUOtsing> findDraftVolumesUsingGETAsync(String activeDraftStage, LocalDate amendmentsDeadlineEndDate, LocalDate amendmentsDeadlineStartDate, Integer descriptorId, String draftTypeCode, LocalDate initiatedEndDate, LocalDate initiatedStartDate, String initiatorUuid, String lang, String leadingCommitteeUuid, Integer mark, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String proceedingStatus, String reference, String responsibleMemberUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, Boolean unpaged, final ServiceCallback<PagedResourcesEelnUOtsing> serviceCallback) {
        return ServiceFuture.fromResponse(findDraftVolumesUsingGETWithServiceResponseAsync(activeDraftStage, amendmentsDeadlineEndDate, amendmentsDeadlineStartDate, descriptorId, draftTypeCode, initiatedEndDate, initiatedStartDate, initiatorUuid, lang, leadingCommitteeUuid, mark, membership, offset, page, pageNumber, pageSize, paged, proceedingStatus, reference, responsibleMemberUuid, size, sort, sortsorted, sortunsorted, title, unpaged), serviceCallback);
    }

    /**
     * Eelnõude otsing.
     *
     * @param activeDraftStage Aktiivne menetlusetapp
     * @param amendmentsDeadlineEndDate Muudatuseteepanekute tähtaja vahemiku lõpp (yyyy-MM-dd)
     * @param amendmentsDeadlineStartDate Muudatuseteepanekute tähtaja vahemiku algus (yyyy-MM-dd)
     * @param descriptorId Märksõna ID
     * @param draftTypeCode Eelnõu liik (klassifikaator 'eelnouLiik'). Possible values include: 'UA', 'DE', 'PE', 'AE', 'TK', 'SE', 'OE'
     * @param initiatedEndDate Algatamise kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param initiatedStartDate Algatamise kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param initiatorUuid Algataja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param leadingCommitteeUuid Juhtivkomisjoni UUID
     * @param mark Registreerimise number
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param proceedingStatus Menetluse staatus. Possible values include: 'IN_PROCESS', 'PROCESSED'
     * @param reference Viit
     * @param responsibleMemberUuid Juhtivkomisjoni esindaja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesEelnUOtsing object
     */
    public Observable<PagedResourcesEelnUOtsing> findDraftVolumesUsingGETAsync(String activeDraftStage, LocalDate amendmentsDeadlineEndDate, LocalDate amendmentsDeadlineStartDate, Integer descriptorId, String draftTypeCode, LocalDate initiatedEndDate, LocalDate initiatedStartDate, String initiatorUuid, String lang, String leadingCommitteeUuid, Integer mark, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String proceedingStatus, String reference, String responsibleMemberUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, Boolean unpaged) {
        return findDraftVolumesUsingGETWithServiceResponseAsync(activeDraftStage, amendmentsDeadlineEndDate, amendmentsDeadlineStartDate, descriptorId, draftTypeCode, initiatedEndDate, initiatedStartDate, initiatorUuid, lang, leadingCommitteeUuid, mark, membership, offset, page, pageNumber, pageSize, paged, proceedingStatus, reference, responsibleMemberUuid, size, sort, sortsorted, sortunsorted, title, unpaged).map(new Func1<ServiceResponse<PagedResourcesEelnUOtsing>, PagedResourcesEelnUOtsing>() {
            @Override
            public PagedResourcesEelnUOtsing call(ServiceResponse<PagedResourcesEelnUOtsing> response) {
                return response.body();
            }
        });
    }

    /**
     * Eelnõude otsing.
     *
     * @param activeDraftStage Aktiivne menetlusetapp
     * @param amendmentsDeadlineEndDate Muudatuseteepanekute tähtaja vahemiku lõpp (yyyy-MM-dd)
     * @param amendmentsDeadlineStartDate Muudatuseteepanekute tähtaja vahemiku algus (yyyy-MM-dd)
     * @param descriptorId Märksõna ID
     * @param draftTypeCode Eelnõu liik (klassifikaator 'eelnouLiik'). Possible values include: 'UA', 'DE', 'PE', 'AE', 'TK', 'SE', 'OE'
     * @param initiatedEndDate Algatamise kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param initiatedStartDate Algatamise kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param initiatorUuid Algataja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param leadingCommitteeUuid Juhtivkomisjoni UUID
     * @param mark Registreerimise number
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param proceedingStatus Menetluse staatus. Possible values include: 'IN_PROCESS', 'PROCESSED'
     * @param reference Viit
     * @param responsibleMemberUuid Juhtivkomisjoni esindaja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesEelnUOtsing object
     */
    public Observable<ServiceResponse<PagedResourcesEelnUOtsing>> findDraftVolumesUsingGETWithServiceResponseAsync(String activeDraftStage, LocalDate amendmentsDeadlineEndDate, LocalDate amendmentsDeadlineStartDate, Integer descriptorId, String draftTypeCode, LocalDate initiatedEndDate, LocalDate initiatedStartDate, String initiatorUuid, String lang, String leadingCommitteeUuid, Integer mark, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String proceedingStatus, String reference, String responsibleMemberUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, Boolean unpaged) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findDraftVolumesUsingGET(activeDraftStage, amendmentsDeadlineEndDate, amendmentsDeadlineStartDate, descriptorId, draftTypeCode, initiatedEndDate, initiatedStartDate, initiatorUuid, lang, leadingCommitteeUuid, mark, membership, offset, page, pageNumber, pageSize, paged, proceedingStatus, reference, responsibleMemberUuid, size, sortConverted, sortsorted, sortunsorted, title, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesEelnUOtsing>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesEelnUOtsing>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesEelnUOtsing> clientResponse = findDraftVolumesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesEelnUOtsing> findDraftVolumesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesEelnUOtsing, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesEelnUOtsing>() { }.getType())
                .build(response);
    }

    /**
     * test.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void testUsingGET() {
        testUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * test.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> testUsingGETAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(testUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * test.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> testUsingGETAsync() {
        return testUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * test.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> testUsingGETWithServiceResponseAsync() {
        final Long offset = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final Boolean unpaged = null;
        return service.testUsingGET(offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = testUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * test.
     *
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void testUsingGET(Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        testUsingGETWithServiceResponseAsync(offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, unpaged).toBlocking().single().body();
    }

    /**
     * test.
     *
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> testUsingGETAsync(Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(testUsingGETWithServiceResponseAsync(offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, unpaged), serviceCallback);
    }

    /**
     * test.
     *
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> testUsingGETAsync(Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        return testUsingGETWithServiceResponseAsync(offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, unpaged).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * test.
     *
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> testUsingGETWithServiceResponseAsync(Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        return service.testUsingGET(offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = testUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> testUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EelnUToimikBaas object if successful.
     */
    public EelnUToimikBaas getDraftVolumeUsingGET(String uuid) {
        return getDraftVolumeUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EelnUToimikBaas> getDraftVolumeUsingGETAsync(String uuid, final ServiceCallback<EelnUToimikBaas> serviceCallback) {
        return ServiceFuture.fromResponse(getDraftVolumeUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EelnUToimikBaas object
     */
    public Observable<EelnUToimikBaas> getDraftVolumeUsingGETAsync(String uuid) {
        return getDraftVolumeUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<EelnUToimikBaas>, EelnUToimikBaas>() {
            @Override
            public EelnUToimikBaas call(ServiceResponse<EelnUToimikBaas> response) {
                return response.body();
            }
        });
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EelnUToimikBaas object
     */
    public Observable<ServiceResponse<EelnUToimikBaas>> getDraftVolumeUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        final Boolean querySteno = null;
        return service.getDraftVolumeUsingGET(uuid, lang, querySteno)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EelnUToimikBaas>>>() {
                @Override
                public Observable<ServiceResponse<EelnUToimikBaas>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EelnUToimikBaas> clientResponse = getDraftVolumeUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the EelnUToimikBaas object if successful.
     */
    public EelnUToimikBaas getDraftVolumeUsingGET(String uuid, String lang, Boolean querySteno) {
        return getDraftVolumeUsingGETWithServiceResponseAsync(uuid, lang, querySteno).toBlocking().single().body();
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<EelnUToimikBaas> getDraftVolumeUsingGETAsync(String uuid, String lang, Boolean querySteno, final ServiceCallback<EelnUToimikBaas> serviceCallback) {
        return ServiceFuture.fromResponse(getDraftVolumeUsingGETWithServiceResponseAsync(uuid, lang, querySteno), serviceCallback);
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EelnUToimikBaas object
     */
    public Observable<EelnUToimikBaas> getDraftVolumeUsingGETAsync(String uuid, String lang, Boolean querySteno) {
        return getDraftVolumeUsingGETWithServiceResponseAsync(uuid, lang, querySteno).map(new Func1<ServiceResponse<EelnUToimikBaas>, EelnUToimikBaas>() {
            @Override
            public EelnUToimikBaas call(ServiceResponse<EelnUToimikBaas> response) {
                return response.body();
            }
        });
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the EelnUToimikBaas object
     */
    public Observable<ServiceResponse<EelnUToimikBaas>> getDraftVolumeUsingGETWithServiceResponseAsync(String uuid, String lang, Boolean querySteno) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getDraftVolumeUsingGET(uuid, lang, querySteno)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<EelnUToimikBaas>>>() {
                @Override
                public Observable<ServiceResponse<EelnUToimikBaas>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<EelnUToimikBaas> clientResponse = getDraftVolumeUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<EelnUToimikBaas> getDraftVolumeUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<EelnUToimikBaas, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EelnUToimikBaas>() { }.getType())
                .build(response);
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ToimikERJK&gt; object if successful.
     */
    public List<ToimikERJK> findErjkProtocolsUsingGET() {
        return findErjkProtocolsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ToimikERJK>> findErjkProtocolsUsingGETAsync(final ServiceCallback<List<ToimikERJK>> serviceCallback) {
        return ServiceFuture.fromResponse(findErjkProtocolsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ToimikERJK&gt; object
     */
    public Observable<List<ToimikERJK>> findErjkProtocolsUsingGETAsync() {
        return findErjkProtocolsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<ToimikERJK>>, List<ToimikERJK>>() {
            @Override
            public List<ToimikERJK> call(ServiceResponse<List<ToimikERJK>> response) {
                return response.body();
            }
        });
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ToimikERJK&gt; object
     */
    public Observable<ServiceResponse<List<ToimikERJK>>> findErjkProtocolsUsingGETWithServiceResponseAsync() {
        final List<String> sort = null;
        final Boolean sorted = null;
        final Boolean unsorted = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findErjkProtocolsUsingGET(sortConverted, sorted, unsorted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ToimikERJK>>>>() {
                @Override
                public Observable<ServiceResponse<List<ToimikERJK>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ToimikERJK>> clientResponse = findErjkProtocolsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sorted the Boolean value
     * @param unsorted the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ToimikERJK&gt; object if successful.
     */
    public List<ToimikERJK> findErjkProtocolsUsingGET(List<String> sort, Boolean sorted, Boolean unsorted) {
        return findErjkProtocolsUsingGETWithServiceResponseAsync(sort, sorted, unsorted).toBlocking().single().body();
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sorted the Boolean value
     * @param unsorted the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ToimikERJK>> findErjkProtocolsUsingGETAsync(List<String> sort, Boolean sorted, Boolean unsorted, final ServiceCallback<List<ToimikERJK>> serviceCallback) {
        return ServiceFuture.fromResponse(findErjkProtocolsUsingGETWithServiceResponseAsync(sort, sorted, unsorted), serviceCallback);
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sorted the Boolean value
     * @param unsorted the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ToimikERJK&gt; object
     */
    public Observable<List<ToimikERJK>> findErjkProtocolsUsingGETAsync(List<String> sort, Boolean sorted, Boolean unsorted) {
        return findErjkProtocolsUsingGETWithServiceResponseAsync(sort, sorted, unsorted).map(new Func1<ServiceResponse<List<ToimikERJK>>, List<ToimikERJK>>() {
            @Override
            public List<ToimikERJK> call(ServiceResponse<List<ToimikERJK>> response) {
                return response.body();
            }
        });
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sorted the Boolean value
     * @param unsorted the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ToimikERJK&gt; object
     */
    public Observable<ServiceResponse<List<ToimikERJK>>> findErjkProtocolsUsingGETWithServiceResponseAsync(List<String> sort, Boolean sorted, Boolean unsorted) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findErjkProtocolsUsingGET(sortConverted, sorted, unsorted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ToimikERJK>>>>() {
                @Override
                public Observable<ServiceResponse<List<ToimikERJK>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ToimikERJK>> clientResponse = findErjkProtocolsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ToimikERJK>> findErjkProtocolsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<ToimikERJK>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ToimikERJK>>() { }.getType())
                .build(response);
    }

    /**
     * ERJK protokoll.
     *
     * @param uuid Toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ToimikERJK object if successful.
     */
    public ToimikERJK findErjkProtocolUsingGET(String uuid) {
        return findErjkProtocolUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * ERJK protokoll.
     *
     * @param uuid Toimiku UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ToimikERJK> findErjkProtocolUsingGETAsync(String uuid, final ServiceCallback<ToimikERJK> serviceCallback) {
        return ServiceFuture.fromResponse(findErjkProtocolUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * ERJK protokoll.
     *
     * @param uuid Toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ToimikERJK object
     */
    public Observable<ToimikERJK> findErjkProtocolUsingGETAsync(String uuid) {
        return findErjkProtocolUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<ToimikERJK>, ToimikERJK>() {
            @Override
            public ToimikERJK call(ServiceResponse<ToimikERJK> response) {
                return response.body();
            }
        });
    }

    /**
     * ERJK protokoll.
     *
     * @param uuid Toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ToimikERJK object
     */
    public Observable<ServiceResponse<ToimikERJK>> findErjkProtocolUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.findErjkProtocolUsingGET(uuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ToimikERJK>>>() {
                @Override
                public Observable<ServiceResponse<ToimikERJK>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ToimikERJK> clientResponse = findErjkProtocolUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ToimikERJK> findErjkProtocolUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ToimikERJK, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ToimikERJK>() { }.getType())
                .build(response);
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesELToimikOtsing object if successful.
     */
    public PagedResourcesELToimikOtsing findEuropeanUnionDocumentsUsingGET() {
        return findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesELToimikOtsing> findEuropeanUnionDocumentsUsingGETAsync(final ServiceCallback<PagedResourcesELToimikOtsing> serviceCallback) {
        return ServiceFuture.fromResponse(findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesELToimikOtsing object
     */
    public Observable<PagedResourcesELToimikOtsing> findEuropeanUnionDocumentsUsingGETAsync() {
        return findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesELToimikOtsing>, PagedResourcesELToimikOtsing>() {
            @Override
            public PagedResourcesELToimikOtsing call(ServiceResponse<PagedResourcesELToimikOtsing> response) {
                return response.body();
            }
        });
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesELToimikOtsing object
     */
    public Observable<ServiceResponse<PagedResourcesELToimikOtsing>> findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync() {
        final LocalDate createdEndDate = null;
        final LocalDate createdStartDate = null;
        final String documentType = null;
        final String elMark = null;
        final String elTypeCode = null;
        final String lang = null;
        final Integer membership = null;
        final Long offset = null;
        final String opinionCommitteeUuid = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final LocalDate receiveDateEnd = null;
        final LocalDate receiveDateStart = null;
        final String reference = null;
        final String responsibleCommitteeUuid = null;
        final String sectorCode = null;
        final String sectorCommitteeUuid = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final String title = null;
        final String titleEn = null;
        final Boolean unpaged = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findEuropeanUnionDocumentsUsingGET(createdEndDate, createdStartDate, documentType, elMark, elTypeCode, lang, membership, offset, opinionCommitteeUuid, page, pageNumber, pageSize, paged, receiveDateEnd, receiveDateStart, reference, responsibleCommitteeUuid, sectorCode, sectorCommitteeUuid, size, sortConverted, sortsorted, sortunsorted, title, titleEn, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesELToimikOtsing>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesELToimikOtsing>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesELToimikOtsing> clientResponse = findEuropeanUnionDocumentsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param documentType Dokumendi liik (sh EL dokumendi liigid)
     * @param elMark EL toimiku tähis
     * @param elTypeCode EL toimiku liik (klassifikaator 'elToimikuliik'). Possible values include: 'MUU_EL_DOKUMENT', 'EL_ALGATUS', 'NOUKOGU_JA_ULEMKOGU_DOKUMENT'
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param opinionCommitteeUuid Arvamuse andja komisjoni UUID
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param receiveDateEnd Saabumise kuupäeva lõpp (yyyy-MM-dd)
     * @param receiveDateStart Saabumise kuupäeva algus (yyyy-MM-dd)
     * @param reference Viit
     * @param responsibleCommitteeUuid Vastutava komisjoni UUID
     * @param sectorCode Valdkond (klassifikaator 'elValdkond'). Possible values include: 'KESKKOND', 'HARIDUS_KULTUUR_NOORED', 'TOOHOIVE_SOTSIAAL_TERVISHOID_TARBIJAKAITSE', 'POLLUMAJANDUS_KALANDUS', 'TRANSPORT_TELE_ENERGEETIKA', 'JUSTIITS_SISEKUSIMUSED', 'MAJANDUS_RAHANDUS', 'KONKURENTSIVOIME', 'ULDASJAD', 'VALISASJAD'
     * @param sectorCommitteeUuid Valdkonna komisjoni UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param titleEn Pealkiri inglise keeles
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesELToimikOtsing object if successful.
     */
    public PagedResourcesELToimikOtsing findEuropeanUnionDocumentsUsingGET(LocalDate createdEndDate, LocalDate createdStartDate, String documentType, String elMark, String elTypeCode, String lang, Integer membership, Long offset, String opinionCommitteeUuid, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, LocalDate receiveDateEnd, LocalDate receiveDateStart, String reference, String responsibleCommitteeUuid, String sectorCode, String sectorCommitteeUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, String titleEn, Boolean unpaged) {
        return findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync(createdEndDate, createdStartDate, documentType, elMark, elTypeCode, lang, membership, offset, opinionCommitteeUuid, page, pageNumber, pageSize, paged, receiveDateEnd, receiveDateStart, reference, responsibleCommitteeUuid, sectorCode, sectorCommitteeUuid, size, sort, sortsorted, sortunsorted, title, titleEn, unpaged).toBlocking().single().body();
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param documentType Dokumendi liik (sh EL dokumendi liigid)
     * @param elMark EL toimiku tähis
     * @param elTypeCode EL toimiku liik (klassifikaator 'elToimikuliik'). Possible values include: 'MUU_EL_DOKUMENT', 'EL_ALGATUS', 'NOUKOGU_JA_ULEMKOGU_DOKUMENT'
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param opinionCommitteeUuid Arvamuse andja komisjoni UUID
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param receiveDateEnd Saabumise kuupäeva lõpp (yyyy-MM-dd)
     * @param receiveDateStart Saabumise kuupäeva algus (yyyy-MM-dd)
     * @param reference Viit
     * @param responsibleCommitteeUuid Vastutava komisjoni UUID
     * @param sectorCode Valdkond (klassifikaator 'elValdkond'). Possible values include: 'KESKKOND', 'HARIDUS_KULTUUR_NOORED', 'TOOHOIVE_SOTSIAAL_TERVISHOID_TARBIJAKAITSE', 'POLLUMAJANDUS_KALANDUS', 'TRANSPORT_TELE_ENERGEETIKA', 'JUSTIITS_SISEKUSIMUSED', 'MAJANDUS_RAHANDUS', 'KONKURENTSIVOIME', 'ULDASJAD', 'VALISASJAD'
     * @param sectorCommitteeUuid Valdkonna komisjoni UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param titleEn Pealkiri inglise keeles
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesELToimikOtsing> findEuropeanUnionDocumentsUsingGETAsync(LocalDate createdEndDate, LocalDate createdStartDate, String documentType, String elMark, String elTypeCode, String lang, Integer membership, Long offset, String opinionCommitteeUuid, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, LocalDate receiveDateEnd, LocalDate receiveDateStart, String reference, String responsibleCommitteeUuid, String sectorCode, String sectorCommitteeUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, String titleEn, Boolean unpaged, final ServiceCallback<PagedResourcesELToimikOtsing> serviceCallback) {
        return ServiceFuture.fromResponse(findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync(createdEndDate, createdStartDate, documentType, elMark, elTypeCode, lang, membership, offset, opinionCommitteeUuid, page, pageNumber, pageSize, paged, receiveDateEnd, receiveDateStart, reference, responsibleCommitteeUuid, sectorCode, sectorCommitteeUuid, size, sort, sortsorted, sortunsorted, title, titleEn, unpaged), serviceCallback);
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param documentType Dokumendi liik (sh EL dokumendi liigid)
     * @param elMark EL toimiku tähis
     * @param elTypeCode EL toimiku liik (klassifikaator 'elToimikuliik'). Possible values include: 'MUU_EL_DOKUMENT', 'EL_ALGATUS', 'NOUKOGU_JA_ULEMKOGU_DOKUMENT'
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param opinionCommitteeUuid Arvamuse andja komisjoni UUID
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param receiveDateEnd Saabumise kuupäeva lõpp (yyyy-MM-dd)
     * @param receiveDateStart Saabumise kuupäeva algus (yyyy-MM-dd)
     * @param reference Viit
     * @param responsibleCommitteeUuid Vastutava komisjoni UUID
     * @param sectorCode Valdkond (klassifikaator 'elValdkond'). Possible values include: 'KESKKOND', 'HARIDUS_KULTUUR_NOORED', 'TOOHOIVE_SOTSIAAL_TERVISHOID_TARBIJAKAITSE', 'POLLUMAJANDUS_KALANDUS', 'TRANSPORT_TELE_ENERGEETIKA', 'JUSTIITS_SISEKUSIMUSED', 'MAJANDUS_RAHANDUS', 'KONKURENTSIVOIME', 'ULDASJAD', 'VALISASJAD'
     * @param sectorCommitteeUuid Valdkonna komisjoni UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param titleEn Pealkiri inglise keeles
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesELToimikOtsing object
     */
    public Observable<PagedResourcesELToimikOtsing> findEuropeanUnionDocumentsUsingGETAsync(LocalDate createdEndDate, LocalDate createdStartDate, String documentType, String elMark, String elTypeCode, String lang, Integer membership, Long offset, String opinionCommitteeUuid, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, LocalDate receiveDateEnd, LocalDate receiveDateStart, String reference, String responsibleCommitteeUuid, String sectorCode, String sectorCommitteeUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, String titleEn, Boolean unpaged) {
        return findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync(createdEndDate, createdStartDate, documentType, elMark, elTypeCode, lang, membership, offset, opinionCommitteeUuid, page, pageNumber, pageSize, paged, receiveDateEnd, receiveDateStart, reference, responsibleCommitteeUuid, sectorCode, sectorCommitteeUuid, size, sort, sortsorted, sortunsorted, title, titleEn, unpaged).map(new Func1<ServiceResponse<PagedResourcesELToimikOtsing>, PagedResourcesELToimikOtsing>() {
            @Override
            public PagedResourcesELToimikOtsing call(ServiceResponse<PagedResourcesELToimikOtsing> response) {
                return response.body();
            }
        });
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param documentType Dokumendi liik (sh EL dokumendi liigid)
     * @param elMark EL toimiku tähis
     * @param elTypeCode EL toimiku liik (klassifikaator 'elToimikuliik'). Possible values include: 'MUU_EL_DOKUMENT', 'EL_ALGATUS', 'NOUKOGU_JA_ULEMKOGU_DOKUMENT'
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param opinionCommitteeUuid Arvamuse andja komisjoni UUID
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param receiveDateEnd Saabumise kuupäeva lõpp (yyyy-MM-dd)
     * @param receiveDateStart Saabumise kuupäeva algus (yyyy-MM-dd)
     * @param reference Viit
     * @param responsibleCommitteeUuid Vastutava komisjoni UUID
     * @param sectorCode Valdkond (klassifikaator 'elValdkond'). Possible values include: 'KESKKOND', 'HARIDUS_KULTUUR_NOORED', 'TOOHOIVE_SOTSIAAL_TERVISHOID_TARBIJAKAITSE', 'POLLUMAJANDUS_KALANDUS', 'TRANSPORT_TELE_ENERGEETIKA', 'JUSTIITS_SISEKUSIMUSED', 'MAJANDUS_RAHANDUS', 'KONKURENTSIVOIME', 'ULDASJAD', 'VALISASJAD'
     * @param sectorCommitteeUuid Valdkonna komisjoni UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param titleEn Pealkiri inglise keeles
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesELToimikOtsing object
     */
    public Observable<ServiceResponse<PagedResourcesELToimikOtsing>> findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync(LocalDate createdEndDate, LocalDate createdStartDate, String documentType, String elMark, String elTypeCode, String lang, Integer membership, Long offset, String opinionCommitteeUuid, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, LocalDate receiveDateEnd, LocalDate receiveDateStart, String reference, String responsibleCommitteeUuid, String sectorCode, String sectorCommitteeUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, String titleEn, Boolean unpaged) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findEuropeanUnionDocumentsUsingGET(createdEndDate, createdStartDate, documentType, elMark, elTypeCode, lang, membership, offset, opinionCommitteeUuid, page, pageNumber, pageSize, paged, receiveDateEnd, receiveDateStart, reference, responsibleCommitteeUuid, sectorCode, sectorCommitteeUuid, size, sortConverted, sortsorted, sortunsorted, title, titleEn, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesELToimikOtsing>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesELToimikOtsing>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesELToimikOtsing> clientResponse = findEuropeanUnionDocumentsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesELToimikOtsing> findEuropeanUnionDocumentsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesELToimikOtsing, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesELToimikOtsing>() { }.getType())
                .build(response);
    }

    /**
     * Arupärimised.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesToimikArupRimine object if successful.
     */
    public PagedResourcesToimikArupRimine findInterpellationsUsingGET() {
        return findInterpellationsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Arupärimised.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesToimikArupRimine> findInterpellationsUsingGETAsync(final ServiceCallback<PagedResourcesToimikArupRimine> serviceCallback) {
        return ServiceFuture.fromResponse(findInterpellationsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Arupärimised.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesToimikArupRimine object
     */
    public Observable<PagedResourcesToimikArupRimine> findInterpellationsUsingGETAsync() {
        return findInterpellationsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesToimikArupRimine>, PagedResourcesToimikArupRimine>() {
            @Override
            public PagedResourcesToimikArupRimine call(ServiceResponse<PagedResourcesToimikArupRimine> response) {
                return response.body();
            }
        });
    }

    /**
     * Arupärimised.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesToimikArupRimine object
     */
    public Observable<ServiceResponse<PagedResourcesToimikArupRimine>> findInterpellationsUsingGETWithServiceResponseAsync() {
        final String enquirerUuid = null;
        final String lang = null;
        final Integer membership = null;
        final Long offset = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final Boolean unpaged = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findInterpellationsUsingGET(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sortConverted, sortsorted, sortunsorted, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesToimikArupRimine>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesToimikArupRimine>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesToimikArupRimine> clientResponse = findInterpellationsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Arupärimised.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesToimikArupRimine object if successful.
     */
    public PagedResourcesToimikArupRimine findInterpellationsUsingGET(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        return findInterpellationsUsingGETWithServiceResponseAsync(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sort, sortsorted, sortunsorted, unpaged).toBlocking().single().body();
    }

    /**
     * Arupärimised.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesToimikArupRimine> findInterpellationsUsingGETAsync(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged, final ServiceCallback<PagedResourcesToimikArupRimine> serviceCallback) {
        return ServiceFuture.fromResponse(findInterpellationsUsingGETWithServiceResponseAsync(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sort, sortsorted, sortunsorted, unpaged), serviceCallback);
    }

    /**
     * Arupärimised.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesToimikArupRimine object
     */
    public Observable<PagedResourcesToimikArupRimine> findInterpellationsUsingGETAsync(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        return findInterpellationsUsingGETWithServiceResponseAsync(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sort, sortsorted, sortunsorted, unpaged).map(new Func1<ServiceResponse<PagedResourcesToimikArupRimine>, PagedResourcesToimikArupRimine>() {
            @Override
            public PagedResourcesToimikArupRimine call(ServiceResponse<PagedResourcesToimikArupRimine> response) {
                return response.body();
            }
        });
    }

    /**
     * Arupärimised.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesToimikArupRimine object
     */
    public Observable<ServiceResponse<PagedResourcesToimikArupRimine>> findInterpellationsUsingGETWithServiceResponseAsync(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findInterpellationsUsingGET(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sortConverted, sortsorted, sortunsorted, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesToimikArupRimine>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesToimikArupRimine>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesToimikArupRimine> clientResponse = findInterpellationsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesToimikArupRimine> findInterpellationsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesToimikArupRimine, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesToimikArupRimine>() { }.getType())
                .build(response);
    }

    /**
     * Kirjalikud küsimused.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesToimikKirjalikKSimus object if successful.
     */
    public PagedResourcesToimikKirjalikKSimus findWrittenQuestionsUsingGET() {
        return findWrittenQuestionsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Kirjalikud küsimused.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesToimikKirjalikKSimus> findWrittenQuestionsUsingGETAsync(final ServiceCallback<PagedResourcesToimikKirjalikKSimus> serviceCallback) {
        return ServiceFuture.fromResponse(findWrittenQuestionsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Kirjalikud küsimused.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesToimikKirjalikKSimus object
     */
    public Observable<PagedResourcesToimikKirjalikKSimus> findWrittenQuestionsUsingGETAsync() {
        return findWrittenQuestionsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesToimikKirjalikKSimus>, PagedResourcesToimikKirjalikKSimus>() {
            @Override
            public PagedResourcesToimikKirjalikKSimus call(ServiceResponse<PagedResourcesToimikKirjalikKSimus> response) {
                return response.body();
            }
        });
    }

    /**
     * Kirjalikud küsimused.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesToimikKirjalikKSimus object
     */
    public Observable<ServiceResponse<PagedResourcesToimikKirjalikKSimus>> findWrittenQuestionsUsingGETWithServiceResponseAsync() {
        final String enquirerUuid = null;
        final String lang = null;
        final Integer membership = null;
        final Long offset = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final Boolean unpaged = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findWrittenQuestionsUsingGET(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sortConverted, sortsorted, sortunsorted, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesToimikKirjalikKSimus>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesToimikKirjalikKSimus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesToimikKirjalikKSimus> clientResponse = findWrittenQuestionsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Kirjalikud küsimused.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesToimikKirjalikKSimus object if successful.
     */
    public PagedResourcesToimikKirjalikKSimus findWrittenQuestionsUsingGET(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        return findWrittenQuestionsUsingGETWithServiceResponseAsync(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sort, sortsorted, sortunsorted, unpaged).toBlocking().single().body();
    }

    /**
     * Kirjalikud küsimused.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesToimikKirjalikKSimus> findWrittenQuestionsUsingGETAsync(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged, final ServiceCallback<PagedResourcesToimikKirjalikKSimus> serviceCallback) {
        return ServiceFuture.fromResponse(findWrittenQuestionsUsingGETWithServiceResponseAsync(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sort, sortsorted, sortunsorted, unpaged), serviceCallback);
    }

    /**
     * Kirjalikud küsimused.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesToimikKirjalikKSimus object
     */
    public Observable<PagedResourcesToimikKirjalikKSimus> findWrittenQuestionsUsingGETAsync(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        return findWrittenQuestionsUsingGETWithServiceResponseAsync(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sort, sortsorted, sortunsorted, unpaged).map(new Func1<ServiceResponse<PagedResourcesToimikKirjalikKSimus>, PagedResourcesToimikKirjalikKSimus>() {
            @Override
            public PagedResourcesToimikKirjalikKSimus call(ServiceResponse<PagedResourcesToimikKirjalikKSimus> response) {
                return response.body();
            }
        });
    }

    /**
     * Kirjalikud küsimused.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesToimikKirjalikKSimus object
     */
    public Observable<ServiceResponse<PagedResourcesToimikKirjalikKSimus>> findWrittenQuestionsUsingGETWithServiceResponseAsync(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findWrittenQuestionsUsingGET(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sortConverted, sortsorted, sortunsorted, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesToimikKirjalikKSimus>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesToimikKirjalikKSimus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesToimikKirjalikKSimus> clientResponse = findWrittenQuestionsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesToimikKirjalikKSimus> findWrittenQuestionsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesToimikKirjalikKSimus, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesToimikKirjalikKSimus>() { }.getType())
                .build(response);
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Toimik object if successful.
     */
    public Toimik getVolumeUsingGET(String uuid) {
        return getVolumeUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Toimik> getVolumeUsingGETAsync(String uuid, final ServiceCallback<Toimik> serviceCallback) {
        return ServiceFuture.fromResponse(getVolumeUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Toimik object
     */
    public Observable<Toimik> getVolumeUsingGETAsync(String uuid) {
        return getVolumeUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<Toimik>, Toimik>() {
            @Override
            public Toimik call(ServiceResponse<Toimik> response) {
                return response.body();
            }
        });
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Toimik object
     */
    public Observable<ServiceResponse<Toimik>> getVolumeUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getVolumeUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Toimik>>>() {
                @Override
                public Observable<ServiceResponse<Toimik>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Toimik> clientResponse = getVolumeUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Toimik object if successful.
     */
    public Toimik getVolumeUsingGET(String uuid, String lang) {
        return getVolumeUsingGETWithServiceResponseAsync(uuid, lang).toBlocking().single().body();
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Toimik> getVolumeUsingGETAsync(String uuid, String lang, final ServiceCallback<Toimik> serviceCallback) {
        return ServiceFuture.fromResponse(getVolumeUsingGETWithServiceResponseAsync(uuid, lang), serviceCallback);
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Toimik object
     */
    public Observable<Toimik> getVolumeUsingGETAsync(String uuid, String lang) {
        return getVolumeUsingGETWithServiceResponseAsync(uuid, lang).map(new Func1<ServiceResponse<Toimik>, Toimik>() {
            @Override
            public Toimik call(ServiceResponse<Toimik> response) {
                return response.body();
            }
        });
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Toimik object
     */
    public Observable<ServiceResponse<Toimik>> getVolumeUsingGETWithServiceResponseAsync(String uuid, String lang) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getVolumeUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Toimik>>>() {
                @Override
                public Observable<ServiceResponse<Toimik>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Toimik> clientResponse = getVolumeUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Toimik> getVolumeUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Toimik, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Toimik>() { }.getType())
                .build(response);
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;TIskoguIstungHLetus&gt; object if successful.
     */
    public List<TIskoguIstungHLetus> getVotingsUsingGET(LocalDate endDate, LocalDate startDate) {
        return getVotingsUsingGETWithServiceResponseAsync(endDate, startDate).toBlocking().single().body();
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TIskoguIstungHLetus>> getVotingsUsingGETAsync(LocalDate endDate, LocalDate startDate, final ServiceCallback<List<TIskoguIstungHLetus>> serviceCallback) {
        return ServiceFuture.fromResponse(getVotingsUsingGETWithServiceResponseAsync(endDate, startDate), serviceCallback);
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;TIskoguIstungHLetus&gt; object
     */
    public Observable<List<TIskoguIstungHLetus>> getVotingsUsingGETAsync(LocalDate endDate, LocalDate startDate) {
        return getVotingsUsingGETWithServiceResponseAsync(endDate, startDate).map(new Func1<ServiceResponse<List<TIskoguIstungHLetus>>, List<TIskoguIstungHLetus>>() {
            @Override
            public List<TIskoguIstungHLetus> call(ServiceResponse<List<TIskoguIstungHLetus>> response) {
                return response.body();
            }
        });
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;TIskoguIstungHLetus&gt; object
     */
    public Observable<ServiceResponse<List<TIskoguIstungHLetus>>> getVotingsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        final String lang = null;
        return service.getVotingsUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<TIskoguIstungHLetus>>>>() {
                @Override
                public Observable<ServiceResponse<List<TIskoguIstungHLetus>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<TIskoguIstungHLetus>> clientResponse = getVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;TIskoguIstungHLetus&gt; object if successful.
     */
    public List<TIskoguIstungHLetus> getVotingsUsingGET(LocalDate endDate, LocalDate startDate, String lang) {
        return getVotingsUsingGETWithServiceResponseAsync(endDate, startDate, lang).toBlocking().single().body();
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<TIskoguIstungHLetus>> getVotingsUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang, final ServiceCallback<List<TIskoguIstungHLetus>> serviceCallback) {
        return ServiceFuture.fromResponse(getVotingsUsingGETWithServiceResponseAsync(endDate, startDate, lang), serviceCallback);
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;TIskoguIstungHLetus&gt; object
     */
    public Observable<List<TIskoguIstungHLetus>> getVotingsUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang) {
        return getVotingsUsingGETWithServiceResponseAsync(endDate, startDate, lang).map(new Func1<ServiceResponse<List<TIskoguIstungHLetus>>, List<TIskoguIstungHLetus>>() {
            @Override
            public List<TIskoguIstungHLetus> call(ServiceResponse<List<TIskoguIstungHLetus>> response) {
                return response.body();
            }
        });
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;TIskoguIstungHLetus&gt; object
     */
    public Observable<ServiceResponse<List<TIskoguIstungHLetus>>> getVotingsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        return service.getVotingsUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<TIskoguIstungHLetus>>>>() {
                @Override
                public Observable<ServiceResponse<List<TIskoguIstungHLetus>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<TIskoguIstungHLetus>> clientResponse = getVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<TIskoguIstungHLetus>> getVotingsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<TIskoguIstungHLetus>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<TIskoguIstungHLetus>>() { }.getType())
                .build(response);
    }

    /**
     * Hääletuste kalender.
     * Kuupäevad, millal vähemalt üks hääletus on toimunud.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;HLetuspEv&gt; object if successful.
     */
    public List<HLetuspEv> getVotingCalendarUsingGET(LocalDate endDate, LocalDate startDate) {
        return getVotingCalendarUsingGETWithServiceResponseAsync(endDate, startDate).toBlocking().single().body();
    }

    /**
     * Hääletuste kalender.
     * Kuupäevad, millal vähemalt üks hääletus on toimunud.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<HLetuspEv>> getVotingCalendarUsingGETAsync(LocalDate endDate, LocalDate startDate, final ServiceCallback<List<HLetuspEv>> serviceCallback) {
        return ServiceFuture.fromResponse(getVotingCalendarUsingGETWithServiceResponseAsync(endDate, startDate), serviceCallback);
    }

    /**
     * Hääletuste kalender.
     * Kuupäevad, millal vähemalt üks hääletus on toimunud.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;HLetuspEv&gt; object
     */
    public Observable<List<HLetuspEv>> getVotingCalendarUsingGETAsync(LocalDate endDate, LocalDate startDate) {
        return getVotingCalendarUsingGETWithServiceResponseAsync(endDate, startDate).map(new Func1<ServiceResponse<List<HLetuspEv>>, List<HLetuspEv>>() {
            @Override
            public List<HLetuspEv> call(ServiceResponse<List<HLetuspEv>> response) {
                return response.body();
            }
        });
    }

    /**
     * Hääletuste kalender.
     * Kuupäevad, millal vähemalt üks hääletus on toimunud.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;HLetuspEv&gt; object
     */
    public Observable<ServiceResponse<List<HLetuspEv>>> getVotingCalendarUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        return service.getVotingCalendarUsingGET(endDate, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<HLetuspEv>>>>() {
                @Override
                public Observable<ServiceResponse<List<HLetuspEv>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<HLetuspEv>> clientResponse = getVotingCalendarUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<HLetuspEv>> getVotingCalendarUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<HLetuspEv>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<HLetuspEv>>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Kasutajagrupp&gt; object if successful.
     */
    public List<Kasutajagrupp> findCommitteeMemberVotingsUsingGET(String userUuid) {
        return findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(userUuid).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Kasutajagrupp>> findCommitteeMemberVotingsUsingGETAsync(String userUuid, final ServiceCallback<List<Kasutajagrupp>> serviceCallback) {
        return ServiceFuture.fromResponse(findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(userUuid), serviceCallback);
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Kasutajagrupp&gt; object
     */
    public Observable<List<Kasutajagrupp>> findCommitteeMemberVotingsUsingGETAsync(String userUuid) {
        return findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(userUuid).map(new Func1<ServiceResponse<List<Kasutajagrupp>>, List<Kasutajagrupp>>() {
            @Override
            public List<Kasutajagrupp> call(ServiceResponse<List<Kasutajagrupp>> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Kasutajagrupp&gt; object
     */
    public Observable<ServiceResponse<List<Kasutajagrupp>>> findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(String userUuid) {
        if (userUuid == null) {
            throw new IllegalArgumentException("Parameter userUuid is required and cannot be null.");
        }
        final LocalDate endDate = null;
        final String lang = null;
        final LocalDate startDate = null;
        return service.findCommitteeMemberVotingsUsingGET(endDate, lang, startDate, userUuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Kasutajagrupp>>>>() {
                @Override
                public Observable<ServiceResponse<List<Kasutajagrupp>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Kasutajagrupp>> clientResponse = findCommitteeMemberVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Kasutajagrupp&gt; object if successful.
     */
    public List<Kasutajagrupp> findCommitteeMemberVotingsUsingGET(String userUuid, LocalDate endDate, String lang, LocalDate startDate) {
        return findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(userUuid, endDate, lang, startDate).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Kasutajagrupp>> findCommitteeMemberVotingsUsingGETAsync(String userUuid, LocalDate endDate, String lang, LocalDate startDate, final ServiceCallback<List<Kasutajagrupp>> serviceCallback) {
        return ServiceFuture.fromResponse(findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(userUuid, endDate, lang, startDate), serviceCallback);
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Kasutajagrupp&gt; object
     */
    public Observable<List<Kasutajagrupp>> findCommitteeMemberVotingsUsingGETAsync(String userUuid, LocalDate endDate, String lang, LocalDate startDate) {
        return findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(userUuid, endDate, lang, startDate).map(new Func1<ServiceResponse<List<Kasutajagrupp>>, List<Kasutajagrupp>>() {
            @Override
            public List<Kasutajagrupp> call(ServiceResponse<List<Kasutajagrupp>> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Kasutajagrupp&gt; object
     */
    public Observable<ServiceResponse<List<Kasutajagrupp>>> findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(String userUuid, LocalDate endDate, String lang, LocalDate startDate) {
        if (userUuid == null) {
            throw new IllegalArgumentException("Parameter userUuid is required and cannot be null.");
        }
        return service.findCommitteeMemberVotingsUsingGET(endDate, lang, startDate, userUuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Kasutajagrupp>>>>() {
                @Override
                public Observable<ServiceResponse<List<Kasutajagrupp>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Kasutajagrupp>> clientResponse = findCommitteeMemberVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Kasutajagrupp>> findCommitteeMemberVotingsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<Kasutajagrupp>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Kasutajagrupp>>() { }.getType())
                .build(response);
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;KomisjoniIstung&gt; object if successful.
     */
    public List<KomisjoniIstung> findCommitteeVotingsUsingGET(String uuid) {
        return findCommitteeVotingsUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<KomisjoniIstung>> findCommitteeVotingsUsingGETAsync(String uuid, final ServiceCallback<List<KomisjoniIstung>> serviceCallback) {
        return ServiceFuture.fromResponse(findCommitteeVotingsUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KomisjoniIstung&gt; object
     */
    public Observable<List<KomisjoniIstung>> findCommitteeVotingsUsingGETAsync(String uuid) {
        return findCommitteeVotingsUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<List<KomisjoniIstung>>, List<KomisjoniIstung>>() {
            @Override
            public List<KomisjoniIstung> call(ServiceResponse<List<KomisjoniIstung>> response) {
                return response.body();
            }
        });
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KomisjoniIstung&gt; object
     */
    public Observable<ServiceResponse<List<KomisjoniIstung>>> findCommitteeVotingsUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final LocalDate endDate = null;
        final String lang = null;
        final LocalDate startDate = null;
        return service.findCommitteeVotingsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<KomisjoniIstung>>>>() {
                @Override
                public Observable<ServiceResponse<List<KomisjoniIstung>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<KomisjoniIstung>> clientResponse = findCommitteeVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;KomisjoniIstung&gt; object if successful.
     */
    public List<KomisjoniIstung> findCommitteeVotingsUsingGET(String uuid, LocalDate endDate, String lang, LocalDate startDate) {
        return findCommitteeVotingsUsingGETWithServiceResponseAsync(uuid, endDate, lang, startDate).toBlocking().single().body();
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<KomisjoniIstung>> findCommitteeVotingsUsingGETAsync(String uuid, LocalDate endDate, String lang, LocalDate startDate, final ServiceCallback<List<KomisjoniIstung>> serviceCallback) {
        return ServiceFuture.fromResponse(findCommitteeVotingsUsingGETWithServiceResponseAsync(uuid, endDate, lang, startDate), serviceCallback);
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KomisjoniIstung&gt; object
     */
    public Observable<List<KomisjoniIstung>> findCommitteeVotingsUsingGETAsync(String uuid, LocalDate endDate, String lang, LocalDate startDate) {
        return findCommitteeVotingsUsingGETWithServiceResponseAsync(uuid, endDate, lang, startDate).map(new Func1<ServiceResponse<List<KomisjoniIstung>>, List<KomisjoniIstung>>() {
            @Override
            public List<KomisjoniIstung> call(ServiceResponse<List<KomisjoniIstung>> response) {
                return response.body();
            }
        });
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;KomisjoniIstung&gt; object
     */
    public Observable<ServiceResponse<List<KomisjoniIstung>>> findCommitteeVotingsUsingGETWithServiceResponseAsync(String uuid, LocalDate endDate, String lang, LocalDate startDate) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.findCommitteeVotingsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<KomisjoniIstung>>>>() {
                @Override
                public Observable<ServiceResponse<List<KomisjoniIstung>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<KomisjoniIstung>> clientResponse = findCommitteeVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<KomisjoniIstung>> findCommitteeVotingsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<KomisjoniIstung>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<KomisjoniIstung>>() { }.getType())
                .build(response);
    }

    /**
     * Viimane hääletus.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TIskoguHLetusDetailid object if successful.
     */
    public TIskoguHLetusDetailid getLastVotingUsingGET() {
        return getLastVotingUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Viimane hääletus.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TIskoguHLetusDetailid> getLastVotingUsingGETAsync(final ServiceCallback<TIskoguHLetusDetailid> serviceCallback) {
        return ServiceFuture.fromResponse(getLastVotingUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Viimane hääletus.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TIskoguHLetusDetailid object
     */
    public Observable<TIskoguHLetusDetailid> getLastVotingUsingGETAsync() {
        return getLastVotingUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<TIskoguHLetusDetailid>, TIskoguHLetusDetailid>() {
            @Override
            public TIskoguHLetusDetailid call(ServiceResponse<TIskoguHLetusDetailid> response) {
                return response.body();
            }
        });
    }

    /**
     * Viimane hääletus.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TIskoguHLetusDetailid object
     */
    public Observable<ServiceResponse<TIskoguHLetusDetailid>> getLastVotingUsingGETWithServiceResponseAsync() {
        final String lang = null;
        return service.getLastVotingUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TIskoguHLetusDetailid>>>() {
                @Override
                public Observable<ServiceResponse<TIskoguHLetusDetailid>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TIskoguHLetusDetailid> clientResponse = getLastVotingUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Viimane hääletus.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TIskoguHLetusDetailid object if successful.
     */
    public TIskoguHLetusDetailid getLastVotingUsingGET(String lang) {
        return getLastVotingUsingGETWithServiceResponseAsync(lang).toBlocking().single().body();
    }

    /**
     * Viimane hääletus.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TIskoguHLetusDetailid> getLastVotingUsingGETAsync(String lang, final ServiceCallback<TIskoguHLetusDetailid> serviceCallback) {
        return ServiceFuture.fromResponse(getLastVotingUsingGETWithServiceResponseAsync(lang), serviceCallback);
    }

    /**
     * Viimane hääletus.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TIskoguHLetusDetailid object
     */
    public Observable<TIskoguHLetusDetailid> getLastVotingUsingGETAsync(String lang) {
        return getLastVotingUsingGETWithServiceResponseAsync(lang).map(new Func1<ServiceResponse<TIskoguHLetusDetailid>, TIskoguHLetusDetailid>() {
            @Override
            public TIskoguHLetusDetailid call(ServiceResponse<TIskoguHLetusDetailid> response) {
                return response.body();
            }
        });
    }

    /**
     * Viimane hääletus.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TIskoguHLetusDetailid object
     */
    public Observable<ServiceResponse<TIskoguHLetusDetailid>> getLastVotingUsingGETWithServiceResponseAsync(String lang) {
        return service.getLastVotingUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TIskoguHLetusDetailid>>>() {
                @Override
                public Observable<ServiceResponse<TIskoguHLetusDetailid>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TIskoguHLetusDetailid> clientResponse = getLastVotingUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TIskoguHLetusDetailid> getLastVotingUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<TIskoguHLetusDetailid, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TIskoguHLetusDetailid>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesRiigikoguLiikmeHLetus object if successful.
     */
    public PagedResourcesRiigikoguLiikmeHLetus getPlenaryMemberVotingsUsingGET(String uuid) {
        return getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesRiigikoguLiikmeHLetus> getPlenaryMemberVotingsUsingGETAsync(String uuid, final ServiceCallback<PagedResourcesRiigikoguLiikmeHLetus> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesRiigikoguLiikmeHLetus object
     */
    public Observable<PagedResourcesRiigikoguLiikmeHLetus> getPlenaryMemberVotingsUsingGETAsync(String uuid) {
        return getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus>, PagedResourcesRiigikoguLiikmeHLetus>() {
            @Override
            public PagedResourcesRiigikoguLiikmeHLetus call(ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesRiigikoguLiikmeHLetus object
     */
    public Observable<ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus>> getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final LocalDate endDate = null;
        final String lang = null;
        final Long offset = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final LocalDate startDate = null;
        final Boolean unpaged = null;
        return service.getPlenaryMemberVotingsUsingGET(uuid, endDate, lang, offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, startDate, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus> clientResponse = getPlenaryMemberVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param startDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesRiigikoguLiikmeHLetus object if successful.
     */
    public PagedResourcesRiigikoguLiikmeHLetus getPlenaryMemberVotingsUsingGET(String uuid, LocalDate endDate, String lang, Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, LocalDate startDate, Boolean unpaged) {
        return getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(uuid, endDate, lang, offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, startDate, unpaged).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param startDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesRiigikoguLiikmeHLetus> getPlenaryMemberVotingsUsingGETAsync(String uuid, LocalDate endDate, String lang, Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, LocalDate startDate, Boolean unpaged, final ServiceCallback<PagedResourcesRiigikoguLiikmeHLetus> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(uuid, endDate, lang, offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, startDate, unpaged), serviceCallback);
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param startDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesRiigikoguLiikmeHLetus object
     */
    public Observable<PagedResourcesRiigikoguLiikmeHLetus> getPlenaryMemberVotingsUsingGETAsync(String uuid, LocalDate endDate, String lang, Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, LocalDate startDate, Boolean unpaged) {
        return getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(uuid, endDate, lang, offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, startDate, unpaged).map(new Func1<ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus>, PagedResourcesRiigikoguLiikmeHLetus>() {
            @Override
            public PagedResourcesRiigikoguLiikmeHLetus call(ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param startDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesRiigikoguLiikmeHLetus object
     */
    public Observable<ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus>> getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(String uuid, LocalDate endDate, String lang, Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, LocalDate startDate, Boolean unpaged) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getPlenaryMemberVotingsUsingGET(uuid, endDate, lang, offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, startDate, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus> clientResponse = getPlenaryMemberVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesRiigikoguLiikmeHLetus> getPlenaryMemberVotingsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedResourcesRiigikoguLiikmeHLetus, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesRiigikoguLiikmeHLetus>() { }.getType())
                .build(response);
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TIskoguHLetusDetailid object if successful.
     */
    public TIskoguHLetusDetailid getVotingUsingGET(String uuid) {
        return getVotingUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TIskoguHLetusDetailid> getVotingUsingGETAsync(String uuid, final ServiceCallback<TIskoguHLetusDetailid> serviceCallback) {
        return ServiceFuture.fromResponse(getVotingUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TIskoguHLetusDetailid object
     */
    public Observable<TIskoguHLetusDetailid> getVotingUsingGETAsync(String uuid) {
        return getVotingUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<TIskoguHLetusDetailid>, TIskoguHLetusDetailid>() {
            @Override
            public TIskoguHLetusDetailid call(ServiceResponse<TIskoguHLetusDetailid> response) {
                return response.body();
            }
        });
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TIskoguHLetusDetailid object
     */
    public Observable<ServiceResponse<TIskoguHLetusDetailid>> getVotingUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getVotingUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TIskoguHLetusDetailid>>>() {
                @Override
                public Observable<ServiceResponse<TIskoguHLetusDetailid>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TIskoguHLetusDetailid> clientResponse = getVotingUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the TIskoguHLetusDetailid object if successful.
     */
    public TIskoguHLetusDetailid getVotingUsingGET(String uuid, String lang) {
        return getVotingUsingGETWithServiceResponseAsync(uuid, lang).toBlocking().single().body();
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<TIskoguHLetusDetailid> getVotingUsingGETAsync(String uuid, String lang, final ServiceCallback<TIskoguHLetusDetailid> serviceCallback) {
        return ServiceFuture.fromResponse(getVotingUsingGETWithServiceResponseAsync(uuid, lang), serviceCallback);
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TIskoguHLetusDetailid object
     */
    public Observable<TIskoguHLetusDetailid> getVotingUsingGETAsync(String uuid, String lang) {
        return getVotingUsingGETWithServiceResponseAsync(uuid, lang).map(new Func1<ServiceResponse<TIskoguHLetusDetailid>, TIskoguHLetusDetailid>() {
            @Override
            public TIskoguHLetusDetailid call(ServiceResponse<TIskoguHLetusDetailid> response) {
                return response.body();
            }
        });
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the TIskoguHLetusDetailid object
     */
    public Observable<ServiceResponse<TIskoguHLetusDetailid>> getVotingUsingGETWithServiceResponseAsync(String uuid, String lang) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getVotingUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<TIskoguHLetusDetailid>>>() {
                @Override
                public Observable<ServiceResponse<TIskoguHLetusDetailid>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<TIskoguHLetusDetailid> clientResponse = getVotingUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<TIskoguHLetusDetailid> getVotingUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<TIskoguHLetusDetailid, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<TIskoguHLetusDetailid>() { }.getType())
                .build(response);
    }

}
