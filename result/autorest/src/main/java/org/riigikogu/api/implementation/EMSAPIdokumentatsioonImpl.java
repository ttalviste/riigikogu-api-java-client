/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package org.riigikogu.api.implementation;

import org.riigikogu.api.EMSAPIdokumentatsioon;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.CollectionFormat;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import org.joda.time.LocalDate;
import org.riigikogu.api.models.Agenda;
import org.riigikogu.api.models.AgendaStenoUrl;
import org.riigikogu.api.models.Classifier;
import org.riigikogu.api.models.ClassifierValueDetails;
import org.riigikogu.api.models.CollectiveAddress;
import org.riigikogu.api.models.CommitteeSitting;
import org.riigikogu.api.models.Contacts;
import org.riigikogu.api.models.Document;
import org.riigikogu.api.models.DocumentTree;
import org.riigikogu.api.models.DocumentTypes;
import org.riigikogu.api.models.DraftInitiators;
import org.riigikogu.api.models.DraftVolume;
import org.riigikogu.api.models.ErjkProtocol;
import org.riigikogu.api.models.EventCalendar;
import org.riigikogu.api.models.Events;
import org.riigikogu.api.models.FactionSpeech;
import org.riigikogu.api.models.FileMetadata;
import org.riigikogu.api.models.Hallplan;
import org.riigikogu.api.models.LastStenoSpeech;
import org.riigikogu.api.models.MemberParticipation;
import org.riigikogu.api.models.Membership;
import org.riigikogu.api.models.PagedResourcesOfDocument;
import org.riigikogu.api.models.PagedResourcesOfDraftVolumes;
import org.riigikogu.api.models.PagedResourcesOfEuropeanUnionDocument;
import org.riigikogu.api.models.PagedResourcesOfInterpellations;
import org.riigikogu.api.models.PagedResourcesOfOtherQuestions;
import org.riigikogu.api.models.PagedResourcesOfPlenaryMemberSitting;
import org.riigikogu.api.models.PagedResourcesOfVolumes;
import org.riigikogu.api.models.PagedResourcesOfWrittenQuestions;
import org.riigikogu.api.models.PlenaryMember;
import org.riigikogu.api.models.PlenaryMemberDetails;
import org.riigikogu.api.models.PlenaryMemberVoting;
import org.riigikogu.api.models.PlenarySittingVoting;
import org.riigikogu.api.models.PlenaryVotingDetails;
import org.riigikogu.api.models.Session;
import org.riigikogu.api.models.StenoSpeeches;
import org.riigikogu.api.models.StenoSpeechesCount;
import org.riigikogu.api.models.UnitAgenda;
import org.riigikogu.api.models.UserDetails;
import org.riigikogu.api.models.UserGroup;
import org.riigikogu.api.models.Volume;
import org.riigikogu.api.models.VolumeTypes;
import org.riigikogu.api.models.VotingCalendar;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.Path;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the EMSAPIdokumentatsioon class.
 */
public class EMSAPIdokumentatsioonImpl extends ServiceClient implements EMSAPIdokumentatsioon {
    /**
     * The Retrofit service to perform REST calls.
     */
    private EMSAPIdokumentatsioonService service;

    /**
     * Initializes an instance of EMSAPIdokumentatsioon client.
     */
    public EMSAPIdokumentatsioonImpl() {
        this("http://api.riigikogu.ee");
    }

    /**
     * Initializes an instance of EMSAPIdokumentatsioon client.
     *
     * @param baseUrl the base URL of the host
     */
    public EMSAPIdokumentatsioonImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of EMSAPIdokumentatsioon client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public EMSAPIdokumentatsioonImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("http://api.riigikogu.ee", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of EMSAPIdokumentatsioon client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public EMSAPIdokumentatsioonImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of EMSAPIdokumentatsioon client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public EMSAPIdokumentatsioonImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(EMSAPIdokumentatsioonService.class);
    }

    /**
     * The interface defining all the services for EMSAPIdokumentatsioon to be
     * used by Retrofit to perform actually REST calls.
     */
    interface EMSAPIdokumentatsioonService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenaryAgendaUsingGET" })
        @GET("api/agenda/plenary")
        Observable<Response<ResponseBody>> getPlenaryAgendaUsingGET(@Query("date") LocalDate dateParameter, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("querySteno") Boolean querySteno, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getUnitAgendaUsingGET" })
        @GET("api/agenda/usergroup/{uuid}")
        Observable<Response<ResponseBody>> getUnitAgendaUsingGET(@Path("uuid") String uuid, @Query("date") LocalDate dateParameter, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getClassifiersUsingGET" })
        @GET("api/classifiers")
        Observable<Response<ResponseBody>> getClassifiersUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getClassifierValueUsingGET" })
        @GET("api/classifiers/{classifierCode}/{valueCode}")
        Observable<Response<ResponseBody>> getClassifierValueUsingGET(@Path("classifierCode") String classifierCode, @Path("valueCode") String valueCode, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getClassifierValuesUsingGET" })
        @GET("api/classifiers/{code}")
        Observable<Response<ResponseBody>> getClassifierValuesUsingGET(@Path("code") String code, @Query("includeInactive") Boolean includeInactive, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getContactsUsingGET" })
        @GET("api/contacts")
        Observable<Response<ResponseBody>> getContactsUsingGET(@Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getUserDetailsUsingGET" })
        @GET("api/contacts/{uuid}")
        Observable<Response<ResponseBody>> getUserDetailsUsingGET(@Path("uuid") String uuid, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findDocumentsUsingGET" })
        @GET("api/documents")
        Observable<Response<ResponseBody>> findDocumentsUsingGET(@Query("authorReference") String authorReference, @Query("createdEnd") LocalDate createdEnd, @Query("createdStart") LocalDate createdStart, @Query("directionCode") String directionCode, @Query("documentType") String documentType, @Query("functionUuid") String functionUuid, @Query("letterAuthor") String letterAuthor, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("reference") String reference, @Query("seriesUuid") String seriesUuid, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("subseriesUuid") String subseriesUuid, @Query("title") String title, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findCollectiveAddressesUsingGET" })
        @GET("api/documents/collective-addresses")
        Observable<Response<ResponseBody>> findCollectiveAddressesUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findCollectiveAddressUsingGET" })
        @GET("api/documents/collective-addresses/{uuidOrSenderRef}")
        Observable<Response<ResponseBody>> findCollectiveAddressUsingGET(@Path("uuidOrSenderRef") String uuidOrSenderRef);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findOtherQuestionsUsingGET" })
        @GET("api/documents/other-questions")
        Observable<Response<ResponseBody>> findOtherQuestionsUsingGET(@Query("applicantUuid") String applicantUuid, @Query("createdEnd") LocalDate createdEnd, @Query("createdStart") LocalDate createdStart, @Query("dateEnd") LocalDate dateEnd, @Query("dateStart") LocalDate dateStart, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("querySteno") Boolean querySteno, @Query("reference") String reference, @Query("reporterUuid") String reporterUuid, @Query("sittingDateTimeEnd") LocalDate sittingDateTimeEnd, @Query("sittingDateTimeStart") LocalDate sittingDateTimeStart, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("subTypeCode") String subTypeCode, @Query("title") String title, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getDocumentUsingGET" })
        @GET("api/documents/{uuid}")
        Observable<Response<ResponseBody>> getDocumentUsingGET(@Path("uuid") String uuid, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getEventsUsingGET" })
        @GET("api/events")
        Observable<Response<ResponseBody>> getEventsUsingGET(@Query("date") LocalDate dateParameter, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("querySteno") Boolean querySteno, @Query("startDate") LocalDate startDate, @Query("type") String type);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getEventCalendarUsingGET" })
        @GET("api/events/calendar")
        Observable<Response<ResponseBody>> getEventCalendarUsingGET(@Query("committeeGroupUuid") String committeeGroupUuid, @Query("endDate") LocalDate endDate, @Query("startDate") LocalDate startDate, @Query("type") String type);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getFileMetadataUsingGET" })
        @GET("api/files/{uuid}")
        Observable<Response<ResponseBody>> getFileMetadataUsingGET(@Path("uuid") String uuid, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon downloadFileUsingGET" })
        @GET("api/files/{uuid}/download")
        Observable<Response<ResponseBody>> downloadFileUsingGET(@Path("uuid") String uuid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getLatestHallplanUsingGET" })
        @GET("api/hallplan")
        Observable<Response<ResponseBody>> getLatestHallplanUsingGET(@Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getDocumentTreeUsingGET" })
        @GET("api/lists/document-tree")
        Observable<Response<ResponseBody>> getDocumentTreeUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getDocumentTypesUsingGET" })
        @GET("api/lists/document-types")
        Observable<Response<ResponseBody>> getDocumentTypesUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getDraftInitiatorsUsingGET" })
        @GET("api/lists/draft-initiators")
        Observable<Response<ResponseBody>> getDraftInitiatorsUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getVolumeTypesUsingGET" })
        @GET("api/lists/volume-types")
        Observable<Response<ResponseBody>> getVolumeTypesUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getMembershipsUsingGET" })
        @GET("api/memberships")
        Observable<Response<ResponseBody>> getMembershipsUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getCurrentMembershipUsingGET" })
        @GET("api/memberships/current")
        Observable<Response<ResponseBody>> getCurrentMembershipUsingGET();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getMembershipUsingGET" })
        @GET("api/memberships/{number}")
        Observable<Response<ResponseBody>> getMembershipUsingGET(@Path("number") int number);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenaryMembersUsingGET" })
        @GET("api/plenary-members")
        Observable<Response<ResponseBody>> getPlenaryMembersUsingGET(@Query("committeeUuid") String committeeUuid, @Query("electoralDistrictCodes") String electoralDistrictCodes, @Query("factionUuid") String factionUuid, @Query("includeInactive") Boolean includeInactive, @Query("lang") String lang, @Query("membership") Integer membership, @Query("name") String name);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenaryMemberDetailsUsingGET" })
        @GET("api/plenary-members/{uuid}")
        Observable<Response<ResponseBody>> getPlenaryMemberDetailsUsingGET(@Path("uuid") String uuid, @Query("lang") String lang, @Query("querySteno") Boolean querySteno);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getSessionsUsingGET" })
        @GET("api/sessions")
        Observable<Response<ResponseBody>> getSessionsUsingGET(@Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getCurrentSessionUsingGET" })
        @GET("api/sessions/current")
        Observable<Response<ResponseBody>> getCurrentSessionUsingGET(@Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getFactionParticipationUsingGET" })
        @GET("api/statistics/participations/faction/{uuid}")
        Observable<Response<ResponseBody>> getFactionParticipationUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getMemberParticipationUsingGET" })
        @GET("api/statistics/participations/member/{uuid}")
        Observable<Response<ResponseBody>> getMemberParticipationUsingGET(@Path("uuid") String uuid, @Query("details") Boolean details, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenaryParticipationUsingGET" })
        @GET("api/statistics/participations/plenary")
        Observable<Response<ResponseBody>> getPlenaryParticipationUsingGET(@Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getFactionSpeechStatisticsUsingGET" })
        @GET("api/statistics/speeches/faction/{uuid}")
        Observable<Response<ResponseBody>> getFactionSpeechStatisticsUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getMemberSpeechStatisticsUsingGET" })
        @GET("api/statistics/speeches/member/{uuid}")
        Observable<Response<ResponseBody>> getMemberSpeechStatisticsUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenarySpeechStatisticsUsingGET" })
        @GET("api/statistics/speeches/plenary")
        Observable<Response<ResponseBody>> getPlenarySpeechStatisticsUsingGET(@Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getFactionVotingStatisticsUsingGET" })
        @GET("api/statistics/votings/faction/{uuid}")
        Observable<Response<ResponseBody>> getFactionVotingStatisticsUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getMemberVotingStatisticsUsingGET" })
        @GET("api/statistics/votings/member/{uuid}")
        Observable<Response<ResponseBody>> getMemberVotingStatisticsUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenaryVotingStatisticsUsingGET" })
        @GET("api/statistics/votings/plenary")
        Observable<Response<ResponseBody>> getPlenaryVotingStatisticsUsingGET(@Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getAgendaUrlsUsingGET" })
        @GET("api/steno/agenda")
        Observable<Response<ResponseBody>> getAgendaUrlsUsingGET(@Query("uuids") String uuids);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getLastVerbatimsUsingGET" })
        @GET("api/steno/lastVerbatims")
        Observable<Response<ResponseBody>> getLastVerbatimsUsingGET(@Query("count") Integer count);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getSpeechesUsingGET" })
        @GET("api/steno/speeches")
        Observable<Response<ResponseBody>> getSpeechesUsingGET(@Query("endDate") LocalDate endDate, @Query("membership") Integer membership, @Query("startDate") LocalDate startDate, @Query("userUuids") String userUuids);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getSpeechCountUsingGET" })
        @GET("api/steno/speeches/count")
        Observable<Response<ResponseBody>> getSpeechCountUsingGET(@Query("endDate") LocalDate endDate, @Query("membership") Integer membership, @Query("startDate") LocalDate startDate, @Query("type") String type, @Query("userUuid") String userUuid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getLastSpeechUsingGET" })
        @GET("api/steno/speeches/last")
        Observable<Response<ResponseBody>> getLastSpeechUsingGET(@Query("charCount") Integer charCount, @Query("membership") Integer membership, @Query("type") String type, @Query("userUuid") String userUuid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findUserGroupsUsingGET" })
        @GET("api/usergroups")
        Observable<Response<ResponseBody>> findUserGroupsUsingGET(@Query("hideInactive") Boolean hideInactive, @Query("lang") String lang, @Query("name") String name, @Query("typeCode") String typeCode);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getUserGroupUsingGET" })
        @GET("api/usergroups/{uuid}")
        Observable<Response<ResponseBody>> getUserGroupUsingGET(@Path("uuid") String uuid, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findVolumesUsingGET" })
        @GET("api/volumes")
        Observable<Response<ResponseBody>> findVolumesUsingGET(@Query("createdEndDate") LocalDate createdEndDate, @Query("createdStartDate") LocalDate createdStartDate, @Query("functionGroupUuid") String functionGroupUuid, @Query("functionUuid") String functionUuid, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("reference") String reference, @Query("seriesUuid") String seriesUuid, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("subseriesUuid") String subseriesUuid, @Query("title") String title, @Query("unpaged") Boolean unpaged, @Query("volumeType") String volumeType);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findDraftVolumesUsingGET" })
        @GET("api/volumes/drafts")
        Observable<Response<ResponseBody>> findDraftVolumesUsingGET(@Query("activeDraftStage") String activeDraftStage, @Query("amendmentsDeadlineEndDate") LocalDate amendmentsDeadlineEndDate, @Query("amendmentsDeadlineStartDate") LocalDate amendmentsDeadlineStartDate, @Query("descriptorId") Integer descriptorId, @Query("draftTypeCode") String draftTypeCode, @Query("initiatedEndDate") LocalDate initiatedEndDate, @Query("initiatedStartDate") LocalDate initiatedStartDate, @Query("initiatorUuid") String initiatorUuid, @Query("lang") String lang, @Query("leadingCommitteeUuid") String leadingCommitteeUuid, @Query("mark") Integer mark, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("proceedingStatus") String proceedingStatus, @Query("reference") String reference, @Query("responsibleMemberUuid") String responsibleMemberUuid, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("title") String title, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon testUsingGET" })
        @GET("api/volumes/drafts/test")
        Observable<Response<ResponseBody>> testUsingGET(@Query("offset") Long offset, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getDraftVolumeUsingGET" })
        @GET("api/volumes/drafts/{uuid}")
        Observable<Response<ResponseBody>> getDraftVolumeUsingGET(@Path("uuid") String uuid, @Query("lang") String lang, @Query("querySteno") Boolean querySteno);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findErjkProtocolsUsingGET" })
        @GET("api/volumes/erjk-protocols")
        Observable<Response<ResponseBody>> findErjkProtocolsUsingGET(@Query("sort") String sort, @Query("sorted") Boolean sorted, @Query("unsorted") Boolean unsorted);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findErjkProtocolUsingGET" })
        @GET("api/volumes/erjk-protocols/{uuid}")
        Observable<Response<ResponseBody>> findErjkProtocolUsingGET(@Path("uuid") String uuid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findEuropeanUnionDocumentsUsingGET" })
        @GET("api/volumes/eu")
        Observable<Response<ResponseBody>> findEuropeanUnionDocumentsUsingGET(@Query("createdEndDate") LocalDate createdEndDate, @Query("createdStartDate") LocalDate createdStartDate, @Query("documentType") String documentType, @Query("elMark") String elMark, @Query("elTypeCode") String elTypeCode, @Query("lang") String lang, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("opinionCommitteeUuid") String opinionCommitteeUuid, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("receiveDateEnd") LocalDate receiveDateEnd, @Query("receiveDateStart") LocalDate receiveDateStart, @Query("reference") String reference, @Query("responsibleCommitteeUuid") String responsibleCommitteeUuid, @Query("sectorCode") String sectorCode, @Query("sectorCommitteeUuid") String sectorCommitteeUuid, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("title") String title, @Query("titleEn") String titleEn, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findInterpellationsUsingGET" })
        @GET("api/volumes/interpellations")
        Observable<Response<ResponseBody>> findInterpellationsUsingGET(@Query("enquirerUuid") String enquirerUuid, @Query("lang") String lang, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findWrittenQuestionsUsingGET" })
        @GET("api/volumes/written-questions")
        Observable<Response<ResponseBody>> findWrittenQuestionsUsingGET(@Query("enquirerUuid") String enquirerUuid, @Query("lang") String lang, @Query("membership") Integer membership, @Query("offset") Long offset, @Query("page") Integer page, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("size") Integer size, @Query("sort") String sort, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getVolumeUsingGET" })
        @GET("api/volumes/{uuid}")
        Observable<Response<ResponseBody>> getVolumeUsingGET(@Path("uuid") String uuid, @Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getVotingsUsingGET" })
        @GET("api/votings")
        Observable<Response<ResponseBody>> getVotingsUsingGET(@Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getVotingCalendarUsingGET" })
        @GET("api/votings/calendar")
        Observable<Response<ResponseBody>> getVotingCalendarUsingGET(@Query("endDate") LocalDate endDate, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findCommitteeMemberVotingsUsingGET" })
        @GET("api/votings/committees")
        Observable<Response<ResponseBody>> findCommitteeMemberVotingsUsingGET(@Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate, @Query("userUuid") String userUuid);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon findCommitteeVotingsUsingGET" })
        @GET("api/votings/committees/{uuid}")
        Observable<Response<ResponseBody>> findCommitteeVotingsUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("startDate") LocalDate startDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getLastVotingUsingGET" })
        @GET("api/votings/last")
        Observable<Response<ResponseBody>> getLastVotingUsingGET(@Query("lang") String lang);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getPlenaryMemberVotingsUsingGET" })
        @GET("api/votings/plenary-member/{uuid}")
        Observable<Response<ResponseBody>> getPlenaryMemberVotingsUsingGET(@Path("uuid") String uuid, @Query("endDate") LocalDate endDate, @Query("lang") String lang, @Query("offset") Long offset, @Query("pageNumber") Integer pageNumber, @Query("pageSize") Integer pageSize, @Query("paged") Boolean paged, @Query("sort.sorted") Boolean sortsorted, @Query("sort.unsorted") Boolean sortunsorted, @Query("startDate") LocalDate startDate, @Query("unpaged") Boolean unpaged);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: org.riigikogu.api.EMSAPIdokumentatsioon getVotingUsingGET" })
        @GET("api/votings/{uuid}")
        Observable<Response<ResponseBody>> getVotingUsingGET(@Path("uuid") String uuid, @Query("lang") String lang);

    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Agenda object if successful.
     */
    public Agenda getPlenaryAgendaUsingGET() {
        return getPlenaryAgendaUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Agenda> getPlenaryAgendaUsingGETAsync(final ServiceCallback<Agenda> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryAgendaUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Agenda object
     */
    public Observable<Agenda> getPlenaryAgendaUsingGETAsync() {
        return getPlenaryAgendaUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<Agenda>, Agenda>() {
            @Override
            public Agenda call(ServiceResponse<Agenda> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Agenda object
     */
    public Observable<ServiceResponse<Agenda>> getPlenaryAgendaUsingGETWithServiceResponseAsync() {
        final LocalDate dateParameter = null;
        final LocalDate endDate = null;
        final String lang = null;
        final Boolean querySteno = null;
        final LocalDate startDate = null;
        return service.getPlenaryAgendaUsingGET(dateParameter, endDate, lang, querySteno, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Agenda>>>() {
                @Override
                public Observable<ServiceResponse<Agenda>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Agenda> clientResponse = getPlenaryAgendaUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Agenda object if successful.
     */
    public Agenda getPlenaryAgendaUsingGET(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate) {
        return getPlenaryAgendaUsingGETWithServiceResponseAsync(dateParameter, endDate, lang, querySteno, startDate).toBlocking().single().body();
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Agenda> getPlenaryAgendaUsingGETAsync(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate, final ServiceCallback<Agenda> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryAgendaUsingGETWithServiceResponseAsync(dateParameter, endDate, lang, querySteno, startDate), serviceCallback);
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Agenda object
     */
    public Observable<Agenda> getPlenaryAgendaUsingGETAsync(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate) {
        return getPlenaryAgendaUsingGETWithServiceResponseAsync(dateParameter, endDate, lang, querySteno, startDate).map(new Func1<ServiceResponse<Agenda>, Agenda>() {
            @Override
            public Agenda call(ServiceResponse<Agenda> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Agenda object
     */
    public Observable<ServiceResponse<Agenda>> getPlenaryAgendaUsingGETWithServiceResponseAsync(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate) {
        return service.getPlenaryAgendaUsingGET(dateParameter, endDate, lang, querySteno, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Agenda>>>() {
                @Override
                public Observable<ServiceResponse<Agenda>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Agenda> clientResponse = getPlenaryAgendaUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Agenda> getPlenaryAgendaUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Agenda, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Agenda>() { }.getType())
                .build(response);
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UnitAgenda object if successful.
     */
    public UnitAgenda getUnitAgendaUsingGET(String uuid) {
        return getUnitAgendaUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UnitAgenda> getUnitAgendaUsingGETAsync(String uuid, final ServiceCallback<UnitAgenda> serviceCallback) {
        return ServiceFuture.fromResponse(getUnitAgendaUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UnitAgenda object
     */
    public Observable<UnitAgenda> getUnitAgendaUsingGETAsync(String uuid) {
        return getUnitAgendaUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<UnitAgenda>, UnitAgenda>() {
            @Override
            public UnitAgenda call(ServiceResponse<UnitAgenda> response) {
                return response.body();
            }
        });
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UnitAgenda object
     */
    public Observable<ServiceResponse<UnitAgenda>> getUnitAgendaUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final LocalDate dateParameter = null;
        final LocalDate endDate = null;
        final String lang = null;
        final LocalDate startDate = null;
        return service.getUnitAgendaUsingGET(uuid, dateParameter, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UnitAgenda>>>() {
                @Override
                public Observable<ServiceResponse<UnitAgenda>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UnitAgenda> clientResponse = getUnitAgendaUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UnitAgenda object if successful.
     */
    public UnitAgenda getUnitAgendaUsingGET(String uuid, LocalDate dateParameter, LocalDate endDate, String lang, LocalDate startDate) {
        return getUnitAgendaUsingGETWithServiceResponseAsync(uuid, dateParameter, endDate, lang, startDate).toBlocking().single().body();
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UnitAgenda> getUnitAgendaUsingGETAsync(String uuid, LocalDate dateParameter, LocalDate endDate, String lang, LocalDate startDate, final ServiceCallback<UnitAgenda> serviceCallback) {
        return ServiceFuture.fromResponse(getUnitAgendaUsingGETWithServiceResponseAsync(uuid, dateParameter, endDate, lang, startDate), serviceCallback);
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UnitAgenda object
     */
    public Observable<UnitAgenda> getUnitAgendaUsingGETAsync(String uuid, LocalDate dateParameter, LocalDate endDate, String lang, LocalDate startDate) {
        return getUnitAgendaUsingGETWithServiceResponseAsync(uuid, dateParameter, endDate, lang, startDate).map(new Func1<ServiceResponse<UnitAgenda>, UnitAgenda>() {
            @Override
            public UnitAgenda call(ServiceResponse<UnitAgenda> response) {
                return response.body();
            }
        });
    }

    /**
     * Üksuse päevakord.
     * Päevakorda saab küsida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param uuid Kasutajagrupi UUID
     * @param dateParameter Kuupäev nädalas, mille päevakorda soovitakse
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UnitAgenda object
     */
    public Observable<ServiceResponse<UnitAgenda>> getUnitAgendaUsingGETWithServiceResponseAsync(String uuid, LocalDate dateParameter, LocalDate endDate, String lang, LocalDate startDate) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getUnitAgendaUsingGET(uuid, dateParameter, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UnitAgenda>>>() {
                @Override
                public Observable<ServiceResponse<UnitAgenda>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UnitAgenda> clientResponse = getUnitAgendaUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UnitAgenda> getUnitAgendaUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UnitAgenda, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UnitAgenda>() { }.getType())
                .build(response);
    }

    /**
     * Klassifikaatorid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Classifier&gt; object if successful.
     */
    public List<Classifier> getClassifiersUsingGET() {
        return getClassifiersUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Klassifikaatorid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Classifier>> getClassifiersUsingGETAsync(final ServiceCallback<List<Classifier>> serviceCallback) {
        return ServiceFuture.fromResponse(getClassifiersUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Klassifikaatorid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Classifier&gt; object
     */
    public Observable<List<Classifier>> getClassifiersUsingGETAsync() {
        return getClassifiersUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Classifier>>, List<Classifier>>() {
            @Override
            public List<Classifier> call(ServiceResponse<List<Classifier>> response) {
                return response.body();
            }
        });
    }

    /**
     * Klassifikaatorid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Classifier&gt; object
     */
    public Observable<ServiceResponse<List<Classifier>>> getClassifiersUsingGETWithServiceResponseAsync() {
        return service.getClassifiersUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Classifier>>>>() {
                @Override
                public Observable<ServiceResponse<List<Classifier>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Classifier>> clientResponse = getClassifiersUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Classifier>> getClassifiersUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Classifier>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Classifier>>() { }.getType())
                .build(response);
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClassifierValueDetails object if successful.
     */
    public ClassifierValueDetails getClassifierValueUsingGET(String classifierCode, String valueCode) {
        return getClassifierValueUsingGETWithServiceResponseAsync(classifierCode, valueCode).toBlocking().single().body();
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClassifierValueDetails> getClassifierValueUsingGETAsync(String classifierCode, String valueCode, final ServiceCallback<ClassifierValueDetails> serviceCallback) {
        return ServiceFuture.fromResponse(getClassifierValueUsingGETWithServiceResponseAsync(classifierCode, valueCode), serviceCallback);
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClassifierValueDetails object
     */
    public Observable<ClassifierValueDetails> getClassifierValueUsingGETAsync(String classifierCode, String valueCode) {
        return getClassifierValueUsingGETWithServiceResponseAsync(classifierCode, valueCode).map(new Func1<ServiceResponse<ClassifierValueDetails>, ClassifierValueDetails>() {
            @Override
            public ClassifierValueDetails call(ServiceResponse<ClassifierValueDetails> response) {
                return response.body();
            }
        });
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClassifierValueDetails object
     */
    public Observable<ServiceResponse<ClassifierValueDetails>> getClassifierValueUsingGETWithServiceResponseAsync(String classifierCode, String valueCode) {
        if (classifierCode == null) {
            throw new IllegalArgumentException("Parameter classifierCode is required and cannot be null.");
        }
        if (valueCode == null) {
            throw new IllegalArgumentException("Parameter valueCode is required and cannot be null.");
        }
        final String lang = null;
        return service.getClassifierValueUsingGET(classifierCode, valueCode, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClassifierValueDetails>>>() {
                @Override
                public Observable<ServiceResponse<ClassifierValueDetails>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClassifierValueDetails> clientResponse = getClassifierValueUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ClassifierValueDetails object if successful.
     */
    public ClassifierValueDetails getClassifierValueUsingGET(String classifierCode, String valueCode, String lang) {
        return getClassifierValueUsingGETWithServiceResponseAsync(classifierCode, valueCode, lang).toBlocking().single().body();
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ClassifierValueDetails> getClassifierValueUsingGETAsync(String classifierCode, String valueCode, String lang, final ServiceCallback<ClassifierValueDetails> serviceCallback) {
        return ServiceFuture.fromResponse(getClassifierValueUsingGETWithServiceResponseAsync(classifierCode, valueCode, lang), serviceCallback);
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClassifierValueDetails object
     */
    public Observable<ClassifierValueDetails> getClassifierValueUsingGETAsync(String classifierCode, String valueCode, String lang) {
        return getClassifierValueUsingGETWithServiceResponseAsync(classifierCode, valueCode, lang).map(new Func1<ServiceResponse<ClassifierValueDetails>, ClassifierValueDetails>() {
            @Override
            public ClassifierValueDetails call(ServiceResponse<ClassifierValueDetails> response) {
                return response.body();
            }
        });
    }

    /**
     * Klassifikaatori väärtus.
     *
     * @param classifierCode Klassifikaatori kood
     * @param valueCode Väärtuse kood
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ClassifierValueDetails object
     */
    public Observable<ServiceResponse<ClassifierValueDetails>> getClassifierValueUsingGETWithServiceResponseAsync(String classifierCode, String valueCode, String lang) {
        if (classifierCode == null) {
            throw new IllegalArgumentException("Parameter classifierCode is required and cannot be null.");
        }
        if (valueCode == null) {
            throw new IllegalArgumentException("Parameter valueCode is required and cannot be null.");
        }
        return service.getClassifierValueUsingGET(classifierCode, valueCode, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ClassifierValueDetails>>>() {
                @Override
                public Observable<ServiceResponse<ClassifierValueDetails>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ClassifierValueDetails> clientResponse = getClassifierValueUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ClassifierValueDetails> getClassifierValueUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ClassifierValueDetails, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ClassifierValueDetails>() { }.getType())
                .build(response);
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ClassifierValueDetails&gt; object if successful.
     */
    public List<ClassifierValueDetails> getClassifierValuesUsingGET(String code) {
        return getClassifierValuesUsingGETWithServiceResponseAsync(code).toBlocking().single().body();
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ClassifierValueDetails>> getClassifierValuesUsingGETAsync(String code, final ServiceCallback<List<ClassifierValueDetails>> serviceCallback) {
        return ServiceFuture.fromResponse(getClassifierValuesUsingGETWithServiceResponseAsync(code), serviceCallback);
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ClassifierValueDetails&gt; object
     */
    public Observable<List<ClassifierValueDetails>> getClassifierValuesUsingGETAsync(String code) {
        return getClassifierValuesUsingGETWithServiceResponseAsync(code).map(new Func1<ServiceResponse<List<ClassifierValueDetails>>, List<ClassifierValueDetails>>() {
            @Override
            public List<ClassifierValueDetails> call(ServiceResponse<List<ClassifierValueDetails>> response) {
                return response.body();
            }
        });
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ClassifierValueDetails&gt; object
     */
    public Observable<ServiceResponse<List<ClassifierValueDetails>>> getClassifierValuesUsingGETWithServiceResponseAsync(String code) {
        if (code == null) {
            throw new IllegalArgumentException("Parameter code is required and cannot be null.");
        }
        final Boolean includeInactive = null;
        final String lang = null;
        return service.getClassifierValuesUsingGET(code, includeInactive, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ClassifierValueDetails>>>>() {
                @Override
                public Observable<ServiceResponse<List<ClassifierValueDetails>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ClassifierValueDetails>> clientResponse = getClassifierValuesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @param includeInactive Kaasa mitteaktiivsed väärtused? (true/false)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ClassifierValueDetails&gt; object if successful.
     */
    public List<ClassifierValueDetails> getClassifierValuesUsingGET(String code, Boolean includeInactive, String lang) {
        return getClassifierValuesUsingGETWithServiceResponseAsync(code, includeInactive, lang).toBlocking().single().body();
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @param includeInactive Kaasa mitteaktiivsed väärtused? (true/false)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ClassifierValueDetails>> getClassifierValuesUsingGETAsync(String code, Boolean includeInactive, String lang, final ServiceCallback<List<ClassifierValueDetails>> serviceCallback) {
        return ServiceFuture.fromResponse(getClassifierValuesUsingGETWithServiceResponseAsync(code, includeInactive, lang), serviceCallback);
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @param includeInactive Kaasa mitteaktiivsed väärtused? (true/false)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ClassifierValueDetails&gt; object
     */
    public Observable<List<ClassifierValueDetails>> getClassifierValuesUsingGETAsync(String code, Boolean includeInactive, String lang) {
        return getClassifierValuesUsingGETWithServiceResponseAsync(code, includeInactive, lang).map(new Func1<ServiceResponse<List<ClassifierValueDetails>>, List<ClassifierValueDetails>>() {
            @Override
            public List<ClassifierValueDetails> call(ServiceResponse<List<ClassifierValueDetails>> response) {
                return response.body();
            }
        });
    }

    /**
     * Klassifikaatori väärtused.
     *
     * @param code Klassifikaatori kood
     * @param includeInactive Kaasa mitteaktiivsed väärtused? (true/false)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ClassifierValueDetails&gt; object
     */
    public Observable<ServiceResponse<List<ClassifierValueDetails>>> getClassifierValuesUsingGETWithServiceResponseAsync(String code, Boolean includeInactive, String lang) {
        if (code == null) {
            throw new IllegalArgumentException("Parameter code is required and cannot be null.");
        }
        return service.getClassifierValuesUsingGET(code, includeInactive, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ClassifierValueDetails>>>>() {
                @Override
                public Observable<ServiceResponse<List<ClassifierValueDetails>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ClassifierValueDetails>> clientResponse = getClassifierValuesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ClassifierValueDetails>> getClassifierValuesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<ClassifierValueDetails>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ClassifierValueDetails>>() { }.getType())
                .build(response);
    }

    /**
     * Kontaktide nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Contacts&gt; object if successful.
     */
    public List<Contacts> getContactsUsingGET() {
        return getContactsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Kontaktide nimekiri.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Contacts>> getContactsUsingGETAsync(final ServiceCallback<List<Contacts>> serviceCallback) {
        return ServiceFuture.fromResponse(getContactsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Kontaktide nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Contacts&gt; object
     */
    public Observable<List<Contacts>> getContactsUsingGETAsync() {
        return getContactsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Contacts>>, List<Contacts>>() {
            @Override
            public List<Contacts> call(ServiceResponse<List<Contacts>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kontaktide nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Contacts&gt; object
     */
    public Observable<ServiceResponse<List<Contacts>>> getContactsUsingGETWithServiceResponseAsync() {
        final String lang = null;
        return service.getContactsUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Contacts>>>>() {
                @Override
                public Observable<ServiceResponse<List<Contacts>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Contacts>> clientResponse = getContactsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Kontaktide nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Contacts&gt; object if successful.
     */
    public List<Contacts> getContactsUsingGET(String lang) {
        return getContactsUsingGETWithServiceResponseAsync(lang).toBlocking().single().body();
    }

    /**
     * Kontaktide nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Contacts>> getContactsUsingGETAsync(String lang, final ServiceCallback<List<Contacts>> serviceCallback) {
        return ServiceFuture.fromResponse(getContactsUsingGETWithServiceResponseAsync(lang), serviceCallback);
    }

    /**
     * Kontaktide nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Contacts&gt; object
     */
    public Observable<List<Contacts>> getContactsUsingGETAsync(String lang) {
        return getContactsUsingGETWithServiceResponseAsync(lang).map(new Func1<ServiceResponse<List<Contacts>>, List<Contacts>>() {
            @Override
            public List<Contacts> call(ServiceResponse<List<Contacts>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kontaktide nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Contacts&gt; object
     */
    public Observable<ServiceResponse<List<Contacts>>> getContactsUsingGETWithServiceResponseAsync(String lang) {
        return service.getContactsUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Contacts>>>>() {
                @Override
                public Observable<ServiceResponse<List<Contacts>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Contacts>> clientResponse = getContactsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Contacts>> getContactsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Contacts>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Contacts>>() { }.getType())
                .build(response);
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserDetails object if successful.
     */
    public UserDetails getUserDetailsUsingGET(String uuid) {
        return getUserDetailsUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserDetails> getUserDetailsUsingGETAsync(String uuid, final ServiceCallback<UserDetails> serviceCallback) {
        return ServiceFuture.fromResponse(getUserDetailsUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserDetails object
     */
    public Observable<UserDetails> getUserDetailsUsingGETAsync(String uuid) {
        return getUserDetailsUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<UserDetails>, UserDetails>() {
            @Override
            public UserDetails call(ServiceResponse<UserDetails> response) {
                return response.body();
            }
        });
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserDetails object
     */
    public Observable<ServiceResponse<UserDetails>> getUserDetailsUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getUserDetailsUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserDetails>>>() {
                @Override
                public Observable<ServiceResponse<UserDetails>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserDetails> clientResponse = getUserDetailsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserDetails object if successful.
     */
    public UserDetails getUserDetailsUsingGET(String uuid, String lang) {
        return getUserDetailsUsingGETWithServiceResponseAsync(uuid, lang).toBlocking().single().body();
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserDetails> getUserDetailsUsingGETAsync(String uuid, String lang, final ServiceCallback<UserDetails> serviceCallback) {
        return ServiceFuture.fromResponse(getUserDetailsUsingGETWithServiceResponseAsync(uuid, lang), serviceCallback);
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserDetails object
     */
    public Observable<UserDetails> getUserDetailsUsingGETAsync(String uuid, String lang) {
        return getUserDetailsUsingGETWithServiceResponseAsync(uuid, lang).map(new Func1<ServiceResponse<UserDetails>, UserDetails>() {
            @Override
            public UserDetails call(ServiceResponse<UserDetails> response) {
                return response.body();
            }
        });
    }

    /**
     * Detailid.
     *
     * @param uuid Kasutaja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserDetails object
     */
    public Observable<ServiceResponse<UserDetails>> getUserDetailsUsingGETWithServiceResponseAsync(String uuid, String lang) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getUserDetailsUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserDetails>>>() {
                @Override
                public Observable<ServiceResponse<UserDetails>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserDetails> clientResponse = getUserDetailsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserDetails> getUserDetailsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UserDetails, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UserDetails>() { }.getType())
                .build(response);
    }

    /**
     * Dokumentide otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfDocument object if successful.
     */
    public PagedResourcesOfDocument findDocumentsUsingGET() {
        return findDocumentsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Dokumentide otsing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfDocument> findDocumentsUsingGETAsync(final ServiceCallback<PagedResourcesOfDocument> serviceCallback) {
        return ServiceFuture.fromResponse(findDocumentsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Dokumentide otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfDocument object
     */
    public Observable<PagedResourcesOfDocument> findDocumentsUsingGETAsync() {
        return findDocumentsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesOfDocument>, PagedResourcesOfDocument>() {
            @Override
            public PagedResourcesOfDocument call(ServiceResponse<PagedResourcesOfDocument> response) {
                return response.body();
            }
        });
    }

    /**
     * Dokumentide otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfDocument object
     */
    public Observable<ServiceResponse<PagedResourcesOfDocument>> findDocumentsUsingGETWithServiceResponseAsync() {
        final String authorReference = null;
        final LocalDate createdEnd = null;
        final LocalDate createdStart = null;
        final String directionCode = null;
        final String documentType = null;
        final String functionUuid = null;
        final String letterAuthor = null;
        final Integer membership = null;
        final Long offset = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final String reference = null;
        final String seriesUuid = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final String subseriesUuid = null;
        final String title = null;
        final Boolean unpaged = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findDocumentsUsingGET(authorReference, createdEnd, createdStart, directionCode, documentType, functionUuid, letterAuthor, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sortConverted, sortsorted, sortunsorted, subseriesUuid, title, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfDocument>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfDocument>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfDocument> clientResponse = findDocumentsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Dokumentide otsing.
     *
     * @param authorReference [Kiri] Autori viit
     * @param createdEnd Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStart Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param directionCode [Kiri] Suund (klassifikaator 'kirjaSuund'). Possible values include: 'SISEMINE', 'SISSE', 'VALJA'
     * @param documentType Dokumendi liik. Possible values include: 'yldine', 'lugemiseTekst', 'muudatusettepanek', 'muudatusettepanekugaLiitumine', 'meLoetelu', 'plenaryAgendaItemDocument', 'unitAgendaItemDocument', 'infoAgendaItemDocument', 'interpellationsAgendaItemDocument', 'algtekst', 'lopptekst', 'seletuskiri', 'protokoll', 'interpellationsDocument', 'interpellationsAnswerDocument', 'opinionDocument', 'applicationDocument', 'excursionDocument', 'translationDocument', 'writtenQuestionDocument', 'writtenQuestionAnswerDocument', 'letterDocument', 'directiveDocument', 'pressReleaseDocument', 'decisionDocument', 'otherQuestionDocument', 'officialJourneyDocument', 'orderDocument', 'orderImplementationDocument', 'contractDocument', 'pursueDocument', 'elDocument', 'commissionOpinionDocument', 'vabariigiPresidendiOtsus', 'lisadokumendid', 'aruanne', 'taiskoguToonadalaProtokoll', 'riigikoguSeisukoht', 'uuring', 'meAllkirjastamine', 'jobDescriptionDocument', 'collectiveAddressDocument'
     * @param functionUuid Funktsiooni UUID
     * @param letterAuthor [Kiri] Autor
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfDocument object if successful.
     */
    public PagedResourcesOfDocument findDocumentsUsingGET(String authorReference, LocalDate createdEnd, LocalDate createdStart, String directionCode, String documentType, String functionUuid, String letterAuthor, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged) {
        return findDocumentsUsingGETWithServiceResponseAsync(authorReference, createdEnd, createdStart, directionCode, documentType, functionUuid, letterAuthor, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sort, sortsorted, sortunsorted, subseriesUuid, title, unpaged).toBlocking().single().body();
    }

    /**
     * Dokumentide otsing.
     *
     * @param authorReference [Kiri] Autori viit
     * @param createdEnd Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStart Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param directionCode [Kiri] Suund (klassifikaator 'kirjaSuund'). Possible values include: 'SISEMINE', 'SISSE', 'VALJA'
     * @param documentType Dokumendi liik. Possible values include: 'yldine', 'lugemiseTekst', 'muudatusettepanek', 'muudatusettepanekugaLiitumine', 'meLoetelu', 'plenaryAgendaItemDocument', 'unitAgendaItemDocument', 'infoAgendaItemDocument', 'interpellationsAgendaItemDocument', 'algtekst', 'lopptekst', 'seletuskiri', 'protokoll', 'interpellationsDocument', 'interpellationsAnswerDocument', 'opinionDocument', 'applicationDocument', 'excursionDocument', 'translationDocument', 'writtenQuestionDocument', 'writtenQuestionAnswerDocument', 'letterDocument', 'directiveDocument', 'pressReleaseDocument', 'decisionDocument', 'otherQuestionDocument', 'officialJourneyDocument', 'orderDocument', 'orderImplementationDocument', 'contractDocument', 'pursueDocument', 'elDocument', 'commissionOpinionDocument', 'vabariigiPresidendiOtsus', 'lisadokumendid', 'aruanne', 'taiskoguToonadalaProtokoll', 'riigikoguSeisukoht', 'uuring', 'meAllkirjastamine', 'jobDescriptionDocument', 'collectiveAddressDocument'
     * @param functionUuid Funktsiooni UUID
     * @param letterAuthor [Kiri] Autor
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfDocument> findDocumentsUsingGETAsync(String authorReference, LocalDate createdEnd, LocalDate createdStart, String directionCode, String documentType, String functionUuid, String letterAuthor, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged, final ServiceCallback<PagedResourcesOfDocument> serviceCallback) {
        return ServiceFuture.fromResponse(findDocumentsUsingGETWithServiceResponseAsync(authorReference, createdEnd, createdStart, directionCode, documentType, functionUuid, letterAuthor, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sort, sortsorted, sortunsorted, subseriesUuid, title, unpaged), serviceCallback);
    }

    /**
     * Dokumentide otsing.
     *
     * @param authorReference [Kiri] Autori viit
     * @param createdEnd Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStart Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param directionCode [Kiri] Suund (klassifikaator 'kirjaSuund'). Possible values include: 'SISEMINE', 'SISSE', 'VALJA'
     * @param documentType Dokumendi liik. Possible values include: 'yldine', 'lugemiseTekst', 'muudatusettepanek', 'muudatusettepanekugaLiitumine', 'meLoetelu', 'plenaryAgendaItemDocument', 'unitAgendaItemDocument', 'infoAgendaItemDocument', 'interpellationsAgendaItemDocument', 'algtekst', 'lopptekst', 'seletuskiri', 'protokoll', 'interpellationsDocument', 'interpellationsAnswerDocument', 'opinionDocument', 'applicationDocument', 'excursionDocument', 'translationDocument', 'writtenQuestionDocument', 'writtenQuestionAnswerDocument', 'letterDocument', 'directiveDocument', 'pressReleaseDocument', 'decisionDocument', 'otherQuestionDocument', 'officialJourneyDocument', 'orderDocument', 'orderImplementationDocument', 'contractDocument', 'pursueDocument', 'elDocument', 'commissionOpinionDocument', 'vabariigiPresidendiOtsus', 'lisadokumendid', 'aruanne', 'taiskoguToonadalaProtokoll', 'riigikoguSeisukoht', 'uuring', 'meAllkirjastamine', 'jobDescriptionDocument', 'collectiveAddressDocument'
     * @param functionUuid Funktsiooni UUID
     * @param letterAuthor [Kiri] Autor
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfDocument object
     */
    public Observable<PagedResourcesOfDocument> findDocumentsUsingGETAsync(String authorReference, LocalDate createdEnd, LocalDate createdStart, String directionCode, String documentType, String functionUuid, String letterAuthor, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged) {
        return findDocumentsUsingGETWithServiceResponseAsync(authorReference, createdEnd, createdStart, directionCode, documentType, functionUuid, letterAuthor, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sort, sortsorted, sortunsorted, subseriesUuid, title, unpaged).map(new Func1<ServiceResponse<PagedResourcesOfDocument>, PagedResourcesOfDocument>() {
            @Override
            public PagedResourcesOfDocument call(ServiceResponse<PagedResourcesOfDocument> response) {
                return response.body();
            }
        });
    }

    /**
     * Dokumentide otsing.
     *
     * @param authorReference [Kiri] Autori viit
     * @param createdEnd Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStart Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param directionCode [Kiri] Suund (klassifikaator 'kirjaSuund'). Possible values include: 'SISEMINE', 'SISSE', 'VALJA'
     * @param documentType Dokumendi liik. Possible values include: 'yldine', 'lugemiseTekst', 'muudatusettepanek', 'muudatusettepanekugaLiitumine', 'meLoetelu', 'plenaryAgendaItemDocument', 'unitAgendaItemDocument', 'infoAgendaItemDocument', 'interpellationsAgendaItemDocument', 'algtekst', 'lopptekst', 'seletuskiri', 'protokoll', 'interpellationsDocument', 'interpellationsAnswerDocument', 'opinionDocument', 'applicationDocument', 'excursionDocument', 'translationDocument', 'writtenQuestionDocument', 'writtenQuestionAnswerDocument', 'letterDocument', 'directiveDocument', 'pressReleaseDocument', 'decisionDocument', 'otherQuestionDocument', 'officialJourneyDocument', 'orderDocument', 'orderImplementationDocument', 'contractDocument', 'pursueDocument', 'elDocument', 'commissionOpinionDocument', 'vabariigiPresidendiOtsus', 'lisadokumendid', 'aruanne', 'taiskoguToonadalaProtokoll', 'riigikoguSeisukoht', 'uuring', 'meAllkirjastamine', 'jobDescriptionDocument', 'collectiveAddressDocument'
     * @param functionUuid Funktsiooni UUID
     * @param letterAuthor [Kiri] Autor
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfDocument object
     */
    public Observable<ServiceResponse<PagedResourcesOfDocument>> findDocumentsUsingGETWithServiceResponseAsync(String authorReference, LocalDate createdEnd, LocalDate createdStart, String directionCode, String documentType, String functionUuid, String letterAuthor, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findDocumentsUsingGET(authorReference, createdEnd, createdStart, directionCode, documentType, functionUuid, letterAuthor, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sortConverted, sortsorted, sortunsorted, subseriesUuid, title, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfDocument>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfDocument>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfDocument> clientResponse = findDocumentsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesOfDocument> findDocumentsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesOfDocument, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesOfDocument>() { }.getType())
                .build(response);
    }

    /**
     * Kollektiivsed pöördumised.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;CollectiveAddress&gt; object if successful.
     */
    public List<CollectiveAddress> findCollectiveAddressesUsingGET() {
        return findCollectiveAddressesUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Kollektiivsed pöördumised.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CollectiveAddress>> findCollectiveAddressesUsingGETAsync(final ServiceCallback<List<CollectiveAddress>> serviceCallback) {
        return ServiceFuture.fromResponse(findCollectiveAddressesUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Kollektiivsed pöördumised.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CollectiveAddress&gt; object
     */
    public Observable<List<CollectiveAddress>> findCollectiveAddressesUsingGETAsync() {
        return findCollectiveAddressesUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<CollectiveAddress>>, List<CollectiveAddress>>() {
            @Override
            public List<CollectiveAddress> call(ServiceResponse<List<CollectiveAddress>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kollektiivsed pöördumised.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CollectiveAddress&gt; object
     */
    public Observable<ServiceResponse<List<CollectiveAddress>>> findCollectiveAddressesUsingGETWithServiceResponseAsync() {
        return service.findCollectiveAddressesUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<CollectiveAddress>>>>() {
                @Override
                public Observable<ServiceResponse<List<CollectiveAddress>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<CollectiveAddress>> clientResponse = findCollectiveAddressesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<CollectiveAddress>> findCollectiveAddressesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<CollectiveAddress>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<CollectiveAddress>>() { }.getType())
                .build(response);
    }

    /**
     * Kollektiivse pöördumise detailid.
     *
     * @param uuidOrSenderRef Dokumendi UUID või saatja viit
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CollectiveAddress object if successful.
     */
    public CollectiveAddress findCollectiveAddressUsingGET(String uuidOrSenderRef) {
        return findCollectiveAddressUsingGETWithServiceResponseAsync(uuidOrSenderRef).toBlocking().single().body();
    }

    /**
     * Kollektiivse pöördumise detailid.
     *
     * @param uuidOrSenderRef Dokumendi UUID või saatja viit
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CollectiveAddress> findCollectiveAddressUsingGETAsync(String uuidOrSenderRef, final ServiceCallback<CollectiveAddress> serviceCallback) {
        return ServiceFuture.fromResponse(findCollectiveAddressUsingGETWithServiceResponseAsync(uuidOrSenderRef), serviceCallback);
    }

    /**
     * Kollektiivse pöördumise detailid.
     *
     * @param uuidOrSenderRef Dokumendi UUID või saatja viit
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CollectiveAddress object
     */
    public Observable<CollectiveAddress> findCollectiveAddressUsingGETAsync(String uuidOrSenderRef) {
        return findCollectiveAddressUsingGETWithServiceResponseAsync(uuidOrSenderRef).map(new Func1<ServiceResponse<CollectiveAddress>, CollectiveAddress>() {
            @Override
            public CollectiveAddress call(ServiceResponse<CollectiveAddress> response) {
                return response.body();
            }
        });
    }

    /**
     * Kollektiivse pöördumise detailid.
     *
     * @param uuidOrSenderRef Dokumendi UUID või saatja viit
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CollectiveAddress object
     */
    public Observable<ServiceResponse<CollectiveAddress>> findCollectiveAddressUsingGETWithServiceResponseAsync(String uuidOrSenderRef) {
        if (uuidOrSenderRef == null) {
            throw new IllegalArgumentException("Parameter uuidOrSenderRef is required and cannot be null.");
        }
        return service.findCollectiveAddressUsingGET(uuidOrSenderRef)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CollectiveAddress>>>() {
                @Override
                public Observable<ServiceResponse<CollectiveAddress>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CollectiveAddress> clientResponse = findCollectiveAddressUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CollectiveAddress> findCollectiveAddressUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<CollectiveAddress, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<CollectiveAddress>() { }.getType())
                .build(response);
    }

    /**
     * Muud küsimused.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfOtherQuestions object if successful.
     */
    public PagedResourcesOfOtherQuestions findOtherQuestionsUsingGET() {
        return findOtherQuestionsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Muud küsimused.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfOtherQuestions> findOtherQuestionsUsingGETAsync(final ServiceCallback<PagedResourcesOfOtherQuestions> serviceCallback) {
        return ServiceFuture.fromResponse(findOtherQuestionsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Muud küsimused.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfOtherQuestions object
     */
    public Observable<PagedResourcesOfOtherQuestions> findOtherQuestionsUsingGETAsync() {
        return findOtherQuestionsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesOfOtherQuestions>, PagedResourcesOfOtherQuestions>() {
            @Override
            public PagedResourcesOfOtherQuestions call(ServiceResponse<PagedResourcesOfOtherQuestions> response) {
                return response.body();
            }
        });
    }

    /**
     * Muud küsimused.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfOtherQuestions object
     */
    public Observable<ServiceResponse<PagedResourcesOfOtherQuestions>> findOtherQuestionsUsingGETWithServiceResponseAsync() {
        final String applicantUuid = null;
        final LocalDate createdEnd = null;
        final LocalDate createdStart = null;
        final LocalDate dateEnd = null;
        final LocalDate dateStart = null;
        final Integer membership = null;
        final Long offset = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final Boolean querySteno = null;
        final String reference = null;
        final String reporterUuid = null;
        final LocalDate sittingDateTimeEnd = null;
        final LocalDate sittingDateTimeStart = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final List<String> subTypeCode = null;
        final String title = null;
        final Boolean unpaged = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);String subTypeCodeConverted = this.serializerAdapter().serializeList(subTypeCode, CollectionFormat.MULTI);
        return service.findOtherQuestionsUsingGET(applicantUuid, createdEnd, createdStart, dateEnd, dateStart, membership, offset, page, pageNumber, pageSize, paged, querySteno, reference, reporterUuid, sittingDateTimeEnd, sittingDateTimeStart, size, sortConverted, sortsorted, sortunsorted, subTypeCodeConverted, title, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfOtherQuestions>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfOtherQuestions>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfOtherQuestions> clientResponse = findOtherQuestionsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Muud küsimused.
     *
     * @param applicantUuid Esitaja UUID
     * @param createdEnd Loomise lõppkuupäev (yyyy-MM-dd)
     * @param createdStart Loomise alguskuupäev (yyyy-MM-dd)
     * @param dateEnd Dokumendi kuupäeva lõpp (yyyy-MM-dd)
     * @param dateStart Dokumendi kuupäeva algus (yyyy-MM-dd)
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param reference Viit
     * @param reporterUuid Ettekandja UUID
     * @param sittingDateTimeEnd Seotud täiskogu istungi kuupäeva lõpp (yyyy-MM-dd)
     * @param sittingDateTimeStart Seotud täiskogu istungi kuupäeva algus (yyyy-MM-dd)
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subTypeCode Alamtüübi kood. Lubatud mitu väärtust.
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfOtherQuestions object if successful.
     */
    public PagedResourcesOfOtherQuestions findOtherQuestionsUsingGET(String applicantUuid, LocalDate createdEnd, LocalDate createdStart, LocalDate dateEnd, LocalDate dateStart, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Boolean querySteno, String reference, String reporterUuid, LocalDate sittingDateTimeEnd, LocalDate sittingDateTimeStart, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, List<String> subTypeCode, String title, Boolean unpaged) {
        return findOtherQuestionsUsingGETWithServiceResponseAsync(applicantUuid, createdEnd, createdStart, dateEnd, dateStart, membership, offset, page, pageNumber, pageSize, paged, querySteno, reference, reporterUuid, sittingDateTimeEnd, sittingDateTimeStart, size, sort, sortsorted, sortunsorted, subTypeCode, title, unpaged).toBlocking().single().body();
    }

    /**
     * Muud küsimused.
     *
     * @param applicantUuid Esitaja UUID
     * @param createdEnd Loomise lõppkuupäev (yyyy-MM-dd)
     * @param createdStart Loomise alguskuupäev (yyyy-MM-dd)
     * @param dateEnd Dokumendi kuupäeva lõpp (yyyy-MM-dd)
     * @param dateStart Dokumendi kuupäeva algus (yyyy-MM-dd)
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param reference Viit
     * @param reporterUuid Ettekandja UUID
     * @param sittingDateTimeEnd Seotud täiskogu istungi kuupäeva lõpp (yyyy-MM-dd)
     * @param sittingDateTimeStart Seotud täiskogu istungi kuupäeva algus (yyyy-MM-dd)
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subTypeCode Alamtüübi kood. Lubatud mitu väärtust.
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfOtherQuestions> findOtherQuestionsUsingGETAsync(String applicantUuid, LocalDate createdEnd, LocalDate createdStart, LocalDate dateEnd, LocalDate dateStart, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Boolean querySteno, String reference, String reporterUuid, LocalDate sittingDateTimeEnd, LocalDate sittingDateTimeStart, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, List<String> subTypeCode, String title, Boolean unpaged, final ServiceCallback<PagedResourcesOfOtherQuestions> serviceCallback) {
        return ServiceFuture.fromResponse(findOtherQuestionsUsingGETWithServiceResponseAsync(applicantUuid, createdEnd, createdStart, dateEnd, dateStart, membership, offset, page, pageNumber, pageSize, paged, querySteno, reference, reporterUuid, sittingDateTimeEnd, sittingDateTimeStart, size, sort, sortsorted, sortunsorted, subTypeCode, title, unpaged), serviceCallback);
    }

    /**
     * Muud küsimused.
     *
     * @param applicantUuid Esitaja UUID
     * @param createdEnd Loomise lõppkuupäev (yyyy-MM-dd)
     * @param createdStart Loomise alguskuupäev (yyyy-MM-dd)
     * @param dateEnd Dokumendi kuupäeva lõpp (yyyy-MM-dd)
     * @param dateStart Dokumendi kuupäeva algus (yyyy-MM-dd)
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param reference Viit
     * @param reporterUuid Ettekandja UUID
     * @param sittingDateTimeEnd Seotud täiskogu istungi kuupäeva lõpp (yyyy-MM-dd)
     * @param sittingDateTimeStart Seotud täiskogu istungi kuupäeva algus (yyyy-MM-dd)
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subTypeCode Alamtüübi kood. Lubatud mitu väärtust.
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfOtherQuestions object
     */
    public Observable<PagedResourcesOfOtherQuestions> findOtherQuestionsUsingGETAsync(String applicantUuid, LocalDate createdEnd, LocalDate createdStart, LocalDate dateEnd, LocalDate dateStart, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Boolean querySteno, String reference, String reporterUuid, LocalDate sittingDateTimeEnd, LocalDate sittingDateTimeStart, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, List<String> subTypeCode, String title, Boolean unpaged) {
        return findOtherQuestionsUsingGETWithServiceResponseAsync(applicantUuid, createdEnd, createdStart, dateEnd, dateStart, membership, offset, page, pageNumber, pageSize, paged, querySteno, reference, reporterUuid, sittingDateTimeEnd, sittingDateTimeStart, size, sort, sortsorted, sortunsorted, subTypeCode, title, unpaged).map(new Func1<ServiceResponse<PagedResourcesOfOtherQuestions>, PagedResourcesOfOtherQuestions>() {
            @Override
            public PagedResourcesOfOtherQuestions call(ServiceResponse<PagedResourcesOfOtherQuestions> response) {
                return response.body();
            }
        });
    }

    /**
     * Muud küsimused.
     *
     * @param applicantUuid Esitaja UUID
     * @param createdEnd Loomise lõppkuupäev (yyyy-MM-dd)
     * @param createdStart Loomise alguskuupäev (yyyy-MM-dd)
     * @param dateEnd Dokumendi kuupäeva lõpp (yyyy-MM-dd)
     * @param dateStart Dokumendi kuupäeva algus (yyyy-MM-dd)
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param reference Viit
     * @param reporterUuid Ettekandja UUID
     * @param sittingDateTimeEnd Seotud täiskogu istungi kuupäeva lõpp (yyyy-MM-dd)
     * @param sittingDateTimeStart Seotud täiskogu istungi kuupäeva algus (yyyy-MM-dd)
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subTypeCode Alamtüübi kood. Lubatud mitu väärtust.
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfOtherQuestions object
     */
    public Observable<ServiceResponse<PagedResourcesOfOtherQuestions>> findOtherQuestionsUsingGETWithServiceResponseAsync(String applicantUuid, LocalDate createdEnd, LocalDate createdStart, LocalDate dateEnd, LocalDate dateStart, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Boolean querySteno, String reference, String reporterUuid, LocalDate sittingDateTimeEnd, LocalDate sittingDateTimeStart, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, List<String> subTypeCode, String title, Boolean unpaged) {
        Validator.validate(sort);
        Validator.validate(subTypeCode);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);String subTypeCodeConverted = this.serializerAdapter().serializeList(subTypeCode, CollectionFormat.MULTI);
        return service.findOtherQuestionsUsingGET(applicantUuid, createdEnd, createdStart, dateEnd, dateStart, membership, offset, page, pageNumber, pageSize, paged, querySteno, reference, reporterUuid, sittingDateTimeEnd, sittingDateTimeStart, size, sortConverted, sortsorted, sortunsorted, subTypeCodeConverted, title, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfOtherQuestions>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfOtherQuestions>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfOtherQuestions> clientResponse = findOtherQuestionsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesOfOtherQuestions> findOtherQuestionsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesOfOtherQuestions, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesOfOtherQuestions>() { }.getType())
                .build(response);
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Document object if successful.
     */
    public Document getDocumentUsingGET(String uuid) {
        return getDocumentUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Document> getDocumentUsingGETAsync(String uuid, final ServiceCallback<Document> serviceCallback) {
        return ServiceFuture.fromResponse(getDocumentUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Document object
     */
    public Observable<Document> getDocumentUsingGETAsync(String uuid) {
        return getDocumentUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<Document>, Document>() {
            @Override
            public Document call(ServiceResponse<Document> response) {
                return response.body();
            }
        });
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Document object
     */
    public Observable<ServiceResponse<Document>> getDocumentUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getDocumentUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Document>>>() {
                @Override
                public Observable<ServiceResponse<Document>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Document> clientResponse = getDocumentUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Document object if successful.
     */
    public Document getDocumentUsingGET(String uuid, String lang) {
        return getDocumentUsingGETWithServiceResponseAsync(uuid, lang).toBlocking().single().body();
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Document> getDocumentUsingGETAsync(String uuid, String lang, final ServiceCallback<Document> serviceCallback) {
        return ServiceFuture.fromResponse(getDocumentUsingGETWithServiceResponseAsync(uuid, lang), serviceCallback);
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Document object
     */
    public Observable<Document> getDocumentUsingGETAsync(String uuid, String lang) {
        return getDocumentUsingGETWithServiceResponseAsync(uuid, lang).map(new Func1<ServiceResponse<Document>, Document>() {
            @Override
            public Document call(ServiceResponse<Document> response) {
                return response.body();
            }
        });
    }

    /**
     * Dokumendi detailid.
     *
     * @param uuid Dokumendi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Document object
     */
    public Observable<ServiceResponse<Document>> getDocumentUsingGETWithServiceResponseAsync(String uuid, String lang) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getDocumentUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Document>>>() {
                @Override
                public Observable<ServiceResponse<Document>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Document> clientResponse = getDocumentUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Document> getDocumentUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Document, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Document>() { }.getType())
                .build(response);
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Events&gt; object if successful.
     */
    public List<Events> getEventsUsingGET() {
        return getEventsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Events>> getEventsUsingGETAsync(final ServiceCallback<List<Events>> serviceCallback) {
        return ServiceFuture.fromResponse(getEventsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Events&gt; object
     */
    public Observable<List<Events>> getEventsUsingGETAsync() {
        return getEventsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Events>>, List<Events>>() {
            @Override
            public List<Events> call(ServiceResponse<List<Events>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Events&gt; object
     */
    public Observable<ServiceResponse<List<Events>>> getEventsUsingGETWithServiceResponseAsync() {
        final LocalDate dateParameter = null;
        final LocalDate endDate = null;
        final String lang = null;
        final Boolean querySteno = null;
        final LocalDate startDate = null;
        final String type = null;
        return service.getEventsUsingGET(dateParameter, endDate, lang, querySteno, startDate, type)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Events>>>>() {
                @Override
                public Observable<ServiceResponse<List<Events>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Events>> clientResponse = getEventsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille sündmusi soovitakse
     * @param endDate Kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param startDate Kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Events&gt; object if successful.
     */
    public List<Events> getEventsUsingGET(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate, String type) {
        return getEventsUsingGETWithServiceResponseAsync(dateParameter, endDate, lang, querySteno, startDate, type).toBlocking().single().body();
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille sündmusi soovitakse
     * @param endDate Kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param startDate Kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Events>> getEventsUsingGETAsync(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate, String type, final ServiceCallback<List<Events>> serviceCallback) {
        return ServiceFuture.fromResponse(getEventsUsingGETWithServiceResponseAsync(dateParameter, endDate, lang, querySteno, startDate, type), serviceCallback);
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille sündmusi soovitakse
     * @param endDate Kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param startDate Kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Events&gt; object
     */
    public Observable<List<Events>> getEventsUsingGETAsync(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate, String type) {
        return getEventsUsingGETWithServiceResponseAsync(dateParameter, endDate, lang, querySteno, startDate, type).map(new Func1<ServiceResponse<List<Events>>, List<Events>>() {
            @Override
            public List<Events> call(ServiceResponse<List<Events>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu ja komisjonide päevakorrad, Riigikogu liikmete lähetused ja visiidid.
     * Sündmusi saab pärida ühe nädala või suvalise ajavahemiku kohta, täites vastavalt 'date' või 'startDate/endDate' parameetrid.
     *
     * @param dateParameter Kuupäev nädalas, mille sündmusi soovitakse
     * @param endDate Kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid?
     * @param startDate Kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Events&gt; object
     */
    public Observable<ServiceResponse<List<Events>>> getEventsUsingGETWithServiceResponseAsync(LocalDate dateParameter, LocalDate endDate, String lang, Boolean querySteno, LocalDate startDate, String type) {
        return service.getEventsUsingGET(dateParameter, endDate, lang, querySteno, startDate, type)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Events>>>>() {
                @Override
                public Observable<ServiceResponse<List<Events>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Events>> clientResponse = getEventsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Events>> getEventsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Events>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Events>>() { }.getType())
                .build(response);
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EventCalendar&gt; object if successful.
     */
    public List<EventCalendar> getEventCalendarUsingGET(LocalDate endDate, LocalDate startDate) {
        return getEventCalendarUsingGETWithServiceResponseAsync(endDate, startDate).toBlocking().single().body();
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EventCalendar>> getEventCalendarUsingGETAsync(LocalDate endDate, LocalDate startDate, final ServiceCallback<List<EventCalendar>> serviceCallback) {
        return ServiceFuture.fromResponse(getEventCalendarUsingGETWithServiceResponseAsync(endDate, startDate), serviceCallback);
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EventCalendar&gt; object
     */
    public Observable<List<EventCalendar>> getEventCalendarUsingGETAsync(LocalDate endDate, LocalDate startDate) {
        return getEventCalendarUsingGETWithServiceResponseAsync(endDate, startDate).map(new Func1<ServiceResponse<List<EventCalendar>>, List<EventCalendar>>() {
            @Override
            public List<EventCalendar> call(ServiceResponse<List<EventCalendar>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EventCalendar&gt; object
     */
    public Observable<ServiceResponse<List<EventCalendar>>> getEventCalendarUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        final String committeeGroupUuid = null;
        final String type = null;
        return service.getEventCalendarUsingGET(committeeGroupUuid, endDate, startDate, type)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EventCalendar>>>>() {
                @Override
                public Observable<ServiceResponse<List<EventCalendar>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EventCalendar>> clientResponse = getEventCalendarUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param committeeGroupUuid Komisjoni UUID, mille päevakorra sündmusi soovitakse. Asjakohane kui "type=committee"
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;EventCalendar&gt; object if successful.
     */
    public List<EventCalendar> getEventCalendarUsingGET(LocalDate endDate, LocalDate startDate, String committeeGroupUuid, String type) {
        return getEventCalendarUsingGETWithServiceResponseAsync(endDate, startDate, committeeGroupUuid, type).toBlocking().single().body();
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param committeeGroupUuid Komisjoni UUID, mille päevakorra sündmusi soovitakse. Asjakohane kui "type=committee"
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<EventCalendar>> getEventCalendarUsingGETAsync(LocalDate endDate, LocalDate startDate, String committeeGroupUuid, String type, final ServiceCallback<List<EventCalendar>> serviceCallback) {
        return ServiceFuture.fromResponse(getEventCalendarUsingGETWithServiceResponseAsync(endDate, startDate, committeeGroupUuid, type), serviceCallback);
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param committeeGroupUuid Komisjoni UUID, mille päevakorra sündmusi soovitakse. Asjakohane kui "type=committee"
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EventCalendar&gt; object
     */
    public Observable<List<EventCalendar>> getEventCalendarUsingGETAsync(LocalDate endDate, LocalDate startDate, String committeeGroupUuid, String type) {
        return getEventCalendarUsingGETWithServiceResponseAsync(endDate, startDate, committeeGroupUuid, type).map(new Func1<ServiceResponse<List<EventCalendar>>, List<EventCalendar>>() {
            @Override
            public List<EventCalendar> call(ServiceResponse<List<EventCalendar>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kuupäevad, millal mõni sündmus on toimunud.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param committeeGroupUuid Komisjoni UUID, mille päevakorra sündmusi soovitakse. Asjakohane kui "type=committee"
     * @param type Sündmuse tüüp. Tühja korral kõik. Possible values include: 'PLENARY', 'COMMITTEE', 'SECONDMENTS', 'VISITS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;EventCalendar&gt; object
     */
    public Observable<ServiceResponse<List<EventCalendar>>> getEventCalendarUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String committeeGroupUuid, String type) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        return service.getEventCalendarUsingGET(committeeGroupUuid, endDate, startDate, type)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EventCalendar>>>>() {
                @Override
                public Observable<ServiceResponse<List<EventCalendar>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EventCalendar>> clientResponse = getEventCalendarUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<EventCalendar>> getEventCalendarUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<EventCalendar>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<EventCalendar>>() { }.getType())
                .build(response);
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FileMetadata object if successful.
     */
    public FileMetadata getFileMetadataUsingGET(String uuid) {
        return getFileMetadataUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FileMetadata> getFileMetadataUsingGETAsync(String uuid, final ServiceCallback<FileMetadata> serviceCallback) {
        return ServiceFuture.fromResponse(getFileMetadataUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FileMetadata object
     */
    public Observable<FileMetadata> getFileMetadataUsingGETAsync(String uuid) {
        return getFileMetadataUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<FileMetadata>, FileMetadata>() {
            @Override
            public FileMetadata call(ServiceResponse<FileMetadata> response) {
                return response.body();
            }
        });
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FileMetadata object
     */
    public Observable<ServiceResponse<FileMetadata>> getFileMetadataUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getFileMetadataUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FileMetadata>>>() {
                @Override
                public Observable<ServiceResponse<FileMetadata>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FileMetadata> clientResponse = getFileMetadataUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FileMetadata object if successful.
     */
    public FileMetadata getFileMetadataUsingGET(String uuid, String lang) {
        return getFileMetadataUsingGETWithServiceResponseAsync(uuid, lang).toBlocking().single().body();
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FileMetadata> getFileMetadataUsingGETAsync(String uuid, String lang, final ServiceCallback<FileMetadata> serviceCallback) {
        return ServiceFuture.fromResponse(getFileMetadataUsingGETWithServiceResponseAsync(uuid, lang), serviceCallback);
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FileMetadata object
     */
    public Observable<FileMetadata> getFileMetadataUsingGETAsync(String uuid, String lang) {
        return getFileMetadataUsingGETWithServiceResponseAsync(uuid, lang).map(new Func1<ServiceResponse<FileMetadata>, FileMetadata>() {
            @Override
            public FileMetadata call(ServiceResponse<FileMetadata> response) {
                return response.body();
            }
        });
    }

    /**
     * Faili metaandmed.
     *
     * @param uuid Faili UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FileMetadata object
     */
    public Observable<ServiceResponse<FileMetadata>> getFileMetadataUsingGETWithServiceResponseAsync(String uuid, String lang) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getFileMetadataUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FileMetadata>>>() {
                @Override
                public Observable<ServiceResponse<FileMetadata>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FileMetadata> clientResponse = getFileMetadataUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FileMetadata> getFileMetadataUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<FileMetadata, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<FileMetadata>() { }.getType())
                .build(response);
    }

    /**
     * Faili allalaadimine.
     *
     * @param uuid Faili UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the byte[] object if successful.
     */
    public byte[] downloadFileUsingGET(String uuid) {
        return downloadFileUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Faili allalaadimine.
     *
     * @param uuid Faili UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<byte[]> downloadFileUsingGETAsync(String uuid, final ServiceCallback<byte[]> serviceCallback) {
        return ServiceFuture.fromResponse(downloadFileUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Faili allalaadimine.
     *
     * @param uuid Faili UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the byte[] object
     */
    public Observable<byte[]> downloadFileUsingGETAsync(String uuid) {
        return downloadFileUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<byte[]>, byte[]>() {
            @Override
            public byte[] call(ServiceResponse<byte[]> response) {
                return response.body();
            }
        });
    }

    /**
     * Faili allalaadimine.
     *
     * @param uuid Faili UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the byte[] object
     */
    public Observable<ServiceResponse<byte[]>> downloadFileUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.downloadFileUsingGET(uuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<byte[]>>>() {
                @Override
                public Observable<ServiceResponse<byte[]>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<byte[]> clientResponse = downloadFileUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<byte[]> downloadFileUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<byte[], RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<byte[]>() { }.getType())
                .build(response);
    }

    /**
     * Saaliplaan.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Hallplan&gt; object if successful.
     */
    public List<Hallplan> getLatestHallplanUsingGET() {
        return getLatestHallplanUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Saaliplaan.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Hallplan>> getLatestHallplanUsingGETAsync(final ServiceCallback<List<Hallplan>> serviceCallback) {
        return ServiceFuture.fromResponse(getLatestHallplanUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Saaliplaan.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Hallplan&gt; object
     */
    public Observable<List<Hallplan>> getLatestHallplanUsingGETAsync() {
        return getLatestHallplanUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Hallplan>>, List<Hallplan>>() {
            @Override
            public List<Hallplan> call(ServiceResponse<List<Hallplan>> response) {
                return response.body();
            }
        });
    }

    /**
     * Saaliplaan.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Hallplan&gt; object
     */
    public Observable<ServiceResponse<List<Hallplan>>> getLatestHallplanUsingGETWithServiceResponseAsync() {
        final String lang = null;
        return service.getLatestHallplanUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Hallplan>>>>() {
                @Override
                public Observable<ServiceResponse<List<Hallplan>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Hallplan>> clientResponse = getLatestHallplanUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Saaliplaan.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Hallplan&gt; object if successful.
     */
    public List<Hallplan> getLatestHallplanUsingGET(String lang) {
        return getLatestHallplanUsingGETWithServiceResponseAsync(lang).toBlocking().single().body();
    }

    /**
     * Saaliplaan.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Hallplan>> getLatestHallplanUsingGETAsync(String lang, final ServiceCallback<List<Hallplan>> serviceCallback) {
        return ServiceFuture.fromResponse(getLatestHallplanUsingGETWithServiceResponseAsync(lang), serviceCallback);
    }

    /**
     * Saaliplaan.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Hallplan&gt; object
     */
    public Observable<List<Hallplan>> getLatestHallplanUsingGETAsync(String lang) {
        return getLatestHallplanUsingGETWithServiceResponseAsync(lang).map(new Func1<ServiceResponse<List<Hallplan>>, List<Hallplan>>() {
            @Override
            public List<Hallplan> call(ServiceResponse<List<Hallplan>> response) {
                return response.body();
            }
        });
    }

    /**
     * Saaliplaan.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Hallplan&gt; object
     */
    public Observable<ServiceResponse<List<Hallplan>>> getLatestHallplanUsingGETWithServiceResponseAsync(String lang) {
        return service.getLatestHallplanUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Hallplan>>>>() {
                @Override
                public Observable<ServiceResponse<List<Hallplan>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Hallplan>> clientResponse = getLatestHallplanUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Hallplan>> getLatestHallplanUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Hallplan>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Hallplan>>() { }.getType())
                .build(response);
    }

    /**
     * Dokumendipuu (hierarhia).
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DocumentTree&gt; object if successful.
     */
    public List<DocumentTree> getDocumentTreeUsingGET() {
        return getDocumentTreeUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Dokumendipuu (hierarhia).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DocumentTree>> getDocumentTreeUsingGETAsync(final ServiceCallback<List<DocumentTree>> serviceCallback) {
        return ServiceFuture.fromResponse(getDocumentTreeUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Dokumendipuu (hierarhia).
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DocumentTree&gt; object
     */
    public Observable<List<DocumentTree>> getDocumentTreeUsingGETAsync() {
        return getDocumentTreeUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<DocumentTree>>, List<DocumentTree>>() {
            @Override
            public List<DocumentTree> call(ServiceResponse<List<DocumentTree>> response) {
                return response.body();
            }
        });
    }

    /**
     * Dokumendipuu (hierarhia).
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DocumentTree&gt; object
     */
    public Observable<ServiceResponse<List<DocumentTree>>> getDocumentTreeUsingGETWithServiceResponseAsync() {
        return service.getDocumentTreeUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DocumentTree>>>>() {
                @Override
                public Observable<ServiceResponse<List<DocumentTree>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DocumentTree>> clientResponse = getDocumentTreeUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DocumentTree>> getDocumentTreeUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<DocumentTree>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DocumentTree>>() { }.getType())
                .build(response);
    }

    /**
     * Dokumendi liigid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DocumentTypes&gt; object if successful.
     */
    public List<DocumentTypes> getDocumentTypesUsingGET() {
        return getDocumentTypesUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Dokumendi liigid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DocumentTypes>> getDocumentTypesUsingGETAsync(final ServiceCallback<List<DocumentTypes>> serviceCallback) {
        return ServiceFuture.fromResponse(getDocumentTypesUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Dokumendi liigid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DocumentTypes&gt; object
     */
    public Observable<List<DocumentTypes>> getDocumentTypesUsingGETAsync() {
        return getDocumentTypesUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<DocumentTypes>>, List<DocumentTypes>>() {
            @Override
            public List<DocumentTypes> call(ServiceResponse<List<DocumentTypes>> response) {
                return response.body();
            }
        });
    }

    /**
     * Dokumendi liigid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DocumentTypes&gt; object
     */
    public Observable<ServiceResponse<List<DocumentTypes>>> getDocumentTypesUsingGETWithServiceResponseAsync() {
        return service.getDocumentTypesUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DocumentTypes>>>>() {
                @Override
                public Observable<ServiceResponse<List<DocumentTypes>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DocumentTypes>> clientResponse = getDocumentTypesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DocumentTypes>> getDocumentTypesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<DocumentTypes>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DocumentTypes>>() { }.getType())
                .build(response);
    }

    /**
     * Eelnõu algatajad.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DraftInitiators&gt; object if successful.
     */
    public List<DraftInitiators> getDraftInitiatorsUsingGET() {
        return getDraftInitiatorsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Eelnõu algatajad.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DraftInitiators>> getDraftInitiatorsUsingGETAsync(final ServiceCallback<List<DraftInitiators>> serviceCallback) {
        return ServiceFuture.fromResponse(getDraftInitiatorsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Eelnõu algatajad.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DraftInitiators&gt; object
     */
    public Observable<List<DraftInitiators>> getDraftInitiatorsUsingGETAsync() {
        return getDraftInitiatorsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<DraftInitiators>>, List<DraftInitiators>>() {
            @Override
            public List<DraftInitiators> call(ServiceResponse<List<DraftInitiators>> response) {
                return response.body();
            }
        });
    }

    /**
     * Eelnõu algatajad.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DraftInitiators&gt; object
     */
    public Observable<ServiceResponse<List<DraftInitiators>>> getDraftInitiatorsUsingGETWithServiceResponseAsync() {
        return service.getDraftInitiatorsUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DraftInitiators>>>>() {
                @Override
                public Observable<ServiceResponse<List<DraftInitiators>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DraftInitiators>> clientResponse = getDraftInitiatorsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DraftInitiators>> getDraftInitiatorsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<DraftInitiators>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DraftInitiators>>() { }.getType())
                .build(response);
    }

    /**
     * Toimiku liigid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;VolumeTypes&gt; object if successful.
     */
    public List<VolumeTypes> getVolumeTypesUsingGET() {
        return getVolumeTypesUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Toimiku liigid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<VolumeTypes>> getVolumeTypesUsingGETAsync(final ServiceCallback<List<VolumeTypes>> serviceCallback) {
        return ServiceFuture.fromResponse(getVolumeTypesUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Toimiku liigid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;VolumeTypes&gt; object
     */
    public Observable<List<VolumeTypes>> getVolumeTypesUsingGETAsync() {
        return getVolumeTypesUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<VolumeTypes>>, List<VolumeTypes>>() {
            @Override
            public List<VolumeTypes> call(ServiceResponse<List<VolumeTypes>> response) {
                return response.body();
            }
        });
    }

    /**
     * Toimiku liigid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;VolumeTypes&gt; object
     */
    public Observable<ServiceResponse<List<VolumeTypes>>> getVolumeTypesUsingGETWithServiceResponseAsync() {
        return service.getVolumeTypesUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VolumeTypes>>>>() {
                @Override
                public Observable<ServiceResponse<List<VolumeTypes>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VolumeTypes>> clientResponse = getVolumeTypesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VolumeTypes>> getVolumeTypesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<VolumeTypes>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<VolumeTypes>>() { }.getType())
                .build(response);
    }

    /**
     * Kõik koosseisud.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Membership&gt; object if successful.
     */
    public List<Membership> getMembershipsUsingGET() {
        return getMembershipsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Kõik koosseisud.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Membership>> getMembershipsUsingGETAsync(final ServiceCallback<List<Membership>> serviceCallback) {
        return ServiceFuture.fromResponse(getMembershipsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Kõik koosseisud.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Membership&gt; object
     */
    public Observable<List<Membership>> getMembershipsUsingGETAsync() {
        return getMembershipsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Membership>>, List<Membership>>() {
            @Override
            public List<Membership> call(ServiceResponse<List<Membership>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kõik koosseisud.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Membership&gt; object
     */
    public Observable<ServiceResponse<List<Membership>>> getMembershipsUsingGETWithServiceResponseAsync() {
        return service.getMembershipsUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Membership>>>>() {
                @Override
                public Observable<ServiceResponse<List<Membership>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Membership>> clientResponse = getMembershipsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Membership>> getMembershipsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Membership>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Membership>>() { }.getType())
                .build(response);
    }

    /**
     * Praegune koosseis.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Membership object if successful.
     */
    public Membership getCurrentMembershipUsingGET() {
        return getCurrentMembershipUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Praegune koosseis.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Membership> getCurrentMembershipUsingGETAsync(final ServiceCallback<Membership> serviceCallback) {
        return ServiceFuture.fromResponse(getCurrentMembershipUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Praegune koosseis.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Membership object
     */
    public Observable<Membership> getCurrentMembershipUsingGETAsync() {
        return getCurrentMembershipUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<Membership>, Membership>() {
            @Override
            public Membership call(ServiceResponse<Membership> response) {
                return response.body();
            }
        });
    }

    /**
     * Praegune koosseis.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Membership object
     */
    public Observable<ServiceResponse<Membership>> getCurrentMembershipUsingGETWithServiceResponseAsync() {
        return service.getCurrentMembershipUsingGET()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Membership>>>() {
                @Override
                public Observable<ServiceResponse<Membership>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Membership> clientResponse = getCurrentMembershipUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Membership> getCurrentMembershipUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Membership, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Membership>() { }.getType())
                .build(response);
    }

    /**
     * Koosseis.
     *
     * @param number Koosseisu number
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Membership object if successful.
     */
    public Membership getMembershipUsingGET(int number) {
        return getMembershipUsingGETWithServiceResponseAsync(number).toBlocking().single().body();
    }

    /**
     * Koosseis.
     *
     * @param number Koosseisu number
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Membership> getMembershipUsingGETAsync(int number, final ServiceCallback<Membership> serviceCallback) {
        return ServiceFuture.fromResponse(getMembershipUsingGETWithServiceResponseAsync(number), serviceCallback);
    }

    /**
     * Koosseis.
     *
     * @param number Koosseisu number
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Membership object
     */
    public Observable<Membership> getMembershipUsingGETAsync(int number) {
        return getMembershipUsingGETWithServiceResponseAsync(number).map(new Func1<ServiceResponse<Membership>, Membership>() {
            @Override
            public Membership call(ServiceResponse<Membership> response) {
                return response.body();
            }
        });
    }

    /**
     * Koosseis.
     *
     * @param number Koosseisu number
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Membership object
     */
    public Observable<ServiceResponse<Membership>> getMembershipUsingGETWithServiceResponseAsync(int number) {
        return service.getMembershipUsingGET(number)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Membership>>>() {
                @Override
                public Observable<ServiceResponse<Membership>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Membership> clientResponse = getMembershipUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Membership> getMembershipUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Membership, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Membership>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PlenaryMember&gt; object if successful.
     */
    public List<PlenaryMember> getPlenaryMembersUsingGET() {
        return getPlenaryMembersUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PlenaryMember>> getPlenaryMembersUsingGETAsync(final ServiceCallback<List<PlenaryMember>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryMembersUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenaryMember&gt; object
     */
    public Observable<List<PlenaryMember>> getPlenaryMembersUsingGETAsync() {
        return getPlenaryMembersUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<PlenaryMember>>, List<PlenaryMember>>() {
            @Override
            public List<PlenaryMember> call(ServiceResponse<List<PlenaryMember>> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenaryMember&gt; object
     */
    public Observable<ServiceResponse<List<PlenaryMember>>> getPlenaryMembersUsingGETWithServiceResponseAsync() {
        final List<String> committeeUuid = null;
        final List<String> electoralDistrictCodes = null;
        final List<String> factionUuid = null;
        final Boolean includeInactive = null;
        final String lang = null;
        final Integer membership = null;
        final String name = null;
        String committeeUuidConverted = this.serializerAdapter().serializeList(committeeUuid, CollectionFormat.MULTI);String electoralDistrictCodesConverted = this.serializerAdapter().serializeList(electoralDistrictCodes, CollectionFormat.MULTI);String factionUuidConverted = this.serializerAdapter().serializeList(factionUuid, CollectionFormat.MULTI);
        return service.getPlenaryMembersUsingGET(committeeUuidConverted, electoralDistrictCodesConverted, factionUuidConverted, includeInactive, lang, membership, name)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PlenaryMember>>>>() {
                @Override
                public Observable<ServiceResponse<List<PlenaryMember>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PlenaryMember>> clientResponse = getPlenaryMembersUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @param committeeUuid Komisjoni UUID. Lubatud mitu väärtust
     * @param electoralDistrictCodes Valimisringkonna kood (klassifikaator 'valimisringkond'). Lubatud mitu väärtust
     * @param factionUuid Fraktsiooni UUID. Lubatud mitu väärtust
     * @param includeInactive Kaasa mitteaktiivsed liikmed
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseis
     * @param name Liikme nimi. Otsitakse otsisõna sisaldumist nii ees- kui perekonnanimes
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PlenaryMember&gt; object if successful.
     */
    public List<PlenaryMember> getPlenaryMembersUsingGET(List<String> committeeUuid, List<String> electoralDistrictCodes, List<String> factionUuid, Boolean includeInactive, String lang, Integer membership, String name) {
        return getPlenaryMembersUsingGETWithServiceResponseAsync(committeeUuid, electoralDistrictCodes, factionUuid, includeInactive, lang, membership, name).toBlocking().single().body();
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @param committeeUuid Komisjoni UUID. Lubatud mitu väärtust
     * @param electoralDistrictCodes Valimisringkonna kood (klassifikaator 'valimisringkond'). Lubatud mitu väärtust
     * @param factionUuid Fraktsiooni UUID. Lubatud mitu väärtust
     * @param includeInactive Kaasa mitteaktiivsed liikmed
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseis
     * @param name Liikme nimi. Otsitakse otsisõna sisaldumist nii ees- kui perekonnanimes
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PlenaryMember>> getPlenaryMembersUsingGETAsync(List<String> committeeUuid, List<String> electoralDistrictCodes, List<String> factionUuid, Boolean includeInactive, String lang, Integer membership, String name, final ServiceCallback<List<PlenaryMember>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryMembersUsingGETWithServiceResponseAsync(committeeUuid, electoralDistrictCodes, factionUuid, includeInactive, lang, membership, name), serviceCallback);
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @param committeeUuid Komisjoni UUID. Lubatud mitu väärtust
     * @param electoralDistrictCodes Valimisringkonna kood (klassifikaator 'valimisringkond'). Lubatud mitu väärtust
     * @param factionUuid Fraktsiooni UUID. Lubatud mitu väärtust
     * @param includeInactive Kaasa mitteaktiivsed liikmed
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseis
     * @param name Liikme nimi. Otsitakse otsisõna sisaldumist nii ees- kui perekonnanimes
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenaryMember&gt; object
     */
    public Observable<List<PlenaryMember>> getPlenaryMembersUsingGETAsync(List<String> committeeUuid, List<String> electoralDistrictCodes, List<String> factionUuid, Boolean includeInactive, String lang, Integer membership, String name) {
        return getPlenaryMembersUsingGETWithServiceResponseAsync(committeeUuid, electoralDistrictCodes, factionUuid, includeInactive, lang, membership, name).map(new Func1<ServiceResponse<List<PlenaryMember>>, List<PlenaryMember>>() {
            @Override
            public List<PlenaryMember> call(ServiceResponse<List<PlenaryMember>> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikmete nimekiri / otsing.
     *
     * @param committeeUuid Komisjoni UUID. Lubatud mitu väärtust
     * @param electoralDistrictCodes Valimisringkonna kood (klassifikaator 'valimisringkond'). Lubatud mitu väärtust
     * @param factionUuid Fraktsiooni UUID. Lubatud mitu väärtust
     * @param includeInactive Kaasa mitteaktiivsed liikmed
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseis
     * @param name Liikme nimi. Otsitakse otsisõna sisaldumist nii ees- kui perekonnanimes
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenaryMember&gt; object
     */
    public Observable<ServiceResponse<List<PlenaryMember>>> getPlenaryMembersUsingGETWithServiceResponseAsync(List<String> committeeUuid, List<String> electoralDistrictCodes, List<String> factionUuid, Boolean includeInactive, String lang, Integer membership, String name) {
        Validator.validate(committeeUuid);
        Validator.validate(electoralDistrictCodes);
        Validator.validate(factionUuid);
        String committeeUuidConverted = this.serializerAdapter().serializeList(committeeUuid, CollectionFormat.MULTI);String electoralDistrictCodesConverted = this.serializerAdapter().serializeList(electoralDistrictCodes, CollectionFormat.MULTI);String factionUuidConverted = this.serializerAdapter().serializeList(factionUuid, CollectionFormat.MULTI);
        return service.getPlenaryMembersUsingGET(committeeUuidConverted, electoralDistrictCodesConverted, factionUuidConverted, includeInactive, lang, membership, name)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PlenaryMember>>>>() {
                @Override
                public Observable<ServiceResponse<List<PlenaryMember>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PlenaryMember>> clientResponse = getPlenaryMembersUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PlenaryMember>> getPlenaryMembersUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<PlenaryMember>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<PlenaryMember>>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PlenaryMemberDetails object if successful.
     */
    public PlenaryMemberDetails getPlenaryMemberDetailsUsingGET(String uuid) {
        return getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PlenaryMemberDetails> getPlenaryMemberDetailsUsingGETAsync(String uuid, final ServiceCallback<PlenaryMemberDetails> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryMemberDetails object
     */
    public Observable<PlenaryMemberDetails> getPlenaryMemberDetailsUsingGETAsync(String uuid) {
        return getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<PlenaryMemberDetails>, PlenaryMemberDetails>() {
            @Override
            public PlenaryMemberDetails call(ServiceResponse<PlenaryMemberDetails> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryMemberDetails object
     */
    public Observable<ServiceResponse<PlenaryMemberDetails>> getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        final Boolean querySteno = null;
        return service.getPlenaryMemberDetailsUsingGET(uuid, lang, querySteno)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PlenaryMemberDetails>>>() {
                @Override
                public Observable<ServiceResponse<PlenaryMemberDetails>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PlenaryMemberDetails> clientResponse = getPlenaryMemberDetailsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest liikme viimane kõne? (true/false)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PlenaryMemberDetails object if successful.
     */
    public PlenaryMemberDetails getPlenaryMemberDetailsUsingGET(String uuid, String lang, Boolean querySteno) {
        return getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(uuid, lang, querySteno).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest liikme viimane kõne? (true/false)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PlenaryMemberDetails> getPlenaryMemberDetailsUsingGETAsync(String uuid, String lang, Boolean querySteno, final ServiceCallback<PlenaryMemberDetails> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(uuid, lang, querySteno), serviceCallback);
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest liikme viimane kõne? (true/false)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryMemberDetails object
     */
    public Observable<PlenaryMemberDetails> getPlenaryMemberDetailsUsingGETAsync(String uuid, String lang, Boolean querySteno) {
        return getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(uuid, lang, querySteno).map(new Func1<ServiceResponse<PlenaryMemberDetails>, PlenaryMemberDetails>() {
            @Override
            public PlenaryMemberDetails call(ServiceResponse<PlenaryMemberDetails> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme detailid.
     *
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest liikme viimane kõne? (true/false)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryMemberDetails object
     */
    public Observable<ServiceResponse<PlenaryMemberDetails>> getPlenaryMemberDetailsUsingGETWithServiceResponseAsync(String uuid, String lang, Boolean querySteno) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getPlenaryMemberDetailsUsingGET(uuid, lang, querySteno)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PlenaryMemberDetails>>>() {
                @Override
                public Observable<ServiceResponse<PlenaryMemberDetails>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PlenaryMemberDetails> clientResponse = getPlenaryMemberDetailsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PlenaryMemberDetails> getPlenaryMemberDetailsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PlenaryMemberDetails, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PlenaryMemberDetails>() { }.getType())
                .build(response);
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Session&gt; object if successful.
     */
    public List<Session> getSessionsUsingGET() {
        return getSessionsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Session>> getSessionsUsingGETAsync(final ServiceCallback<List<Session>> serviceCallback) {
        return ServiceFuture.fromResponse(getSessionsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Session&gt; object
     */
    public Observable<List<Session>> getSessionsUsingGETAsync() {
        return getSessionsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Session>>, List<Session>>() {
            @Override
            public List<Session> call(ServiceResponse<List<Session>> response) {
                return response.body();
            }
        });
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Session&gt; object
     */
    public Observable<ServiceResponse<List<Session>>> getSessionsUsingGETWithServiceResponseAsync() {
        final String lang = null;
        return service.getSessionsUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Session>>>>() {
                @Override
                public Observable<ServiceResponse<List<Session>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Session>> clientResponse = getSessionsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Session&gt; object if successful.
     */
    public List<Session> getSessionsUsingGET(String lang) {
        return getSessionsUsingGETWithServiceResponseAsync(lang).toBlocking().single().body();
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Session>> getSessionsUsingGETAsync(String lang, final ServiceCallback<List<Session>> serviceCallback) {
        return ServiceFuture.fromResponse(getSessionsUsingGETWithServiceResponseAsync(lang), serviceCallback);
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Session&gt; object
     */
    public Observable<List<Session>> getSessionsUsingGETAsync(String lang) {
        return getSessionsUsingGETWithServiceResponseAsync(lang).map(new Func1<ServiceResponse<List<Session>>, List<Session>>() {
            @Override
            public List<Session> call(ServiceResponse<List<Session>> response) {
                return response.body();
            }
        });
    }

    /**
     * Istungjärkude nimekiri.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Session&gt; object
     */
    public Observable<ServiceResponse<List<Session>>> getSessionsUsingGETWithServiceResponseAsync(String lang) {
        return service.getSessionsUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Session>>>>() {
                @Override
                public Observable<ServiceResponse<List<Session>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Session>> clientResponse = getSessionsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Session>> getSessionsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<Session>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<Session>>() { }.getType())
                .build(response);
    }

    /**
     * Praegune istungjärk.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Session object if successful.
     */
    public Session getCurrentSessionUsingGET() {
        return getCurrentSessionUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Praegune istungjärk.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Session> getCurrentSessionUsingGETAsync(final ServiceCallback<Session> serviceCallback) {
        return ServiceFuture.fromResponse(getCurrentSessionUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Praegune istungjärk.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Session object
     */
    public Observable<Session> getCurrentSessionUsingGETAsync() {
        return getCurrentSessionUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<Session>, Session>() {
            @Override
            public Session call(ServiceResponse<Session> response) {
                return response.body();
            }
        });
    }

    /**
     * Praegune istungjärk.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Session object
     */
    public Observable<ServiceResponse<Session>> getCurrentSessionUsingGETWithServiceResponseAsync() {
        final String lang = null;
        return service.getCurrentSessionUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Session>>>() {
                @Override
                public Observable<ServiceResponse<Session>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Session> clientResponse = getCurrentSessionUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Praegune istungjärk.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Session object if successful.
     */
    public Session getCurrentSessionUsingGET(String lang) {
        return getCurrentSessionUsingGETWithServiceResponseAsync(lang).toBlocking().single().body();
    }

    /**
     * Praegune istungjärk.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Session> getCurrentSessionUsingGETAsync(String lang, final ServiceCallback<Session> serviceCallback) {
        return ServiceFuture.fromResponse(getCurrentSessionUsingGETWithServiceResponseAsync(lang), serviceCallback);
    }

    /**
     * Praegune istungjärk.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Session object
     */
    public Observable<Session> getCurrentSessionUsingGETAsync(String lang) {
        return getCurrentSessionUsingGETWithServiceResponseAsync(lang).map(new Func1<ServiceResponse<Session>, Session>() {
            @Override
            public Session call(ServiceResponse<Session> response) {
                return response.body();
            }
        });
    }

    /**
     * Praegune istungjärk.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Session object
     */
    public Observable<ServiceResponse<Session>> getCurrentSessionUsingGETWithServiceResponseAsync(String lang) {
        return service.getCurrentSessionUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Session>>>() {
                @Override
                public Observable<ServiceResponse<Session>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Session> clientResponse = getCurrentSessionUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Session> getCurrentSessionUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Session, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Session>() { }.getType())
                .build(response);
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;MemberParticipation&gt; object if successful.
     */
    public List<MemberParticipation> getFactionParticipationUsingGET(LocalDate endDate, LocalDate startDate, String uuid) {
        return getFactionParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid).toBlocking().single().body();
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MemberParticipation>> getFactionParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, final ServiceCallback<List<MemberParticipation>> serviceCallback) {
        return ServiceFuture.fromResponse(getFactionParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid), serviceCallback);
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;MemberParticipation&gt; object
     */
    public Observable<List<MemberParticipation>> getFactionParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        return getFactionParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid).map(new Func1<ServiceResponse<List<MemberParticipation>>, List<MemberParticipation>>() {
            @Override
            public List<MemberParticipation> call(ServiceResponse<List<MemberParticipation>> response) {
                return response.body();
            }
        });
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;MemberParticipation&gt; object
     */
    public Observable<ServiceResponse<List<MemberParticipation>>> getFactionParticipationUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getFactionParticipationUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<MemberParticipation>>>>() {
                @Override
                public Observable<ServiceResponse<List<MemberParticipation>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<MemberParticipation>> clientResponse = getFactionParticipationUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;MemberParticipation&gt; object if successful.
     */
    public List<MemberParticipation> getFactionParticipationUsingGET(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getFactionParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).toBlocking().single().body();
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MemberParticipation>> getFactionParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang, final ServiceCallback<List<MemberParticipation>> serviceCallback) {
        return ServiceFuture.fromResponse(getFactionParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang), serviceCallback);
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;MemberParticipation&gt; object
     */
    public Observable<List<MemberParticipation>> getFactionParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getFactionParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).map(new Func1<ServiceResponse<List<MemberParticipation>>, List<MemberParticipation>>() {
            @Override
            public List<MemberParticipation> call(ServiceResponse<List<MemberParticipation>> response) {
                return response.body();
            }
        });
    }

    /**
     * Fraktsiooni istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;MemberParticipation&gt; object
     */
    public Observable<ServiceResponse<List<MemberParticipation>>> getFactionParticipationUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getFactionParticipationUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<MemberParticipation>>>>() {
                @Override
                public Observable<ServiceResponse<List<MemberParticipation>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<MemberParticipation>> clientResponse = getFactionParticipationUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<MemberParticipation>> getFactionParticipationUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<MemberParticipation>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<MemberParticipation>>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MemberParticipation object if successful.
     */
    public MemberParticipation getMemberParticipationUsingGET(LocalDate endDate, LocalDate startDate, String uuid) {
        return getMemberParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MemberParticipation> getMemberParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, final ServiceCallback<MemberParticipation> serviceCallback) {
        return ServiceFuture.fromResponse(getMemberParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid), serviceCallback);
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MemberParticipation object
     */
    public Observable<MemberParticipation> getMemberParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        return getMemberParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid).map(new Func1<ServiceResponse<MemberParticipation>, MemberParticipation>() {
            @Override
            public MemberParticipation call(ServiceResponse<MemberParticipation> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MemberParticipation object
     */
    public Observable<ServiceResponse<MemberParticipation>> getMemberParticipationUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final Boolean details = null;
        final String lang = null;
        return service.getMemberParticipationUsingGET(uuid, details, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MemberParticipation>>>() {
                @Override
                public Observable<ServiceResponse<MemberParticipation>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MemberParticipation> clientResponse = getMemberParticipationUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param details details
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the MemberParticipation object if successful.
     */
    public MemberParticipation getMemberParticipationUsingGET(LocalDate endDate, LocalDate startDate, String uuid, Boolean details, String lang) {
        return getMemberParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid, details, lang).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param details details
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<MemberParticipation> getMemberParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, Boolean details, String lang, final ServiceCallback<MemberParticipation> serviceCallback) {
        return ServiceFuture.fromResponse(getMemberParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid, details, lang), serviceCallback);
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param details details
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MemberParticipation object
     */
    public Observable<MemberParticipation> getMemberParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, Boolean details, String lang) {
        return getMemberParticipationUsingGETWithServiceResponseAsync(endDate, startDate, uuid, details, lang).map(new Func1<ServiceResponse<MemberParticipation>, MemberParticipation>() {
            @Override
            public MemberParticipation call(ServiceResponse<MemberParticipation> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param details details
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the MemberParticipation object
     */
    public Observable<ServiceResponse<MemberParticipation>> getMemberParticipationUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid, Boolean details, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getMemberParticipationUsingGET(uuid, details, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<MemberParticipation>>>() {
                @Override
                public Observable<ServiceResponse<MemberParticipation>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<MemberParticipation> clientResponse = getMemberParticipationUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<MemberParticipation> getMemberParticipationUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<MemberParticipation, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<MemberParticipation>() { }.getType())
                .build(response);
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;MemberParticipation&gt; object if successful.
     */
    public List<MemberParticipation> getPlenaryParticipationUsingGET(LocalDate endDate, LocalDate startDate) {
        return getPlenaryParticipationUsingGETWithServiceResponseAsync(endDate, startDate).toBlocking().single().body();
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MemberParticipation>> getPlenaryParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, final ServiceCallback<List<MemberParticipation>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryParticipationUsingGETWithServiceResponseAsync(endDate, startDate), serviceCallback);
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;MemberParticipation&gt; object
     */
    public Observable<List<MemberParticipation>> getPlenaryParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate) {
        return getPlenaryParticipationUsingGETWithServiceResponseAsync(endDate, startDate).map(new Func1<ServiceResponse<List<MemberParticipation>>, List<MemberParticipation>>() {
            @Override
            public List<MemberParticipation> call(ServiceResponse<List<MemberParticipation>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;MemberParticipation&gt; object
     */
    public Observable<ServiceResponse<List<MemberParticipation>>> getPlenaryParticipationUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        final String lang = null;
        return service.getPlenaryParticipationUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<MemberParticipation>>>>() {
                @Override
                public Observable<ServiceResponse<List<MemberParticipation>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<MemberParticipation>> clientResponse = getPlenaryParticipationUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;MemberParticipation&gt; object if successful.
     */
    public List<MemberParticipation> getPlenaryParticipationUsingGET(LocalDate endDate, LocalDate startDate, String lang) {
        return getPlenaryParticipationUsingGETWithServiceResponseAsync(endDate, startDate, lang).toBlocking().single().body();
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<MemberParticipation>> getPlenaryParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang, final ServiceCallback<List<MemberParticipation>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryParticipationUsingGETWithServiceResponseAsync(endDate, startDate, lang), serviceCallback);
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;MemberParticipation&gt; object
     */
    public Observable<List<MemberParticipation>> getPlenaryParticipationUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang) {
        return getPlenaryParticipationUsingGETWithServiceResponseAsync(endDate, startDate, lang).map(new Func1<ServiceResponse<List<MemberParticipation>>, List<MemberParticipation>>() {
            @Override
            public List<MemberParticipation> call(ServiceResponse<List<MemberParticipation>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu istungitest osavõtu statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;MemberParticipation&gt; object
     */
    public Observable<ServiceResponse<List<MemberParticipation>>> getPlenaryParticipationUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        return service.getPlenaryParticipationUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<MemberParticipation>>>>() {
                @Override
                public Observable<ServiceResponse<List<MemberParticipation>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<MemberParticipation>> clientResponse = getPlenaryParticipationUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<MemberParticipation>> getPlenaryParticipationUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<MemberParticipation>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<MemberParticipation>>() { }.getType())
                .build(response);
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FactionSpeech&gt; object if successful.
     */
    public List<FactionSpeech> getFactionSpeechStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid) {
        return getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).toBlocking().single().body();
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FactionSpeech>> getFactionSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, final ServiceCallback<List<FactionSpeech>> serviceCallback) {
        return ServiceFuture.fromResponse(getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid), serviceCallback);
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FactionSpeech&gt; object
     */
    public Observable<List<FactionSpeech>> getFactionSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        return getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).map(new Func1<ServiceResponse<List<FactionSpeech>>, List<FactionSpeech>>() {
            @Override
            public List<FactionSpeech> call(ServiceResponse<List<FactionSpeech>> response) {
                return response.body();
            }
        });
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FactionSpeech&gt; object
     */
    public Observable<ServiceResponse<List<FactionSpeech>>> getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getFactionSpeechStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FactionSpeech>>>>() {
                @Override
                public Observable<ServiceResponse<List<FactionSpeech>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FactionSpeech>> clientResponse = getFactionSpeechStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FactionSpeech&gt; object if successful.
     */
    public List<FactionSpeech> getFactionSpeechStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).toBlocking().single().body();
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FactionSpeech>> getFactionSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang, final ServiceCallback<List<FactionSpeech>> serviceCallback) {
        return ServiceFuture.fromResponse(getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang), serviceCallback);
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FactionSpeech&gt; object
     */
    public Observable<List<FactionSpeech>> getFactionSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).map(new Func1<ServiceResponse<List<FactionSpeech>>, List<FactionSpeech>>() {
            @Override
            public List<FactionSpeech> call(ServiceResponse<List<FactionSpeech>> response) {
                return response.body();
            }
        });
    }

    /**
     * Fraktsiooni sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FactionSpeech&gt; object
     */
    public Observable<ServiceResponse<List<FactionSpeech>>> getFactionSpeechStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getFactionSpeechStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FactionSpeech>>>>() {
                @Override
                public Observable<ServiceResponse<List<FactionSpeech>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FactionSpeech>> clientResponse = getFactionSpeechStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<FactionSpeech>> getFactionSpeechStatisticsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<FactionSpeech>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<FactionSpeech>>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FactionSpeech object if successful.
     */
    public FactionSpeech getMemberSpeechStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid) {
        return getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FactionSpeech> getMemberSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, final ServiceCallback<FactionSpeech> serviceCallback) {
        return ServiceFuture.fromResponse(getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid), serviceCallback);
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FactionSpeech object
     */
    public Observable<FactionSpeech> getMemberSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        return getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).map(new Func1<ServiceResponse<FactionSpeech>, FactionSpeech>() {
            @Override
            public FactionSpeech call(ServiceResponse<FactionSpeech> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FactionSpeech object
     */
    public Observable<ServiceResponse<FactionSpeech>> getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getMemberSpeechStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FactionSpeech>>>() {
                @Override
                public Observable<ServiceResponse<FactionSpeech>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FactionSpeech> clientResponse = getMemberSpeechStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the FactionSpeech object if successful.
     */
    public FactionSpeech getMemberSpeechStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<FactionSpeech> getMemberSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang, final ServiceCallback<FactionSpeech> serviceCallback) {
        return ServiceFuture.fromResponse(getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang), serviceCallback);
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FactionSpeech object
     */
    public Observable<FactionSpeech> getMemberSpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).map(new Func1<ServiceResponse<FactionSpeech>, FactionSpeech>() {
            @Override
            public FactionSpeech call(ServiceResponse<FactionSpeech> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the FactionSpeech object
     */
    public Observable<ServiceResponse<FactionSpeech>> getMemberSpeechStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getMemberSpeechStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FactionSpeech>>>() {
                @Override
                public Observable<ServiceResponse<FactionSpeech>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FactionSpeech> clientResponse = getMemberSpeechStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FactionSpeech> getMemberSpeechStatisticsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<FactionSpeech, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<FactionSpeech>() { }.getType())
                .build(response);
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FactionSpeech&gt; object if successful.
     */
    public List<FactionSpeech> getPlenarySpeechStatisticsUsingGET(LocalDate endDate, LocalDate startDate) {
        return getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate).toBlocking().single().body();
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FactionSpeech>> getPlenarySpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, final ServiceCallback<List<FactionSpeech>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate), serviceCallback);
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FactionSpeech&gt; object
     */
    public Observable<List<FactionSpeech>> getPlenarySpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate) {
        return getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate).map(new Func1<ServiceResponse<List<FactionSpeech>>, List<FactionSpeech>>() {
            @Override
            public List<FactionSpeech> call(ServiceResponse<List<FactionSpeech>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FactionSpeech&gt; object
     */
    public Observable<ServiceResponse<List<FactionSpeech>>> getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        final String lang = null;
        return service.getPlenarySpeechStatisticsUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FactionSpeech>>>>() {
                @Override
                public Observable<ServiceResponse<List<FactionSpeech>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FactionSpeech>> clientResponse = getPlenarySpeechStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;FactionSpeech&gt; object if successful.
     */
    public List<FactionSpeech> getPlenarySpeechStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String lang) {
        return getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, lang).toBlocking().single().body();
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<FactionSpeech>> getPlenarySpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang, final ServiceCallback<List<FactionSpeech>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, lang), serviceCallback);
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FactionSpeech&gt; object
     */
    public Observable<List<FactionSpeech>> getPlenarySpeechStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang) {
        return getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, lang).map(new Func1<ServiceResponse<List<FactionSpeech>>, List<FactionSpeech>>() {
            @Override
            public List<FactionSpeech> call(ServiceResponse<List<FactionSpeech>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu sõnavõttude statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;FactionSpeech&gt; object
     */
    public Observable<ServiceResponse<List<FactionSpeech>>> getPlenarySpeechStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        return service.getPlenarySpeechStatisticsUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<FactionSpeech>>>>() {
                @Override
                public Observable<ServiceResponse<List<FactionSpeech>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<FactionSpeech>> clientResponse = getPlenarySpeechStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<FactionSpeech>> getPlenarySpeechStatisticsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<FactionSpeech>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<FactionSpeech>>() { }.getType())
                .build(response);
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PlenaryMemberVoting&gt; object if successful.
     */
    public List<PlenaryMemberVoting> getFactionVotingStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid) {
        return getFactionVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).toBlocking().single().body();
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PlenaryMemberVoting>> getFactionVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, final ServiceCallback<List<PlenaryMemberVoting>> serviceCallback) {
        return ServiceFuture.fromResponse(getFactionVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid), serviceCallback);
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenaryMemberVoting&gt; object
     */
    public Observable<List<PlenaryMemberVoting>> getFactionVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        return getFactionVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).map(new Func1<ServiceResponse<List<PlenaryMemberVoting>>, List<PlenaryMemberVoting>>() {
            @Override
            public List<PlenaryMemberVoting> call(ServiceResponse<List<PlenaryMemberVoting>> response) {
                return response.body();
            }
        });
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenaryMemberVoting&gt; object
     */
    public Observable<ServiceResponse<List<PlenaryMemberVoting>>> getFactionVotingStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getFactionVotingStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PlenaryMemberVoting>>>>() {
                @Override
                public Observable<ServiceResponse<List<PlenaryMemberVoting>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PlenaryMemberVoting>> clientResponse = getFactionVotingStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PlenaryMemberVoting&gt; object if successful.
     */
    public List<PlenaryMemberVoting> getFactionVotingStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getFactionVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).toBlocking().single().body();
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PlenaryMemberVoting>> getFactionVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang, final ServiceCallback<List<PlenaryMemberVoting>> serviceCallback) {
        return ServiceFuture.fromResponse(getFactionVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang), serviceCallback);
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenaryMemberVoting&gt; object
     */
    public Observable<List<PlenaryMemberVoting>> getFactionVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getFactionVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).map(new Func1<ServiceResponse<List<PlenaryMemberVoting>>, List<PlenaryMemberVoting>>() {
            @Override
            public List<PlenaryMemberVoting> call(ServiceResponse<List<PlenaryMemberVoting>> response) {
                return response.body();
            }
        });
    }

    /**
     * Fraktsiooni hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Fraktsiooni UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenaryMemberVoting&gt; object
     */
    public Observable<ServiceResponse<List<PlenaryMemberVoting>>> getFactionVotingStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getFactionVotingStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PlenaryMemberVoting>>>>() {
                @Override
                public Observable<ServiceResponse<List<PlenaryMemberVoting>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PlenaryMemberVoting>> clientResponse = getFactionVotingStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PlenaryMemberVoting>> getFactionVotingStatisticsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<PlenaryMemberVoting>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<PlenaryMemberVoting>>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PlenaryMemberVoting object if successful.
     */
    public PlenaryMemberVoting getMemberVotingStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid) {
        return getMemberVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PlenaryMemberVoting> getMemberVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, final ServiceCallback<PlenaryMemberVoting> serviceCallback) {
        return ServiceFuture.fromResponse(getMemberVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid), serviceCallback);
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryMemberVoting object
     */
    public Observable<PlenaryMemberVoting> getMemberVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        return getMemberVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid).map(new Func1<ServiceResponse<PlenaryMemberVoting>, PlenaryMemberVoting>() {
            @Override
            public PlenaryMemberVoting call(ServiceResponse<PlenaryMemberVoting> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryMemberVoting object
     */
    public Observable<ServiceResponse<PlenaryMemberVoting>> getMemberVotingStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getMemberVotingStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PlenaryMemberVoting>>>() {
                @Override
                public Observable<ServiceResponse<PlenaryMemberVoting>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PlenaryMemberVoting> clientResponse = getMemberVotingStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PlenaryMemberVoting object if successful.
     */
    public PlenaryMemberVoting getMemberVotingStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getMemberVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PlenaryMemberVoting> getMemberVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang, final ServiceCallback<PlenaryMemberVoting> serviceCallback) {
        return ServiceFuture.fromResponse(getMemberVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang), serviceCallback);
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryMemberVoting object
     */
    public Observable<PlenaryMemberVoting> getMemberVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        return getMemberVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, uuid, lang).map(new Func1<ServiceResponse<PlenaryMemberVoting>, PlenaryMemberVoting>() {
            @Override
            public PlenaryMemberVoting call(ServiceResponse<PlenaryMemberVoting> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param uuid Liikme UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryMemberVoting object
     */
    public Observable<ServiceResponse<PlenaryMemberVoting>> getMemberVotingStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String uuid, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getMemberVotingStatisticsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PlenaryMemberVoting>>>() {
                @Override
                public Observable<ServiceResponse<PlenaryMemberVoting>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PlenaryMemberVoting> clientResponse = getMemberVotingStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PlenaryMemberVoting> getMemberVotingStatisticsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PlenaryMemberVoting, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PlenaryMemberVoting>() { }.getType())
                .build(response);
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PlenaryMemberVoting&gt; object if successful.
     */
    public List<PlenaryMemberVoting> getPlenaryVotingStatisticsUsingGET(LocalDate endDate, LocalDate startDate) {
        return getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate).toBlocking().single().body();
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PlenaryMemberVoting>> getPlenaryVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, final ServiceCallback<List<PlenaryMemberVoting>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate), serviceCallback);
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenaryMemberVoting&gt; object
     */
    public Observable<List<PlenaryMemberVoting>> getPlenaryVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate) {
        return getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate).map(new Func1<ServiceResponse<List<PlenaryMemberVoting>>, List<PlenaryMemberVoting>>() {
            @Override
            public List<PlenaryMemberVoting> call(ServiceResponse<List<PlenaryMemberVoting>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenaryMemberVoting&gt; object
     */
    public Observable<ServiceResponse<List<PlenaryMemberVoting>>> getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        final String lang = null;
        return service.getPlenaryVotingStatisticsUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PlenaryMemberVoting>>>>() {
                @Override
                public Observable<ServiceResponse<List<PlenaryMemberVoting>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PlenaryMemberVoting>> clientResponse = getPlenaryVotingStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PlenaryMemberVoting&gt; object if successful.
     */
    public List<PlenaryMemberVoting> getPlenaryVotingStatisticsUsingGET(LocalDate endDate, LocalDate startDate, String lang) {
        return getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, lang).toBlocking().single().body();
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PlenaryMemberVoting>> getPlenaryVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang, final ServiceCallback<List<PlenaryMemberVoting>> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, lang), serviceCallback);
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenaryMemberVoting&gt; object
     */
    public Observable<List<PlenaryMemberVoting>> getPlenaryVotingStatisticsUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang) {
        return getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(endDate, startDate, lang).map(new Func1<ServiceResponse<List<PlenaryMemberVoting>>, List<PlenaryMemberVoting>>() {
            @Override
            public List<PlenaryMemberVoting> call(ServiceResponse<List<PlenaryMemberVoting>> response) {
                return response.body();
            }
        });
    }

    /**
     * Täiskogu hääletuste statistika.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenaryMemberVoting&gt; object
     */
    public Observable<ServiceResponse<List<PlenaryMemberVoting>>> getPlenaryVotingStatisticsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        return service.getPlenaryVotingStatisticsUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PlenaryMemberVoting>>>>() {
                @Override
                public Observable<ServiceResponse<List<PlenaryMemberVoting>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PlenaryMemberVoting>> clientResponse = getPlenaryVotingStatisticsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PlenaryMemberVoting>> getPlenaryVotingStatisticsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<PlenaryMemberVoting>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<PlenaryMemberVoting>>() { }.getType())
                .build(response);
    }

    /**
     * Päevakorrapunktide steno lingid.
     * Steno XML-RPC teenus: getStenoTekstPaevakordUrl.
     *
     * @param uuids Päevakorrapunktide UUID-d (komaga eraldatud)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;AgendaStenoUrl&gt; object if successful.
     */
    public List<AgendaStenoUrl> getAgendaUrlsUsingGET(String uuids) {
        return getAgendaUrlsUsingGETWithServiceResponseAsync(uuids).toBlocking().single().body();
    }

    /**
     * Päevakorrapunktide steno lingid.
     * Steno XML-RPC teenus: getStenoTekstPaevakordUrl.
     *
     * @param uuids Päevakorrapunktide UUID-d (komaga eraldatud)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<AgendaStenoUrl>> getAgendaUrlsUsingGETAsync(String uuids, final ServiceCallback<List<AgendaStenoUrl>> serviceCallback) {
        return ServiceFuture.fromResponse(getAgendaUrlsUsingGETWithServiceResponseAsync(uuids), serviceCallback);
    }

    /**
     * Päevakorrapunktide steno lingid.
     * Steno XML-RPC teenus: getStenoTekstPaevakordUrl.
     *
     * @param uuids Päevakorrapunktide UUID-d (komaga eraldatud)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AgendaStenoUrl&gt; object
     */
    public Observable<List<AgendaStenoUrl>> getAgendaUrlsUsingGETAsync(String uuids) {
        return getAgendaUrlsUsingGETWithServiceResponseAsync(uuids).map(new Func1<ServiceResponse<List<AgendaStenoUrl>>, List<AgendaStenoUrl>>() {
            @Override
            public List<AgendaStenoUrl> call(ServiceResponse<List<AgendaStenoUrl>> response) {
                return response.body();
            }
        });
    }

    /**
     * Päevakorrapunktide steno lingid.
     * Steno XML-RPC teenus: getStenoTekstPaevakordUrl.
     *
     * @param uuids Päevakorrapunktide UUID-d (komaga eraldatud)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;AgendaStenoUrl&gt; object
     */
    public Observable<ServiceResponse<List<AgendaStenoUrl>>> getAgendaUrlsUsingGETWithServiceResponseAsync(String uuids) {
        if (uuids == null) {
            throw new IllegalArgumentException("Parameter uuids is required and cannot be null.");
        }
        return service.getAgendaUrlsUsingGET(uuids)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<AgendaStenoUrl>>>>() {
                @Override
                public Observable<ServiceResponse<List<AgendaStenoUrl>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<AgendaStenoUrl>> clientResponse = getAgendaUrlsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<AgendaStenoUrl>> getAgendaUrlsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<AgendaStenoUrl>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<AgendaStenoUrl>>() { }.getType())
                .build(response);
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getLastVerbatimsUsingGET() {
        return getLastVerbatimsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getLastVerbatimsUsingGETAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getLastVerbatimsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getLastVerbatimsUsingGETAsync() {
        return getLastVerbatimsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getLastVerbatimsUsingGETWithServiceResponseAsync() {
        final Integer count = null;
        return service.getLastVerbatimsUsingGET(count)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getLastVerbatimsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @param count Tagastatavate stenogrammide arv
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getLastVerbatimsUsingGET(Integer count) {
        return getLastVerbatimsUsingGETWithServiceResponseAsync(count).toBlocking().single().body();
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @param count Tagastatavate stenogrammide arv
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getLastVerbatimsUsingGETAsync(Integer count, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromResponse(getLastVerbatimsUsingGETWithServiceResponseAsync(count), serviceCallback);
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @param count Tagastatavate stenogrammide arv
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getLastVerbatimsUsingGETAsync(Integer count) {
        return getLastVerbatimsUsingGETWithServiceResponseAsync(count).map(new Func1<ServiceResponse<Object>, Object>() {
            @Override
            public Object call(ServiceResponse<Object> response) {
                return response.body();
            }
        });
    }

    /**
     * Viimased stenogrammid.
     * Steno XML-RPC teenus: getViimasedStenogrammid.
     *
     * @param count Tagastatavate stenogrammide arv
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponse<Object>> getLastVerbatimsUsingGETWithServiceResponseAsync(Integer count) {
        return service.getLastVerbatimsUsingGET(count)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Object>>>() {
                @Override
                public Observable<ServiceResponse<Object>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Object> clientResponse = getLastVerbatimsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Object> getLastVerbatimsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .build(response);
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;StenoSpeeches&gt; object if successful.
     */
    public List<StenoSpeeches> getSpeechesUsingGET(LocalDate endDate, LocalDate startDate, String userUuids) {
        return getSpeechesUsingGETWithServiceResponseAsync(endDate, startDate, userUuids).toBlocking().single().body();
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StenoSpeeches>> getSpeechesUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuids, final ServiceCallback<List<StenoSpeeches>> serviceCallback) {
        return ServiceFuture.fromResponse(getSpeechesUsingGETWithServiceResponseAsync(endDate, startDate, userUuids), serviceCallback);
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;StenoSpeeches&gt; object
     */
    public Observable<List<StenoSpeeches>> getSpeechesUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuids) {
        return getSpeechesUsingGETWithServiceResponseAsync(endDate, startDate, userUuids).map(new Func1<ServiceResponse<List<StenoSpeeches>>, List<StenoSpeeches>>() {
            @Override
            public List<StenoSpeeches> call(ServiceResponse<List<StenoSpeeches>> response) {
                return response.body();
            }
        });
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;StenoSpeeches&gt; object
     */
    public Observable<ServiceResponse<List<StenoSpeeches>>> getSpeechesUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String userUuids) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (userUuids == null) {
            throw new IllegalArgumentException("Parameter userUuids is required and cannot be null.");
        }
        final Integer membership = null;
        return service.getSpeechesUsingGET(endDate, membership, startDate, userUuids)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<StenoSpeeches>>>>() {
                @Override
                public Observable<ServiceResponse<List<StenoSpeeches>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<StenoSpeeches>> clientResponse = getSpeechesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @param membership Koosseisu number
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;StenoSpeeches&gt; object if successful.
     */
    public List<StenoSpeeches> getSpeechesUsingGET(LocalDate endDate, LocalDate startDate, String userUuids, Integer membership) {
        return getSpeechesUsingGETWithServiceResponseAsync(endDate, startDate, userUuids, membership).toBlocking().single().body();
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @param membership Koosseisu number
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<StenoSpeeches>> getSpeechesUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuids, Integer membership, final ServiceCallback<List<StenoSpeeches>> serviceCallback) {
        return ServiceFuture.fromResponse(getSpeechesUsingGETWithServiceResponseAsync(endDate, startDate, userUuids, membership), serviceCallback);
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @param membership Koosseisu number
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;StenoSpeeches&gt; object
     */
    public Observable<List<StenoSpeeches>> getSpeechesUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuids, Integer membership) {
        return getSpeechesUsingGETWithServiceResponseAsync(endDate, startDate, userUuids, membership).map(new Func1<ServiceResponse<List<StenoSpeeches>>, List<StenoSpeeches>>() {
            @Override
            public List<StenoSpeeches> call(ServiceResponse<List<StenoSpeeches>> response) {
                return response.body();
            }
        });
    }

    /**
     * Isikute kõnede ja sõnavõttude arv.
     * Steno XML-RPC teenus: getStenoTekstIsikKoned.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuids Isikute UUID-d (komaga eraldatud)
     * @param membership Koosseisu number
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;StenoSpeeches&gt; object
     */
    public Observable<ServiceResponse<List<StenoSpeeches>>> getSpeechesUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String userUuids, Integer membership) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (userUuids == null) {
            throw new IllegalArgumentException("Parameter userUuids is required and cannot be null.");
        }
        return service.getSpeechesUsingGET(endDate, membership, startDate, userUuids)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<StenoSpeeches>>>>() {
                @Override
                public Observable<ServiceResponse<List<StenoSpeeches>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<StenoSpeeches>> clientResponse = getSpeechesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<StenoSpeeches>> getSpeechesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<StenoSpeeches>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<StenoSpeeches>>() { }.getType())
                .build(response);
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StenoSpeechesCount object if successful.
     */
    public StenoSpeechesCount getSpeechCountUsingGET(LocalDate endDate, LocalDate startDate, String userUuid) {
        return getSpeechCountUsingGETWithServiceResponseAsync(endDate, startDate, userUuid).toBlocking().single().body();
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StenoSpeechesCount> getSpeechCountUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuid, final ServiceCallback<StenoSpeechesCount> serviceCallback) {
        return ServiceFuture.fromResponse(getSpeechCountUsingGETWithServiceResponseAsync(endDate, startDate, userUuid), serviceCallback);
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StenoSpeechesCount object
     */
    public Observable<StenoSpeechesCount> getSpeechCountUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuid) {
        return getSpeechCountUsingGETWithServiceResponseAsync(endDate, startDate, userUuid).map(new Func1<ServiceResponse<StenoSpeechesCount>, StenoSpeechesCount>() {
            @Override
            public StenoSpeechesCount call(ServiceResponse<StenoSpeechesCount> response) {
                return response.body();
            }
        });
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StenoSpeechesCount object
     */
    public Observable<ServiceResponse<StenoSpeechesCount>> getSpeechCountUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String userUuid) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (userUuid == null) {
            throw new IllegalArgumentException("Parameter userUuid is required and cannot be null.");
        }
        final Integer membership = null;
        final String type = null;
        return service.getSpeechCountUsingGET(endDate, membership, startDate, type, userUuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StenoSpeechesCount>>>() {
                @Override
                public Observable<ServiceResponse<StenoSpeechesCount>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StenoSpeechesCount> clientResponse = getSpeechCountUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the StenoSpeechesCount object if successful.
     */
    public StenoSpeechesCount getSpeechCountUsingGET(LocalDate endDate, LocalDate startDate, String userUuid, Integer membership, String type) {
        return getSpeechCountUsingGETWithServiceResponseAsync(endDate, startDate, userUuid, membership, type).toBlocking().single().body();
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<StenoSpeechesCount> getSpeechCountUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuid, Integer membership, String type, final ServiceCallback<StenoSpeechesCount> serviceCallback) {
        return ServiceFuture.fromResponse(getSpeechCountUsingGETWithServiceResponseAsync(endDate, startDate, userUuid, membership, type), serviceCallback);
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StenoSpeechesCount object
     */
    public Observable<StenoSpeechesCount> getSpeechCountUsingGETAsync(LocalDate endDate, LocalDate startDate, String userUuid, Integer membership, String type) {
        return getSpeechCountUsingGETWithServiceResponseAsync(endDate, startDate, userUuid, membership, type).map(new Func1<ServiceResponse<StenoSpeechesCount>, StenoSpeechesCount>() {
            @Override
            public StenoSpeechesCount call(ServiceResponse<StenoSpeechesCount> response) {
                return response.body();
            }
        });
    }

    /**
     * Isiku sõnavõttude arv.
     * Steno XML-RPC teenus: getIsikSonavotudCount.
     *
     * @param endDate Lõppkuupäev (yyyy-MM-dd)
     * @param startDate Alguskuupäev (yyyy-MM-dd)
     * @param userUuid Isiku UUID
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the StenoSpeechesCount object
     */
    public Observable<ServiceResponse<StenoSpeechesCount>> getSpeechCountUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String userUuid, Integer membership, String type) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        if (userUuid == null) {
            throw new IllegalArgumentException("Parameter userUuid is required and cannot be null.");
        }
        return service.getSpeechCountUsingGET(endDate, membership, startDate, type, userUuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StenoSpeechesCount>>>() {
                @Override
                public Observable<ServiceResponse<StenoSpeechesCount>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StenoSpeechesCount> clientResponse = getSpeechCountUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StenoSpeechesCount> getSpeechCountUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<StenoSpeechesCount, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<StenoSpeechesCount>() { }.getType())
                .build(response);
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the LastStenoSpeech object if successful.
     */
    public LastStenoSpeech getLastSpeechUsingGET(String userUuid) {
        return getLastSpeechUsingGETWithServiceResponseAsync(userUuid).toBlocking().single().body();
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<LastStenoSpeech> getLastSpeechUsingGETAsync(String userUuid, final ServiceCallback<LastStenoSpeech> serviceCallback) {
        return ServiceFuture.fromResponse(getLastSpeechUsingGETWithServiceResponseAsync(userUuid), serviceCallback);
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LastStenoSpeech object
     */
    public Observable<LastStenoSpeech> getLastSpeechUsingGETAsync(String userUuid) {
        return getLastSpeechUsingGETWithServiceResponseAsync(userUuid).map(new Func1<ServiceResponse<LastStenoSpeech>, LastStenoSpeech>() {
            @Override
            public LastStenoSpeech call(ServiceResponse<LastStenoSpeech> response) {
                return response.body();
            }
        });
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LastStenoSpeech object
     */
    public Observable<ServiceResponse<LastStenoSpeech>> getLastSpeechUsingGETWithServiceResponseAsync(String userUuid) {
        if (userUuid == null) {
            throw new IllegalArgumentException("Parameter userUuid is required and cannot be null.");
        }
        final Integer charCount = null;
        final Integer membership = null;
        final String type = null;
        return service.getLastSpeechUsingGET(charCount, membership, type, userUuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<LastStenoSpeech>>>() {
                @Override
                public Observable<ServiceResponse<LastStenoSpeech>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<LastStenoSpeech> clientResponse = getLastSpeechUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @param charCount Tähemärkide arv
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the LastStenoSpeech object if successful.
     */
    public LastStenoSpeech getLastSpeechUsingGET(String userUuid, Integer charCount, Integer membership, String type) {
        return getLastSpeechUsingGETWithServiceResponseAsync(userUuid, charCount, membership, type).toBlocking().single().body();
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @param charCount Tähemärkide arv
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<LastStenoSpeech> getLastSpeechUsingGETAsync(String userUuid, Integer charCount, Integer membership, String type, final ServiceCallback<LastStenoSpeech> serviceCallback) {
        return ServiceFuture.fromResponse(getLastSpeechUsingGETWithServiceResponseAsync(userUuid, charCount, membership, type), serviceCallback);
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @param charCount Tähemärkide arv
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LastStenoSpeech object
     */
    public Observable<LastStenoSpeech> getLastSpeechUsingGETAsync(String userUuid, Integer charCount, Integer membership, String type) {
        return getLastSpeechUsingGETWithServiceResponseAsync(userUuid, charCount, membership, type).map(new Func1<ServiceResponse<LastStenoSpeech>, LastStenoSpeech>() {
            @Override
            public LastStenoSpeech call(ServiceResponse<LastStenoSpeech> response) {
                return response.body();
            }
        });
    }

    /**
     * Isiku viimane sõnavõtt.
     * Steno XML-RPC teenus: getViimaneSonavott.
     *
     * @param userUuid Isiku UUID
     * @param charCount Tähemärkide arv
     * @param membership Koosseisu number
     * @param type Istungi tüüp. Possible values include: 'IS', 'IT'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the LastStenoSpeech object
     */
    public Observable<ServiceResponse<LastStenoSpeech>> getLastSpeechUsingGETWithServiceResponseAsync(String userUuid, Integer charCount, Integer membership, String type) {
        if (userUuid == null) {
            throw new IllegalArgumentException("Parameter userUuid is required and cannot be null.");
        }
        return service.getLastSpeechUsingGET(charCount, membership, type, userUuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<LastStenoSpeech>>>() {
                @Override
                public Observable<ServiceResponse<LastStenoSpeech>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<LastStenoSpeech> clientResponse = getLastSpeechUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<LastStenoSpeech> getLastSpeechUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<LastStenoSpeech, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<LastStenoSpeech>() { }.getType())
                .build(response);
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserGroup&gt; object if successful.
     */
    public List<UserGroup> findUserGroupsUsingGET() {
        return findUserGroupsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserGroup>> findUserGroupsUsingGETAsync(final ServiceCallback<List<UserGroup>> serviceCallback) {
        return ServiceFuture.fromResponse(findUserGroupsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserGroup&gt; object
     */
    public Observable<List<UserGroup>> findUserGroupsUsingGETAsync() {
        return findUserGroupsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<UserGroup>>, List<UserGroup>>() {
            @Override
            public List<UserGroup> call(ServiceResponse<List<UserGroup>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserGroup&gt; object
     */
    public Observable<ServiceResponse<List<UserGroup>>> findUserGroupsUsingGETWithServiceResponseAsync() {
        final Boolean hideInactive = null;
        final String lang = null;
        final String name = null;
        final String typeCode = null;
        return service.findUserGroupsUsingGET(hideInactive, lang, name, typeCode)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserGroup>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserGroup>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserGroup>> clientResponse = findUserGroupsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @param hideInactive hideInactive
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param name Nimi
     * @param typeCode Tüübi kood (klassifikaator 'kasutajagrupiTuup'). Possible values include: 'UURIMISKOMISJON', 'VANA_FRAKTSIOON', 'VANA_ERIKOMISJON', 'VANA_ALALINE_KOMISJON', 'ALALINE_KOMISJON', 'ERIKOMISJON', 'RIIGIKOGU_JUHATUS', 'ESIMEHE_BÜROO', 'OSAKOND', 'VALIMISRINGKOND', 'TOETUSRYHM', 'ASUTUSE_YKSUS', 'PARLAMENDIRYHM', 'YHENDUS', 'FRAKTSIOON', 'DELEGATSIOON', 'RIIGIKOGU_TAISKOGU', 'ERAKOND', 'AMETNIK', 'TALITUS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserGroup&gt; object if successful.
     */
    public List<UserGroup> findUserGroupsUsingGET(Boolean hideInactive, String lang, String name, String typeCode) {
        return findUserGroupsUsingGETWithServiceResponseAsync(hideInactive, lang, name, typeCode).toBlocking().single().body();
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @param hideInactive hideInactive
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param name Nimi
     * @param typeCode Tüübi kood (klassifikaator 'kasutajagrupiTuup'). Possible values include: 'UURIMISKOMISJON', 'VANA_FRAKTSIOON', 'VANA_ERIKOMISJON', 'VANA_ALALINE_KOMISJON', 'ALALINE_KOMISJON', 'ERIKOMISJON', 'RIIGIKOGU_JUHATUS', 'ESIMEHE_BÜROO', 'OSAKOND', 'VALIMISRINGKOND', 'TOETUSRYHM', 'ASUTUSE_YKSUS', 'PARLAMENDIRYHM', 'YHENDUS', 'FRAKTSIOON', 'DELEGATSIOON', 'RIIGIKOGU_TAISKOGU', 'ERAKOND', 'AMETNIK', 'TALITUS'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserGroup>> findUserGroupsUsingGETAsync(Boolean hideInactive, String lang, String name, String typeCode, final ServiceCallback<List<UserGroup>> serviceCallback) {
        return ServiceFuture.fromResponse(findUserGroupsUsingGETWithServiceResponseAsync(hideInactive, lang, name, typeCode), serviceCallback);
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @param hideInactive hideInactive
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param name Nimi
     * @param typeCode Tüübi kood (klassifikaator 'kasutajagrupiTuup'). Possible values include: 'UURIMISKOMISJON', 'VANA_FRAKTSIOON', 'VANA_ERIKOMISJON', 'VANA_ALALINE_KOMISJON', 'ALALINE_KOMISJON', 'ERIKOMISJON', 'RIIGIKOGU_JUHATUS', 'ESIMEHE_BÜROO', 'OSAKOND', 'VALIMISRINGKOND', 'TOETUSRYHM', 'ASUTUSE_YKSUS', 'PARLAMENDIRYHM', 'YHENDUS', 'FRAKTSIOON', 'DELEGATSIOON', 'RIIGIKOGU_TAISKOGU', 'ERAKOND', 'AMETNIK', 'TALITUS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserGroup&gt; object
     */
    public Observable<List<UserGroup>> findUserGroupsUsingGETAsync(Boolean hideInactive, String lang, String name, String typeCode) {
        return findUserGroupsUsingGETWithServiceResponseAsync(hideInactive, lang, name, typeCode).map(new Func1<ServiceResponse<List<UserGroup>>, List<UserGroup>>() {
            @Override
            public List<UserGroup> call(ServiceResponse<List<UserGroup>> response) {
                return response.body();
            }
        });
    }

    /**
     * Kasutajagruppide nimekiri/otsing.
     *
     * @param hideInactive hideInactive
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param name Nimi
     * @param typeCode Tüübi kood (klassifikaator 'kasutajagrupiTuup'). Possible values include: 'UURIMISKOMISJON', 'VANA_FRAKTSIOON', 'VANA_ERIKOMISJON', 'VANA_ALALINE_KOMISJON', 'ALALINE_KOMISJON', 'ERIKOMISJON', 'RIIGIKOGU_JUHATUS', 'ESIMEHE_BÜROO', 'OSAKOND', 'VALIMISRINGKOND', 'TOETUSRYHM', 'ASUTUSE_YKSUS', 'PARLAMENDIRYHM', 'YHENDUS', 'FRAKTSIOON', 'DELEGATSIOON', 'RIIGIKOGU_TAISKOGU', 'ERAKOND', 'AMETNIK', 'TALITUS'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserGroup&gt; object
     */
    public Observable<ServiceResponse<List<UserGroup>>> findUserGroupsUsingGETWithServiceResponseAsync(Boolean hideInactive, String lang, String name, String typeCode) {
        return service.findUserGroupsUsingGET(hideInactive, lang, name, typeCode)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserGroup>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserGroup>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserGroup>> clientResponse = findUserGroupsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<UserGroup>> findUserGroupsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<UserGroup>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<UserGroup>>() { }.getType())
                .build(response);
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserGroup object if successful.
     */
    public UserGroup getUserGroupUsingGET(String uuid) {
        return getUserGroupUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserGroup> getUserGroupUsingGETAsync(String uuid, final ServiceCallback<UserGroup> serviceCallback) {
        return ServiceFuture.fromResponse(getUserGroupUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserGroup object
     */
    public Observable<UserGroup> getUserGroupUsingGETAsync(String uuid) {
        return getUserGroupUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<UserGroup>, UserGroup>() {
            @Override
            public UserGroup call(ServiceResponse<UserGroup> response) {
                return response.body();
            }
        });
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserGroup object
     */
    public Observable<ServiceResponse<UserGroup>> getUserGroupUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getUserGroupUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserGroup>>>() {
                @Override
                public Observable<ServiceResponse<UserGroup>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserGroup> clientResponse = getUserGroupUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the UserGroup object if successful.
     */
    public UserGroup getUserGroupUsingGET(String uuid, String lang) {
        return getUserGroupUsingGETWithServiceResponseAsync(uuid, lang).toBlocking().single().body();
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<UserGroup> getUserGroupUsingGETAsync(String uuid, String lang, final ServiceCallback<UserGroup> serviceCallback) {
        return ServiceFuture.fromResponse(getUserGroupUsingGETWithServiceResponseAsync(uuid, lang), serviceCallback);
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserGroup object
     */
    public Observable<UserGroup> getUserGroupUsingGETAsync(String uuid, String lang) {
        return getUserGroupUsingGETWithServiceResponseAsync(uuid, lang).map(new Func1<ServiceResponse<UserGroup>, UserGroup>() {
            @Override
            public UserGroup call(ServiceResponse<UserGroup> response) {
                return response.body();
            }
        });
    }

    /**
     * getUserGroup.
     *
     * @param uuid Kasutajagrupi UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the UserGroup object
     */
    public Observable<ServiceResponse<UserGroup>> getUserGroupUsingGETWithServiceResponseAsync(String uuid, String lang) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getUserGroupUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<UserGroup>>>() {
                @Override
                public Observable<ServiceResponse<UserGroup>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<UserGroup> clientResponse = getUserGroupUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<UserGroup> getUserGroupUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<UserGroup, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<UserGroup>() { }.getType())
                .build(response);
    }

    /**
     * Toimikute otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfVolumes object if successful.
     */
    public PagedResourcesOfVolumes findVolumesUsingGET() {
        return findVolumesUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Toimikute otsing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfVolumes> findVolumesUsingGETAsync(final ServiceCallback<PagedResourcesOfVolumes> serviceCallback) {
        return ServiceFuture.fromResponse(findVolumesUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Toimikute otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfVolumes object
     */
    public Observable<PagedResourcesOfVolumes> findVolumesUsingGETAsync() {
        return findVolumesUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesOfVolumes>, PagedResourcesOfVolumes>() {
            @Override
            public PagedResourcesOfVolumes call(ServiceResponse<PagedResourcesOfVolumes> response) {
                return response.body();
            }
        });
    }

    /**
     * Toimikute otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfVolumes object
     */
    public Observable<ServiceResponse<PagedResourcesOfVolumes>> findVolumesUsingGETWithServiceResponseAsync() {
        final LocalDate createdEndDate = null;
        final LocalDate createdStartDate = null;
        final String functionGroupUuid = null;
        final String functionUuid = null;
        final Integer membership = null;
        final Long offset = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final String reference = null;
        final String seriesUuid = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final String subseriesUuid = null;
        final String title = null;
        final Boolean unpaged = null;
        final String volumeType = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findVolumesUsingGET(createdEndDate, createdStartDate, functionGroupUuid, functionUuid, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sortConverted, sortsorted, sortunsorted, subseriesUuid, title, unpaged, volumeType)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfVolumes>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfVolumes>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfVolumes> clientResponse = findVolumesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param functionGroupUuid Funktsioonigrupi UUID
     * @param functionUuid Funktsiooni UUID
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param volumeType Toimiku tüüp. Possible values include: 'letterVolume', 'elVolume', 'dokumenditoimik', 'unitSittingVolume', 'officialJourneyVolume', 'opinionVolume', 'plenarySittingVolume', 'infoSittingVolume', 'interpellationsVolume', 'eelnou', 'writtenQuestionVolume', 'researchVolume', 'procurementVolume', 'visitVolume'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfVolumes object if successful.
     */
    public PagedResourcesOfVolumes findVolumesUsingGET(LocalDate createdEndDate, LocalDate createdStartDate, String functionGroupUuid, String functionUuid, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged, String volumeType) {
        return findVolumesUsingGETWithServiceResponseAsync(createdEndDate, createdStartDate, functionGroupUuid, functionUuid, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sort, sortsorted, sortunsorted, subseriesUuid, title, unpaged, volumeType).toBlocking().single().body();
    }

    /**
     * Toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param functionGroupUuid Funktsioonigrupi UUID
     * @param functionUuid Funktsiooni UUID
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param volumeType Toimiku tüüp. Possible values include: 'letterVolume', 'elVolume', 'dokumenditoimik', 'unitSittingVolume', 'officialJourneyVolume', 'opinionVolume', 'plenarySittingVolume', 'infoSittingVolume', 'interpellationsVolume', 'eelnou', 'writtenQuestionVolume', 'researchVolume', 'procurementVolume', 'visitVolume'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfVolumes> findVolumesUsingGETAsync(LocalDate createdEndDate, LocalDate createdStartDate, String functionGroupUuid, String functionUuid, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged, String volumeType, final ServiceCallback<PagedResourcesOfVolumes> serviceCallback) {
        return ServiceFuture.fromResponse(findVolumesUsingGETWithServiceResponseAsync(createdEndDate, createdStartDate, functionGroupUuid, functionUuid, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sort, sortsorted, sortunsorted, subseriesUuid, title, unpaged, volumeType), serviceCallback);
    }

    /**
     * Toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param functionGroupUuid Funktsioonigrupi UUID
     * @param functionUuid Funktsiooni UUID
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param volumeType Toimiku tüüp. Possible values include: 'letterVolume', 'elVolume', 'dokumenditoimik', 'unitSittingVolume', 'officialJourneyVolume', 'opinionVolume', 'plenarySittingVolume', 'infoSittingVolume', 'interpellationsVolume', 'eelnou', 'writtenQuestionVolume', 'researchVolume', 'procurementVolume', 'visitVolume'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfVolumes object
     */
    public Observable<PagedResourcesOfVolumes> findVolumesUsingGETAsync(LocalDate createdEndDate, LocalDate createdStartDate, String functionGroupUuid, String functionUuid, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged, String volumeType) {
        return findVolumesUsingGETWithServiceResponseAsync(createdEndDate, createdStartDate, functionGroupUuid, functionUuid, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sort, sortsorted, sortunsorted, subseriesUuid, title, unpaged, volumeType).map(new Func1<ServiceResponse<PagedResourcesOfVolumes>, PagedResourcesOfVolumes>() {
            @Override
            public PagedResourcesOfVolumes call(ServiceResponse<PagedResourcesOfVolumes> response) {
                return response.body();
            }
        });
    }

    /**
     * Toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param functionGroupUuid Funktsioonigrupi UUID
     * @param functionUuid Funktsiooni UUID
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param reference Viit
     * @param seriesUuid Sarja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param subseriesUuid Alamsarja UUID
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param volumeType Toimiku tüüp. Possible values include: 'letterVolume', 'elVolume', 'dokumenditoimik', 'unitSittingVolume', 'officialJourneyVolume', 'opinionVolume', 'plenarySittingVolume', 'infoSittingVolume', 'interpellationsVolume', 'eelnou', 'writtenQuestionVolume', 'researchVolume', 'procurementVolume', 'visitVolume'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfVolumes object
     */
    public Observable<ServiceResponse<PagedResourcesOfVolumes>> findVolumesUsingGETWithServiceResponseAsync(LocalDate createdEndDate, LocalDate createdStartDate, String functionGroupUuid, String functionUuid, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String reference, String seriesUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String subseriesUuid, String title, Boolean unpaged, String volumeType) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findVolumesUsingGET(createdEndDate, createdStartDate, functionGroupUuid, functionUuid, membership, offset, page, pageNumber, pageSize, paged, reference, seriesUuid, size, sortConverted, sortsorted, sortunsorted, subseriesUuid, title, unpaged, volumeType)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfVolumes>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfVolumes>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfVolumes> clientResponse = findVolumesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesOfVolumes> findVolumesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesOfVolumes, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesOfVolumes>() { }.getType())
                .build(response);
    }

    /**
     * Eelnõude otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfDraftVolumes object if successful.
     */
    public PagedResourcesOfDraftVolumes findDraftVolumesUsingGET() {
        return findDraftVolumesUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Eelnõude otsing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfDraftVolumes> findDraftVolumesUsingGETAsync(final ServiceCallback<PagedResourcesOfDraftVolumes> serviceCallback) {
        return ServiceFuture.fromResponse(findDraftVolumesUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Eelnõude otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfDraftVolumes object
     */
    public Observable<PagedResourcesOfDraftVolumes> findDraftVolumesUsingGETAsync() {
        return findDraftVolumesUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesOfDraftVolumes>, PagedResourcesOfDraftVolumes>() {
            @Override
            public PagedResourcesOfDraftVolumes call(ServiceResponse<PagedResourcesOfDraftVolumes> response) {
                return response.body();
            }
        });
    }

    /**
     * Eelnõude otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfDraftVolumes object
     */
    public Observable<ServiceResponse<PagedResourcesOfDraftVolumes>> findDraftVolumesUsingGETWithServiceResponseAsync() {
        final String activeDraftStage = null;
        final LocalDate amendmentsDeadlineEndDate = null;
        final LocalDate amendmentsDeadlineStartDate = null;
        final Integer descriptorId = null;
        final String draftTypeCode = null;
        final LocalDate initiatedEndDate = null;
        final LocalDate initiatedStartDate = null;
        final String initiatorUuid = null;
        final String lang = null;
        final String leadingCommitteeUuid = null;
        final Integer mark = null;
        final Integer membership = null;
        final Long offset = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final String proceedingStatus = null;
        final String reference = null;
        final String responsibleMemberUuid = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final String title = null;
        final Boolean unpaged = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findDraftVolumesUsingGET(activeDraftStage, amendmentsDeadlineEndDate, amendmentsDeadlineStartDate, descriptorId, draftTypeCode, initiatedEndDate, initiatedStartDate, initiatorUuid, lang, leadingCommitteeUuid, mark, membership, offset, page, pageNumber, pageSize, paged, proceedingStatus, reference, responsibleMemberUuid, size, sortConverted, sortsorted, sortunsorted, title, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfDraftVolumes>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfDraftVolumes>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfDraftVolumes> clientResponse = findDraftVolumesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Eelnõude otsing.
     *
     * @param activeDraftStage Aktiivne menetlusetapp
     * @param amendmentsDeadlineEndDate Muudatuseteepanekute tähtaja vahemiku lõpp (yyyy-MM-dd)
     * @param amendmentsDeadlineStartDate Muudatuseteepanekute tähtaja vahemiku algus (yyyy-MM-dd)
     * @param descriptorId Märksõna ID
     * @param draftTypeCode Eelnõu liik (klassifikaator 'eelnouLiik'). Possible values include: 'UA', 'DE', 'PE', 'AE', 'TK', 'SE', 'OE'
     * @param initiatedEndDate Algatamise kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param initiatedStartDate Algatamise kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param initiatorUuid Algataja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param leadingCommitteeUuid Juhtivkomisjoni UUID
     * @param mark Registreerimise number
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param proceedingStatus Menetluse staatus. Possible values include: 'IN_PROCESS', 'PROCESSED'
     * @param reference Viit
     * @param responsibleMemberUuid Juhtivkomisjoni esindaja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfDraftVolumes object if successful.
     */
    public PagedResourcesOfDraftVolumes findDraftVolumesUsingGET(String activeDraftStage, LocalDate amendmentsDeadlineEndDate, LocalDate amendmentsDeadlineStartDate, Integer descriptorId, String draftTypeCode, LocalDate initiatedEndDate, LocalDate initiatedStartDate, String initiatorUuid, String lang, String leadingCommitteeUuid, Integer mark, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String proceedingStatus, String reference, String responsibleMemberUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, Boolean unpaged) {
        return findDraftVolumesUsingGETWithServiceResponseAsync(activeDraftStage, amendmentsDeadlineEndDate, amendmentsDeadlineStartDate, descriptorId, draftTypeCode, initiatedEndDate, initiatedStartDate, initiatorUuid, lang, leadingCommitteeUuid, mark, membership, offset, page, pageNumber, pageSize, paged, proceedingStatus, reference, responsibleMemberUuid, size, sort, sortsorted, sortunsorted, title, unpaged).toBlocking().single().body();
    }

    /**
     * Eelnõude otsing.
     *
     * @param activeDraftStage Aktiivne menetlusetapp
     * @param amendmentsDeadlineEndDate Muudatuseteepanekute tähtaja vahemiku lõpp (yyyy-MM-dd)
     * @param amendmentsDeadlineStartDate Muudatuseteepanekute tähtaja vahemiku algus (yyyy-MM-dd)
     * @param descriptorId Märksõna ID
     * @param draftTypeCode Eelnõu liik (klassifikaator 'eelnouLiik'). Possible values include: 'UA', 'DE', 'PE', 'AE', 'TK', 'SE', 'OE'
     * @param initiatedEndDate Algatamise kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param initiatedStartDate Algatamise kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param initiatorUuid Algataja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param leadingCommitteeUuid Juhtivkomisjoni UUID
     * @param mark Registreerimise number
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param proceedingStatus Menetluse staatus. Possible values include: 'IN_PROCESS', 'PROCESSED'
     * @param reference Viit
     * @param responsibleMemberUuid Juhtivkomisjoni esindaja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfDraftVolumes> findDraftVolumesUsingGETAsync(String activeDraftStage, LocalDate amendmentsDeadlineEndDate, LocalDate amendmentsDeadlineStartDate, Integer descriptorId, String draftTypeCode, LocalDate initiatedEndDate, LocalDate initiatedStartDate, String initiatorUuid, String lang, String leadingCommitteeUuid, Integer mark, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String proceedingStatus, String reference, String responsibleMemberUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, Boolean unpaged, final ServiceCallback<PagedResourcesOfDraftVolumes> serviceCallback) {
        return ServiceFuture.fromResponse(findDraftVolumesUsingGETWithServiceResponseAsync(activeDraftStage, amendmentsDeadlineEndDate, amendmentsDeadlineStartDate, descriptorId, draftTypeCode, initiatedEndDate, initiatedStartDate, initiatorUuid, lang, leadingCommitteeUuid, mark, membership, offset, page, pageNumber, pageSize, paged, proceedingStatus, reference, responsibleMemberUuid, size, sort, sortsorted, sortunsorted, title, unpaged), serviceCallback);
    }

    /**
     * Eelnõude otsing.
     *
     * @param activeDraftStage Aktiivne menetlusetapp
     * @param amendmentsDeadlineEndDate Muudatuseteepanekute tähtaja vahemiku lõpp (yyyy-MM-dd)
     * @param amendmentsDeadlineStartDate Muudatuseteepanekute tähtaja vahemiku algus (yyyy-MM-dd)
     * @param descriptorId Märksõna ID
     * @param draftTypeCode Eelnõu liik (klassifikaator 'eelnouLiik'). Possible values include: 'UA', 'DE', 'PE', 'AE', 'TK', 'SE', 'OE'
     * @param initiatedEndDate Algatamise kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param initiatedStartDate Algatamise kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param initiatorUuid Algataja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param leadingCommitteeUuid Juhtivkomisjoni UUID
     * @param mark Registreerimise number
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param proceedingStatus Menetluse staatus. Possible values include: 'IN_PROCESS', 'PROCESSED'
     * @param reference Viit
     * @param responsibleMemberUuid Juhtivkomisjoni esindaja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfDraftVolumes object
     */
    public Observable<PagedResourcesOfDraftVolumes> findDraftVolumesUsingGETAsync(String activeDraftStage, LocalDate amendmentsDeadlineEndDate, LocalDate amendmentsDeadlineStartDate, Integer descriptorId, String draftTypeCode, LocalDate initiatedEndDate, LocalDate initiatedStartDate, String initiatorUuid, String lang, String leadingCommitteeUuid, Integer mark, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String proceedingStatus, String reference, String responsibleMemberUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, Boolean unpaged) {
        return findDraftVolumesUsingGETWithServiceResponseAsync(activeDraftStage, amendmentsDeadlineEndDate, amendmentsDeadlineStartDate, descriptorId, draftTypeCode, initiatedEndDate, initiatedStartDate, initiatorUuid, lang, leadingCommitteeUuid, mark, membership, offset, page, pageNumber, pageSize, paged, proceedingStatus, reference, responsibleMemberUuid, size, sort, sortsorted, sortunsorted, title, unpaged).map(new Func1<ServiceResponse<PagedResourcesOfDraftVolumes>, PagedResourcesOfDraftVolumes>() {
            @Override
            public PagedResourcesOfDraftVolumes call(ServiceResponse<PagedResourcesOfDraftVolumes> response) {
                return response.body();
            }
        });
    }

    /**
     * Eelnõude otsing.
     *
     * @param activeDraftStage Aktiivne menetlusetapp
     * @param amendmentsDeadlineEndDate Muudatuseteepanekute tähtaja vahemiku lõpp (yyyy-MM-dd)
     * @param amendmentsDeadlineStartDate Muudatuseteepanekute tähtaja vahemiku algus (yyyy-MM-dd)
     * @param descriptorId Märksõna ID
     * @param draftTypeCode Eelnõu liik (klassifikaator 'eelnouLiik'). Possible values include: 'UA', 'DE', 'PE', 'AE', 'TK', 'SE', 'OE'
     * @param initiatedEndDate Algatamise kuupäeva vahemiku lõpp (yyyy-MM-dd)
     * @param initiatedStartDate Algatamise kuupäeva vahemiku algus (yyyy-MM-dd)
     * @param initiatorUuid Algataja UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param leadingCommitteeUuid Juhtivkomisjoni UUID
     * @param mark Registreerimise number
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param proceedingStatus Menetluse staatus. Possible values include: 'IN_PROCESS', 'PROCESSED'
     * @param reference Viit
     * @param responsibleMemberUuid Juhtivkomisjoni esindaja UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfDraftVolumes object
     */
    public Observable<ServiceResponse<PagedResourcesOfDraftVolumes>> findDraftVolumesUsingGETWithServiceResponseAsync(String activeDraftStage, LocalDate amendmentsDeadlineEndDate, LocalDate amendmentsDeadlineStartDate, Integer descriptorId, String draftTypeCode, LocalDate initiatedEndDate, LocalDate initiatedStartDate, String initiatorUuid, String lang, String leadingCommitteeUuid, Integer mark, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, String proceedingStatus, String reference, String responsibleMemberUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, Boolean unpaged) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findDraftVolumesUsingGET(activeDraftStage, amendmentsDeadlineEndDate, amendmentsDeadlineStartDate, descriptorId, draftTypeCode, initiatedEndDate, initiatedStartDate, initiatorUuid, lang, leadingCommitteeUuid, mark, membership, offset, page, pageNumber, pageSize, paged, proceedingStatus, reference, responsibleMemberUuid, size, sortConverted, sortsorted, sortunsorted, title, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfDraftVolumes>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfDraftVolumes>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfDraftVolumes> clientResponse = findDraftVolumesUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesOfDraftVolumes> findDraftVolumesUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesOfDraftVolumes, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesOfDraftVolumes>() { }.getType())
                .build(response);
    }

    /**
     * test.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void testUsingGET() {
        testUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * test.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> testUsingGETAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(testUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * test.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> testUsingGETAsync() {
        return testUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * test.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> testUsingGETWithServiceResponseAsync() {
        final Long offset = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final Boolean unpaged = null;
        return service.testUsingGET(offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = testUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * test.
     *
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void testUsingGET(Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        testUsingGETWithServiceResponseAsync(offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, unpaged).toBlocking().single().body();
    }

    /**
     * test.
     *
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> testUsingGETAsync(Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(testUsingGETWithServiceResponseAsync(offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, unpaged), serviceCallback);
    }

    /**
     * test.
     *
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> testUsingGETAsync(Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        return testUsingGETWithServiceResponseAsync(offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, unpaged).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * test.
     *
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> testUsingGETWithServiceResponseAsync(Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        return service.testUsingGET(offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = testUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> testUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DraftVolume object if successful.
     */
    public DraftVolume getDraftVolumeUsingGET(String uuid) {
        return getDraftVolumeUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DraftVolume> getDraftVolumeUsingGETAsync(String uuid, final ServiceCallback<DraftVolume> serviceCallback) {
        return ServiceFuture.fromResponse(getDraftVolumeUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DraftVolume object
     */
    public Observable<DraftVolume> getDraftVolumeUsingGETAsync(String uuid) {
        return getDraftVolumeUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<DraftVolume>, DraftVolume>() {
            @Override
            public DraftVolume call(ServiceResponse<DraftVolume> response) {
                return response.body();
            }
        });
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DraftVolume object
     */
    public Observable<ServiceResponse<DraftVolume>> getDraftVolumeUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        final Boolean querySteno = null;
        return service.getDraftVolumeUsingGET(uuid, lang, querySteno)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DraftVolume>>>() {
                @Override
                public Observable<ServiceResponse<DraftVolume>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DraftVolume> clientResponse = getDraftVolumeUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DraftVolume object if successful.
     */
    public DraftVolume getDraftVolumeUsingGET(String uuid, String lang, Boolean querySteno) {
        return getDraftVolumeUsingGETWithServiceResponseAsync(uuid, lang, querySteno).toBlocking().single().body();
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DraftVolume> getDraftVolumeUsingGETAsync(String uuid, String lang, Boolean querySteno, final ServiceCallback<DraftVolume> serviceCallback) {
        return ServiceFuture.fromResponse(getDraftVolumeUsingGETWithServiceResponseAsync(uuid, lang, querySteno), serviceCallback);
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DraftVolume object
     */
    public Observable<DraftVolume> getDraftVolumeUsingGETAsync(String uuid, String lang, Boolean querySteno) {
        return getDraftVolumeUsingGETWithServiceResponseAsync(uuid, lang, querySteno).map(new Func1<ServiceResponse<DraftVolume>, DraftVolume>() {
            @Override
            public DraftVolume call(ServiceResponse<DraftVolume> response) {
                return response.body();
            }
        });
    }

    /**
     * Eelnõu detailid.
     *
     * @param uuid Eelnõu toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param querySteno Küsi Stenoteksti teenusest päevakorra lingid? (true/false)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DraftVolume object
     */
    public Observable<ServiceResponse<DraftVolume>> getDraftVolumeUsingGETWithServiceResponseAsync(String uuid, String lang, Boolean querySteno) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getDraftVolumeUsingGET(uuid, lang, querySteno)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DraftVolume>>>() {
                @Override
                public Observable<ServiceResponse<DraftVolume>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DraftVolume> clientResponse = getDraftVolumeUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DraftVolume> getDraftVolumeUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<DraftVolume, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DraftVolume>() { }.getType())
                .build(response);
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ErjkProtocol&gt; object if successful.
     */
    public List<ErjkProtocol> findErjkProtocolsUsingGET() {
        return findErjkProtocolsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ErjkProtocol>> findErjkProtocolsUsingGETAsync(final ServiceCallback<List<ErjkProtocol>> serviceCallback) {
        return ServiceFuture.fromResponse(findErjkProtocolsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ErjkProtocol&gt; object
     */
    public Observable<List<ErjkProtocol>> findErjkProtocolsUsingGETAsync() {
        return findErjkProtocolsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<List<ErjkProtocol>>, List<ErjkProtocol>>() {
            @Override
            public List<ErjkProtocol> call(ServiceResponse<List<ErjkProtocol>> response) {
                return response.body();
            }
        });
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ErjkProtocol&gt; object
     */
    public Observable<ServiceResponse<List<ErjkProtocol>>> findErjkProtocolsUsingGETWithServiceResponseAsync() {
        final List<String> sort = null;
        final Boolean sorted = null;
        final Boolean unsorted = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findErjkProtocolsUsingGET(sortConverted, sorted, unsorted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ErjkProtocol>>>>() {
                @Override
                public Observable<ServiceResponse<List<ErjkProtocol>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ErjkProtocol>> clientResponse = findErjkProtocolsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sorted the Boolean value
     * @param unsorted the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;ErjkProtocol&gt; object if successful.
     */
    public List<ErjkProtocol> findErjkProtocolsUsingGET(List<String> sort, Boolean sorted, Boolean unsorted) {
        return findErjkProtocolsUsingGETWithServiceResponseAsync(sort, sorted, unsorted).toBlocking().single().body();
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sorted the Boolean value
     * @param unsorted the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<ErjkProtocol>> findErjkProtocolsUsingGETAsync(List<String> sort, Boolean sorted, Boolean unsorted, final ServiceCallback<List<ErjkProtocol>> serviceCallback) {
        return ServiceFuture.fromResponse(findErjkProtocolsUsingGETWithServiceResponseAsync(sort, sorted, unsorted), serviceCallback);
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sorted the Boolean value
     * @param unsorted the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ErjkProtocol&gt; object
     */
    public Observable<List<ErjkProtocol>> findErjkProtocolsUsingGETAsync(List<String> sort, Boolean sorted, Boolean unsorted) {
        return findErjkProtocolsUsingGETWithServiceResponseAsync(sort, sorted, unsorted).map(new Func1<ServiceResponse<List<ErjkProtocol>>, List<ErjkProtocol>>() {
            @Override
            public List<ErjkProtocol> call(ServiceResponse<List<ErjkProtocol>> response) {
                return response.body();
            }
        });
    }

    /**
     * ERJK protokollide nimekiri.
     *
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sorted the Boolean value
     * @param unsorted the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;ErjkProtocol&gt; object
     */
    public Observable<ServiceResponse<List<ErjkProtocol>>> findErjkProtocolsUsingGETWithServiceResponseAsync(List<String> sort, Boolean sorted, Boolean unsorted) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findErjkProtocolsUsingGET(sortConverted, sorted, unsorted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ErjkProtocol>>>>() {
                @Override
                public Observable<ServiceResponse<List<ErjkProtocol>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<ErjkProtocol>> clientResponse = findErjkProtocolsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<ErjkProtocol>> findErjkProtocolsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<ErjkProtocol>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<ErjkProtocol>>() { }.getType())
                .build(response);
    }

    /**
     * ERJK protokoll.
     *
     * @param uuid Toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ErjkProtocol object if successful.
     */
    public ErjkProtocol findErjkProtocolUsingGET(String uuid) {
        return findErjkProtocolUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * ERJK protokoll.
     *
     * @param uuid Toimiku UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ErjkProtocol> findErjkProtocolUsingGETAsync(String uuid, final ServiceCallback<ErjkProtocol> serviceCallback) {
        return ServiceFuture.fromResponse(findErjkProtocolUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * ERJK protokoll.
     *
     * @param uuid Toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErjkProtocol object
     */
    public Observable<ErjkProtocol> findErjkProtocolUsingGETAsync(String uuid) {
        return findErjkProtocolUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<ErjkProtocol>, ErjkProtocol>() {
            @Override
            public ErjkProtocol call(ServiceResponse<ErjkProtocol> response) {
                return response.body();
            }
        });
    }

    /**
     * ERJK protokoll.
     *
     * @param uuid Toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ErjkProtocol object
     */
    public Observable<ServiceResponse<ErjkProtocol>> findErjkProtocolUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.findErjkProtocolUsingGET(uuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ErjkProtocol>>>() {
                @Override
                public Observable<ServiceResponse<ErjkProtocol>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ErjkProtocol> clientResponse = findErjkProtocolUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ErjkProtocol> findErjkProtocolUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<ErjkProtocol, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ErjkProtocol>() { }.getType())
                .build(response);
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfEuropeanUnionDocument object if successful.
     */
    public PagedResourcesOfEuropeanUnionDocument findEuropeanUnionDocumentsUsingGET() {
        return findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfEuropeanUnionDocument> findEuropeanUnionDocumentsUsingGETAsync(final ServiceCallback<PagedResourcesOfEuropeanUnionDocument> serviceCallback) {
        return ServiceFuture.fromResponse(findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfEuropeanUnionDocument object
     */
    public Observable<PagedResourcesOfEuropeanUnionDocument> findEuropeanUnionDocumentsUsingGETAsync() {
        return findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesOfEuropeanUnionDocument>, PagedResourcesOfEuropeanUnionDocument>() {
            @Override
            public PagedResourcesOfEuropeanUnionDocument call(ServiceResponse<PagedResourcesOfEuropeanUnionDocument> response) {
                return response.body();
            }
        });
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfEuropeanUnionDocument object
     */
    public Observable<ServiceResponse<PagedResourcesOfEuropeanUnionDocument>> findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync() {
        final LocalDate createdEndDate = null;
        final LocalDate createdStartDate = null;
        final String documentType = null;
        final String elMark = null;
        final String elTypeCode = null;
        final String lang = null;
        final Integer membership = null;
        final Long offset = null;
        final String opinionCommitteeUuid = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final LocalDate receiveDateEnd = null;
        final LocalDate receiveDateStart = null;
        final String reference = null;
        final String responsibleCommitteeUuid = null;
        final String sectorCode = null;
        final String sectorCommitteeUuid = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final String title = null;
        final String titleEn = null;
        final Boolean unpaged = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findEuropeanUnionDocumentsUsingGET(createdEndDate, createdStartDate, documentType, elMark, elTypeCode, lang, membership, offset, opinionCommitteeUuid, page, pageNumber, pageSize, paged, receiveDateEnd, receiveDateStart, reference, responsibleCommitteeUuid, sectorCode, sectorCommitteeUuid, size, sortConverted, sortsorted, sortunsorted, title, titleEn, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfEuropeanUnionDocument>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfEuropeanUnionDocument>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfEuropeanUnionDocument> clientResponse = findEuropeanUnionDocumentsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param documentType Dokumendi liik (sh EL dokumendi liigid)
     * @param elMark EL toimiku tähis
     * @param elTypeCode EL toimiku liik (klassifikaator 'elToimikuliik'). Possible values include: 'MUU_EL_DOKUMENT', 'EL_ALGATUS', 'NOUKOGU_JA_ULEMKOGU_DOKUMENT'
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param opinionCommitteeUuid Arvamuse andja komisjoni UUID
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param receiveDateEnd Saabumise kuupäeva lõpp (yyyy-MM-dd)
     * @param receiveDateStart Saabumise kuupäeva algus (yyyy-MM-dd)
     * @param reference Viit
     * @param responsibleCommitteeUuid Vastutava komisjoni UUID
     * @param sectorCode Valdkond (klassifikaator 'elValdkond'). Possible values include: 'KESKKOND', 'HARIDUS_KULTUUR_NOORED', 'TOOHOIVE_SOTSIAAL_TERVISHOID_TARBIJAKAITSE', 'POLLUMAJANDUS_KALANDUS', 'TRANSPORT_TELE_ENERGEETIKA', 'JUSTIITS_SISEKUSIMUSED', 'MAJANDUS_RAHANDUS', 'KONKURENTSIVOIME', 'ULDASJAD', 'VALISASJAD'
     * @param sectorCommitteeUuid Valdkonna komisjoni UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param titleEn Pealkiri inglise keeles
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfEuropeanUnionDocument object if successful.
     */
    public PagedResourcesOfEuropeanUnionDocument findEuropeanUnionDocumentsUsingGET(LocalDate createdEndDate, LocalDate createdStartDate, String documentType, String elMark, String elTypeCode, String lang, Integer membership, Long offset, String opinionCommitteeUuid, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, LocalDate receiveDateEnd, LocalDate receiveDateStart, String reference, String responsibleCommitteeUuid, String sectorCode, String sectorCommitteeUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, String titleEn, Boolean unpaged) {
        return findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync(createdEndDate, createdStartDate, documentType, elMark, elTypeCode, lang, membership, offset, opinionCommitteeUuid, page, pageNumber, pageSize, paged, receiveDateEnd, receiveDateStart, reference, responsibleCommitteeUuid, sectorCode, sectorCommitteeUuid, size, sort, sortsorted, sortunsorted, title, titleEn, unpaged).toBlocking().single().body();
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param documentType Dokumendi liik (sh EL dokumendi liigid)
     * @param elMark EL toimiku tähis
     * @param elTypeCode EL toimiku liik (klassifikaator 'elToimikuliik'). Possible values include: 'MUU_EL_DOKUMENT', 'EL_ALGATUS', 'NOUKOGU_JA_ULEMKOGU_DOKUMENT'
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param opinionCommitteeUuid Arvamuse andja komisjoni UUID
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param receiveDateEnd Saabumise kuupäeva lõpp (yyyy-MM-dd)
     * @param receiveDateStart Saabumise kuupäeva algus (yyyy-MM-dd)
     * @param reference Viit
     * @param responsibleCommitteeUuid Vastutava komisjoni UUID
     * @param sectorCode Valdkond (klassifikaator 'elValdkond'). Possible values include: 'KESKKOND', 'HARIDUS_KULTUUR_NOORED', 'TOOHOIVE_SOTSIAAL_TERVISHOID_TARBIJAKAITSE', 'POLLUMAJANDUS_KALANDUS', 'TRANSPORT_TELE_ENERGEETIKA', 'JUSTIITS_SISEKUSIMUSED', 'MAJANDUS_RAHANDUS', 'KONKURENTSIVOIME', 'ULDASJAD', 'VALISASJAD'
     * @param sectorCommitteeUuid Valdkonna komisjoni UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param titleEn Pealkiri inglise keeles
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfEuropeanUnionDocument> findEuropeanUnionDocumentsUsingGETAsync(LocalDate createdEndDate, LocalDate createdStartDate, String documentType, String elMark, String elTypeCode, String lang, Integer membership, Long offset, String opinionCommitteeUuid, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, LocalDate receiveDateEnd, LocalDate receiveDateStart, String reference, String responsibleCommitteeUuid, String sectorCode, String sectorCommitteeUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, String titleEn, Boolean unpaged, final ServiceCallback<PagedResourcesOfEuropeanUnionDocument> serviceCallback) {
        return ServiceFuture.fromResponse(findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync(createdEndDate, createdStartDate, documentType, elMark, elTypeCode, lang, membership, offset, opinionCommitteeUuid, page, pageNumber, pageSize, paged, receiveDateEnd, receiveDateStart, reference, responsibleCommitteeUuid, sectorCode, sectorCommitteeUuid, size, sort, sortsorted, sortunsorted, title, titleEn, unpaged), serviceCallback);
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param documentType Dokumendi liik (sh EL dokumendi liigid)
     * @param elMark EL toimiku tähis
     * @param elTypeCode EL toimiku liik (klassifikaator 'elToimikuliik'). Possible values include: 'MUU_EL_DOKUMENT', 'EL_ALGATUS', 'NOUKOGU_JA_ULEMKOGU_DOKUMENT'
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param opinionCommitteeUuid Arvamuse andja komisjoni UUID
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param receiveDateEnd Saabumise kuupäeva lõpp (yyyy-MM-dd)
     * @param receiveDateStart Saabumise kuupäeva algus (yyyy-MM-dd)
     * @param reference Viit
     * @param responsibleCommitteeUuid Vastutava komisjoni UUID
     * @param sectorCode Valdkond (klassifikaator 'elValdkond'). Possible values include: 'KESKKOND', 'HARIDUS_KULTUUR_NOORED', 'TOOHOIVE_SOTSIAAL_TERVISHOID_TARBIJAKAITSE', 'POLLUMAJANDUS_KALANDUS', 'TRANSPORT_TELE_ENERGEETIKA', 'JUSTIITS_SISEKUSIMUSED', 'MAJANDUS_RAHANDUS', 'KONKURENTSIVOIME', 'ULDASJAD', 'VALISASJAD'
     * @param sectorCommitteeUuid Valdkonna komisjoni UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param titleEn Pealkiri inglise keeles
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfEuropeanUnionDocument object
     */
    public Observable<PagedResourcesOfEuropeanUnionDocument> findEuropeanUnionDocumentsUsingGETAsync(LocalDate createdEndDate, LocalDate createdStartDate, String documentType, String elMark, String elTypeCode, String lang, Integer membership, Long offset, String opinionCommitteeUuid, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, LocalDate receiveDateEnd, LocalDate receiveDateStart, String reference, String responsibleCommitteeUuid, String sectorCode, String sectorCommitteeUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, String titleEn, Boolean unpaged) {
        return findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync(createdEndDate, createdStartDate, documentType, elMark, elTypeCode, lang, membership, offset, opinionCommitteeUuid, page, pageNumber, pageSize, paged, receiveDateEnd, receiveDateStart, reference, responsibleCommitteeUuid, sectorCode, sectorCommitteeUuid, size, sort, sortsorted, sortunsorted, title, titleEn, unpaged).map(new Func1<ServiceResponse<PagedResourcesOfEuropeanUnionDocument>, PagedResourcesOfEuropeanUnionDocument>() {
            @Override
            public PagedResourcesOfEuropeanUnionDocument call(ServiceResponse<PagedResourcesOfEuropeanUnionDocument> response) {
                return response.body();
            }
        });
    }

    /**
     * Euroopa Liidu toimikute otsing.
     *
     * @param createdEndDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param createdStartDate Loomiskuupäeva vahemiku algus (yyyy-MM-dd)
     * @param documentType Dokumendi liik (sh EL dokumendi liigid)
     * @param elMark EL toimiku tähis
     * @param elTypeCode EL toimiku liik (klassifikaator 'elToimikuliik'). Possible values include: 'MUU_EL_DOKUMENT', 'EL_ALGATUS', 'NOUKOGU_JA_ULEMKOGU_DOKUMENT'
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param opinionCommitteeUuid Arvamuse andja komisjoni UUID
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param receiveDateEnd Saabumise kuupäeva lõpp (yyyy-MM-dd)
     * @param receiveDateStart Saabumise kuupäeva algus (yyyy-MM-dd)
     * @param reference Viit
     * @param responsibleCommitteeUuid Vastutava komisjoni UUID
     * @param sectorCode Valdkond (klassifikaator 'elValdkond'). Possible values include: 'KESKKOND', 'HARIDUS_KULTUUR_NOORED', 'TOOHOIVE_SOTSIAAL_TERVISHOID_TARBIJAKAITSE', 'POLLUMAJANDUS_KALANDUS', 'TRANSPORT_TELE_ENERGEETIKA', 'JUSTIITS_SISEKUSIMUSED', 'MAJANDUS_RAHANDUS', 'KONKURENTSIVOIME', 'ULDASJAD', 'VALISASJAD'
     * @param sectorCommitteeUuid Valdkonna komisjoni UUID
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param title Pealkiri
     * @param titleEn Pealkiri inglise keeles
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfEuropeanUnionDocument object
     */
    public Observable<ServiceResponse<PagedResourcesOfEuropeanUnionDocument>> findEuropeanUnionDocumentsUsingGETWithServiceResponseAsync(LocalDate createdEndDate, LocalDate createdStartDate, String documentType, String elMark, String elTypeCode, String lang, Integer membership, Long offset, String opinionCommitteeUuid, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, LocalDate receiveDateEnd, LocalDate receiveDateStart, String reference, String responsibleCommitteeUuid, String sectorCode, String sectorCommitteeUuid, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, String title, String titleEn, Boolean unpaged) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findEuropeanUnionDocumentsUsingGET(createdEndDate, createdStartDate, documentType, elMark, elTypeCode, lang, membership, offset, opinionCommitteeUuid, page, pageNumber, pageSize, paged, receiveDateEnd, receiveDateStart, reference, responsibleCommitteeUuid, sectorCode, sectorCommitteeUuid, size, sortConverted, sortsorted, sortunsorted, title, titleEn, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfEuropeanUnionDocument>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfEuropeanUnionDocument>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfEuropeanUnionDocument> clientResponse = findEuropeanUnionDocumentsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesOfEuropeanUnionDocument> findEuropeanUnionDocumentsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesOfEuropeanUnionDocument, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesOfEuropeanUnionDocument>() { }.getType())
                .build(response);
    }

    /**
     * Arupärimised.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfInterpellations object if successful.
     */
    public PagedResourcesOfInterpellations findInterpellationsUsingGET() {
        return findInterpellationsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Arupärimised.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfInterpellations> findInterpellationsUsingGETAsync(final ServiceCallback<PagedResourcesOfInterpellations> serviceCallback) {
        return ServiceFuture.fromResponse(findInterpellationsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Arupärimised.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfInterpellations object
     */
    public Observable<PagedResourcesOfInterpellations> findInterpellationsUsingGETAsync() {
        return findInterpellationsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesOfInterpellations>, PagedResourcesOfInterpellations>() {
            @Override
            public PagedResourcesOfInterpellations call(ServiceResponse<PagedResourcesOfInterpellations> response) {
                return response.body();
            }
        });
    }

    /**
     * Arupärimised.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfInterpellations object
     */
    public Observable<ServiceResponse<PagedResourcesOfInterpellations>> findInterpellationsUsingGETWithServiceResponseAsync() {
        final String enquirerUuid = null;
        final String lang = null;
        final Integer membership = null;
        final Long offset = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final Boolean unpaged = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findInterpellationsUsingGET(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sortConverted, sortsorted, sortunsorted, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfInterpellations>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfInterpellations>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfInterpellations> clientResponse = findInterpellationsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Arupärimised.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfInterpellations object if successful.
     */
    public PagedResourcesOfInterpellations findInterpellationsUsingGET(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        return findInterpellationsUsingGETWithServiceResponseAsync(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sort, sortsorted, sortunsorted, unpaged).toBlocking().single().body();
    }

    /**
     * Arupärimised.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfInterpellations> findInterpellationsUsingGETAsync(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged, final ServiceCallback<PagedResourcesOfInterpellations> serviceCallback) {
        return ServiceFuture.fromResponse(findInterpellationsUsingGETWithServiceResponseAsync(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sort, sortsorted, sortunsorted, unpaged), serviceCallback);
    }

    /**
     * Arupärimised.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfInterpellations object
     */
    public Observable<PagedResourcesOfInterpellations> findInterpellationsUsingGETAsync(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        return findInterpellationsUsingGETWithServiceResponseAsync(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sort, sortsorted, sortunsorted, unpaged).map(new Func1<ServiceResponse<PagedResourcesOfInterpellations>, PagedResourcesOfInterpellations>() {
            @Override
            public PagedResourcesOfInterpellations call(ServiceResponse<PagedResourcesOfInterpellations> response) {
                return response.body();
            }
        });
    }

    /**
     * Arupärimised.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfInterpellations object
     */
    public Observable<ServiceResponse<PagedResourcesOfInterpellations>> findInterpellationsUsingGETWithServiceResponseAsync(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findInterpellationsUsingGET(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sortConverted, sortsorted, sortunsorted, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfInterpellations>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfInterpellations>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfInterpellations> clientResponse = findInterpellationsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesOfInterpellations> findInterpellationsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesOfInterpellations, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesOfInterpellations>() { }.getType())
                .build(response);
    }

    /**
     * Kirjalikud küsimused.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfWrittenQuestions object if successful.
     */
    public PagedResourcesOfWrittenQuestions findWrittenQuestionsUsingGET() {
        return findWrittenQuestionsUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Kirjalikud küsimused.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfWrittenQuestions> findWrittenQuestionsUsingGETAsync(final ServiceCallback<PagedResourcesOfWrittenQuestions> serviceCallback) {
        return ServiceFuture.fromResponse(findWrittenQuestionsUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Kirjalikud küsimused.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfWrittenQuestions object
     */
    public Observable<PagedResourcesOfWrittenQuestions> findWrittenQuestionsUsingGETAsync() {
        return findWrittenQuestionsUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PagedResourcesOfWrittenQuestions>, PagedResourcesOfWrittenQuestions>() {
            @Override
            public PagedResourcesOfWrittenQuestions call(ServiceResponse<PagedResourcesOfWrittenQuestions> response) {
                return response.body();
            }
        });
    }

    /**
     * Kirjalikud küsimused.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfWrittenQuestions object
     */
    public Observable<ServiceResponse<PagedResourcesOfWrittenQuestions>> findWrittenQuestionsUsingGETWithServiceResponseAsync() {
        final String enquirerUuid = null;
        final String lang = null;
        final Integer membership = null;
        final Long offset = null;
        final Integer page = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final Integer size = null;
        final List<String> sort = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final Boolean unpaged = null;
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findWrittenQuestionsUsingGET(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sortConverted, sortsorted, sortunsorted, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfWrittenQuestions>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfWrittenQuestions>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfWrittenQuestions> clientResponse = findWrittenQuestionsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Kirjalikud küsimused.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfWrittenQuestions object if successful.
     */
    public PagedResourcesOfWrittenQuestions findWrittenQuestionsUsingGET(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        return findWrittenQuestionsUsingGETWithServiceResponseAsync(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sort, sortsorted, sortunsorted, unpaged).toBlocking().single().body();
    }

    /**
     * Kirjalikud küsimused.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfWrittenQuestions> findWrittenQuestionsUsingGETAsync(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged, final ServiceCallback<PagedResourcesOfWrittenQuestions> serviceCallback) {
        return ServiceFuture.fromResponse(findWrittenQuestionsUsingGETWithServiceResponseAsync(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sort, sortsorted, sortunsorted, unpaged), serviceCallback);
    }

    /**
     * Kirjalikud küsimused.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfWrittenQuestions object
     */
    public Observable<PagedResourcesOfWrittenQuestions> findWrittenQuestionsUsingGETAsync(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        return findWrittenQuestionsUsingGETWithServiceResponseAsync(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sort, sortsorted, sortunsorted, unpaged).map(new Func1<ServiceResponse<PagedResourcesOfWrittenQuestions>, PagedResourcesOfWrittenQuestions>() {
            @Override
            public PagedResourcesOfWrittenQuestions call(ServiceResponse<PagedResourcesOfWrittenQuestions> response) {
                return response.body();
            }
        });
    }

    /**
     * Kirjalikud küsimused.
     *
     * @param enquirerUuid Küsija UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param membership Koosseisu number
     * @param offset the Long value
     * @param page Lehekülje number
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param size Tulemuste arv leheküljel (vaikimisi 20)
     * @param sort Sorteerimine (formaat: väli[,asc|desc])
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfWrittenQuestions object
     */
    public Observable<ServiceResponse<PagedResourcesOfWrittenQuestions>> findWrittenQuestionsUsingGETWithServiceResponseAsync(String enquirerUuid, String lang, Integer membership, Long offset, Integer page, Integer pageNumber, Integer pageSize, Boolean paged, Integer size, List<String> sort, Boolean sortsorted, Boolean sortunsorted, Boolean unpaged) {
        Validator.validate(sort);
        String sortConverted = this.serializerAdapter().serializeList(sort, CollectionFormat.MULTI);
        return service.findWrittenQuestionsUsingGET(enquirerUuid, lang, membership, offset, page, pageNumber, pageSize, paged, size, sortConverted, sortsorted, sortunsorted, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfWrittenQuestions>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfWrittenQuestions>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfWrittenQuestions> clientResponse = findWrittenQuestionsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesOfWrittenQuestions> findWrittenQuestionsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PagedResourcesOfWrittenQuestions, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesOfWrittenQuestions>() { }.getType())
                .build(response);
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Volume object if successful.
     */
    public Volume getVolumeUsingGET(String uuid) {
        return getVolumeUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Volume> getVolumeUsingGETAsync(String uuid, final ServiceCallback<Volume> serviceCallback) {
        return ServiceFuture.fromResponse(getVolumeUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Volume object
     */
    public Observable<Volume> getVolumeUsingGETAsync(String uuid) {
        return getVolumeUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<Volume>, Volume>() {
            @Override
            public Volume call(ServiceResponse<Volume> response) {
                return response.body();
            }
        });
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Volume object
     */
    public Observable<ServiceResponse<Volume>> getVolumeUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getVolumeUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Volume>>>() {
                @Override
                public Observable<ServiceResponse<Volume>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Volume> clientResponse = getVolumeUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Volume object if successful.
     */
    public Volume getVolumeUsingGET(String uuid, String lang) {
        return getVolumeUsingGETWithServiceResponseAsync(uuid, lang).toBlocking().single().body();
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Volume> getVolumeUsingGETAsync(String uuid, String lang, final ServiceCallback<Volume> serviceCallback) {
        return ServiceFuture.fromResponse(getVolumeUsingGETWithServiceResponseAsync(uuid, lang), serviceCallback);
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Volume object
     */
    public Observable<Volume> getVolumeUsingGETAsync(String uuid, String lang) {
        return getVolumeUsingGETWithServiceResponseAsync(uuid, lang).map(new Func1<ServiceResponse<Volume>, Volume>() {
            @Override
            public Volume call(ServiceResponse<Volume> response) {
                return response.body();
            }
        });
    }

    /**
     * Toimiku detailid.
     *
     * @param uuid Toimiku UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Volume object
     */
    public Observable<ServiceResponse<Volume>> getVolumeUsingGETWithServiceResponseAsync(String uuid, String lang) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getVolumeUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Volume>>>() {
                @Override
                public Observable<ServiceResponse<Volume>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Volume> clientResponse = getVolumeUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Volume> getVolumeUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Volume, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Volume>() { }.getType())
                .build(response);
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PlenarySittingVoting&gt; object if successful.
     */
    public List<PlenarySittingVoting> getVotingsUsingGET(LocalDate endDate, LocalDate startDate) {
        return getVotingsUsingGETWithServiceResponseAsync(endDate, startDate).toBlocking().single().body();
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PlenarySittingVoting>> getVotingsUsingGETAsync(LocalDate endDate, LocalDate startDate, final ServiceCallback<List<PlenarySittingVoting>> serviceCallback) {
        return ServiceFuture.fromResponse(getVotingsUsingGETWithServiceResponseAsync(endDate, startDate), serviceCallback);
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenarySittingVoting&gt; object
     */
    public Observable<List<PlenarySittingVoting>> getVotingsUsingGETAsync(LocalDate endDate, LocalDate startDate) {
        return getVotingsUsingGETWithServiceResponseAsync(endDate, startDate).map(new Func1<ServiceResponse<List<PlenarySittingVoting>>, List<PlenarySittingVoting>>() {
            @Override
            public List<PlenarySittingVoting> call(ServiceResponse<List<PlenarySittingVoting>> response) {
                return response.body();
            }
        });
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenarySittingVoting&gt; object
     */
    public Observable<ServiceResponse<List<PlenarySittingVoting>>> getVotingsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        final String lang = null;
        return service.getVotingsUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PlenarySittingVoting>>>>() {
                @Override
                public Observable<ServiceResponse<List<PlenarySittingVoting>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PlenarySittingVoting>> clientResponse = getVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PlenarySittingVoting&gt; object if successful.
     */
    public List<PlenarySittingVoting> getVotingsUsingGET(LocalDate endDate, LocalDate startDate, String lang) {
        return getVotingsUsingGETWithServiceResponseAsync(endDate, startDate, lang).toBlocking().single().body();
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PlenarySittingVoting>> getVotingsUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang, final ServiceCallback<List<PlenarySittingVoting>> serviceCallback) {
        return ServiceFuture.fromResponse(getVotingsUsingGETWithServiceResponseAsync(endDate, startDate, lang), serviceCallback);
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenarySittingVoting&gt; object
     */
    public Observable<List<PlenarySittingVoting>> getVotingsUsingGETAsync(LocalDate endDate, LocalDate startDate, String lang) {
        return getVotingsUsingGETWithServiceResponseAsync(endDate, startDate, lang).map(new Func1<ServiceResponse<List<PlenarySittingVoting>>, List<PlenarySittingVoting>>() {
            @Override
            public List<PlenarySittingVoting> call(ServiceResponse<List<PlenarySittingVoting>> response) {
                return response.body();
            }
        });
    }

    /**
     * Hääletused.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PlenarySittingVoting&gt; object
     */
    public Observable<ServiceResponse<List<PlenarySittingVoting>>> getVotingsUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate, String lang) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        return service.getVotingsUsingGET(endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PlenarySittingVoting>>>>() {
                @Override
                public Observable<ServiceResponse<List<PlenarySittingVoting>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PlenarySittingVoting>> clientResponse = getVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PlenarySittingVoting>> getVotingsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<PlenarySittingVoting>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<PlenarySittingVoting>>() { }.getType())
                .build(response);
    }

    /**
     * Hääletuste kalender.
     * Kuupäevad, millal vähemalt üks hääletus on toimunud.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;VotingCalendar&gt; object if successful.
     */
    public List<VotingCalendar> getVotingCalendarUsingGET(LocalDate endDate, LocalDate startDate) {
        return getVotingCalendarUsingGETWithServiceResponseAsync(endDate, startDate).toBlocking().single().body();
    }

    /**
     * Hääletuste kalender.
     * Kuupäevad, millal vähemalt üks hääletus on toimunud.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<VotingCalendar>> getVotingCalendarUsingGETAsync(LocalDate endDate, LocalDate startDate, final ServiceCallback<List<VotingCalendar>> serviceCallback) {
        return ServiceFuture.fromResponse(getVotingCalendarUsingGETWithServiceResponseAsync(endDate, startDate), serviceCallback);
    }

    /**
     * Hääletuste kalender.
     * Kuupäevad, millal vähemalt üks hääletus on toimunud.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;VotingCalendar&gt; object
     */
    public Observable<List<VotingCalendar>> getVotingCalendarUsingGETAsync(LocalDate endDate, LocalDate startDate) {
        return getVotingCalendarUsingGETWithServiceResponseAsync(endDate, startDate).map(new Func1<ServiceResponse<List<VotingCalendar>>, List<VotingCalendar>>() {
            @Override
            public List<VotingCalendar> call(ServiceResponse<List<VotingCalendar>> response) {
                return response.body();
            }
        });
    }

    /**
     * Hääletuste kalender.
     * Kuupäevad, millal vähemalt üks hääletus on toimunud.
     *
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;VotingCalendar&gt; object
     */
    public Observable<ServiceResponse<List<VotingCalendar>>> getVotingCalendarUsingGETWithServiceResponseAsync(LocalDate endDate, LocalDate startDate) {
        if (endDate == null) {
            throw new IllegalArgumentException("Parameter endDate is required and cannot be null.");
        }
        if (startDate == null) {
            throw new IllegalArgumentException("Parameter startDate is required and cannot be null.");
        }
        return service.getVotingCalendarUsingGET(endDate, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<VotingCalendar>>>>() {
                @Override
                public Observable<ServiceResponse<List<VotingCalendar>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<VotingCalendar>> clientResponse = getVotingCalendarUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<VotingCalendar>> getVotingCalendarUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<VotingCalendar>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<VotingCalendar>>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserGroup&gt; object if successful.
     */
    public List<UserGroup> findCommitteeMemberVotingsUsingGET(String userUuid) {
        return findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(userUuid).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserGroup>> findCommitteeMemberVotingsUsingGETAsync(String userUuid, final ServiceCallback<List<UserGroup>> serviceCallback) {
        return ServiceFuture.fromResponse(findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(userUuid), serviceCallback);
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserGroup&gt; object
     */
    public Observable<List<UserGroup>> findCommitteeMemberVotingsUsingGETAsync(String userUuid) {
        return findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(userUuid).map(new Func1<ServiceResponse<List<UserGroup>>, List<UserGroup>>() {
            @Override
            public List<UserGroup> call(ServiceResponse<List<UserGroup>> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserGroup&gt; object
     */
    public Observable<ServiceResponse<List<UserGroup>>> findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(String userUuid) {
        if (userUuid == null) {
            throw new IllegalArgumentException("Parameter userUuid is required and cannot be null.");
        }
        final LocalDate endDate = null;
        final String lang = null;
        final LocalDate startDate = null;
        return service.findCommitteeMemberVotingsUsingGET(endDate, lang, startDate, userUuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserGroup>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserGroup>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserGroup>> clientResponse = findCommitteeMemberVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UserGroup&gt; object if successful.
     */
    public List<UserGroup> findCommitteeMemberVotingsUsingGET(String userUuid, LocalDate endDate, String lang, LocalDate startDate) {
        return findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(userUuid, endDate, lang, startDate).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UserGroup>> findCommitteeMemberVotingsUsingGETAsync(String userUuid, LocalDate endDate, String lang, LocalDate startDate, final ServiceCallback<List<UserGroup>> serviceCallback) {
        return ServiceFuture.fromResponse(findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(userUuid, endDate, lang, startDate), serviceCallback);
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserGroup&gt; object
     */
    public Observable<List<UserGroup>> findCommitteeMemberVotingsUsingGETAsync(String userUuid, LocalDate endDate, String lang, LocalDate startDate) {
        return findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(userUuid, endDate, lang, startDate).map(new Func1<ServiceResponse<List<UserGroup>>, List<UserGroup>>() {
            @Override
            public List<UserGroup> call(ServiceResponse<List<UserGroup>> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme hääletused komisjonides.
     *
     * @param userUuid userUuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UserGroup&gt; object
     */
    public Observable<ServiceResponse<List<UserGroup>>> findCommitteeMemberVotingsUsingGETWithServiceResponseAsync(String userUuid, LocalDate endDate, String lang, LocalDate startDate) {
        if (userUuid == null) {
            throw new IllegalArgumentException("Parameter userUuid is required and cannot be null.");
        }
        return service.findCommitteeMemberVotingsUsingGET(endDate, lang, startDate, userUuid)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UserGroup>>>>() {
                @Override
                public Observable<ServiceResponse<List<UserGroup>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UserGroup>> clientResponse = findCommitteeMemberVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<UserGroup>> findCommitteeMemberVotingsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<UserGroup>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<UserGroup>>() { }.getType())
                .build(response);
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;CommitteeSitting&gt; object if successful.
     */
    public List<CommitteeSitting> findCommitteeVotingsUsingGET(String uuid) {
        return findCommitteeVotingsUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CommitteeSitting>> findCommitteeVotingsUsingGETAsync(String uuid, final ServiceCallback<List<CommitteeSitting>> serviceCallback) {
        return ServiceFuture.fromResponse(findCommitteeVotingsUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CommitteeSitting&gt; object
     */
    public Observable<List<CommitteeSitting>> findCommitteeVotingsUsingGETAsync(String uuid) {
        return findCommitteeVotingsUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<List<CommitteeSitting>>, List<CommitteeSitting>>() {
            @Override
            public List<CommitteeSitting> call(ServiceResponse<List<CommitteeSitting>> response) {
                return response.body();
            }
        });
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CommitteeSitting&gt; object
     */
    public Observable<ServiceResponse<List<CommitteeSitting>>> findCommitteeVotingsUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final LocalDate endDate = null;
        final String lang = null;
        final LocalDate startDate = null;
        return service.findCommitteeVotingsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<CommitteeSitting>>>>() {
                @Override
                public Observable<ServiceResponse<List<CommitteeSitting>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<CommitteeSitting>> clientResponse = findCommitteeVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;CommitteeSitting&gt; object if successful.
     */
    public List<CommitteeSitting> findCommitteeVotingsUsingGET(String uuid, LocalDate endDate, String lang, LocalDate startDate) {
        return findCommitteeVotingsUsingGETWithServiceResponseAsync(uuid, endDate, lang, startDate).toBlocking().single().body();
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CommitteeSitting>> findCommitteeVotingsUsingGETAsync(String uuid, LocalDate endDate, String lang, LocalDate startDate, final ServiceCallback<List<CommitteeSitting>> serviceCallback) {
        return ServiceFuture.fromResponse(findCommitteeVotingsUsingGETWithServiceResponseAsync(uuid, endDate, lang, startDate), serviceCallback);
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CommitteeSitting&gt; object
     */
    public Observable<List<CommitteeSitting>> findCommitteeVotingsUsingGETAsync(String uuid, LocalDate endDate, String lang, LocalDate startDate) {
        return findCommitteeVotingsUsingGETWithServiceResponseAsync(uuid, endDate, lang, startDate).map(new Func1<ServiceResponse<List<CommitteeSitting>>, List<CommitteeSitting>>() {
            @Override
            public List<CommitteeSitting> call(ServiceResponse<List<CommitteeSitting>> response) {
                return response.body();
            }
        });
    }

    /**
     * Komisjoni hääletused.
     *
     * @param uuid uuid
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang lang. Possible values include: 'et', 'ru', 'en'
     * @param startDate Kuupäevavahemiku algus (yyyy-MM-dd)
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CommitteeSitting&gt; object
     */
    public Observable<ServiceResponse<List<CommitteeSitting>>> findCommitteeVotingsUsingGETWithServiceResponseAsync(String uuid, LocalDate endDate, String lang, LocalDate startDate) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.findCommitteeVotingsUsingGET(uuid, endDate, lang, startDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<CommitteeSitting>>>>() {
                @Override
                public Observable<ServiceResponse<List<CommitteeSitting>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<CommitteeSitting>> clientResponse = findCommitteeVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<CommitteeSitting>> findCommitteeVotingsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<CommitteeSitting>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<CommitteeSitting>>() { }.getType())
                .build(response);
    }

    /**
     * Viimane hääletus.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PlenaryVotingDetails object if successful.
     */
    public PlenaryVotingDetails getLastVotingUsingGET() {
        return getLastVotingUsingGETWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Viimane hääletus.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PlenaryVotingDetails> getLastVotingUsingGETAsync(final ServiceCallback<PlenaryVotingDetails> serviceCallback) {
        return ServiceFuture.fromResponse(getLastVotingUsingGETWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Viimane hääletus.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryVotingDetails object
     */
    public Observable<PlenaryVotingDetails> getLastVotingUsingGETAsync() {
        return getLastVotingUsingGETWithServiceResponseAsync().map(new Func1<ServiceResponse<PlenaryVotingDetails>, PlenaryVotingDetails>() {
            @Override
            public PlenaryVotingDetails call(ServiceResponse<PlenaryVotingDetails> response) {
                return response.body();
            }
        });
    }

    /**
     * Viimane hääletus.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryVotingDetails object
     */
    public Observable<ServiceResponse<PlenaryVotingDetails>> getLastVotingUsingGETWithServiceResponseAsync() {
        final String lang = null;
        return service.getLastVotingUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PlenaryVotingDetails>>>() {
                @Override
                public Observable<ServiceResponse<PlenaryVotingDetails>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PlenaryVotingDetails> clientResponse = getLastVotingUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Viimane hääletus.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PlenaryVotingDetails object if successful.
     */
    public PlenaryVotingDetails getLastVotingUsingGET(String lang) {
        return getLastVotingUsingGETWithServiceResponseAsync(lang).toBlocking().single().body();
    }

    /**
     * Viimane hääletus.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PlenaryVotingDetails> getLastVotingUsingGETAsync(String lang, final ServiceCallback<PlenaryVotingDetails> serviceCallback) {
        return ServiceFuture.fromResponse(getLastVotingUsingGETWithServiceResponseAsync(lang), serviceCallback);
    }

    /**
     * Viimane hääletus.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryVotingDetails object
     */
    public Observable<PlenaryVotingDetails> getLastVotingUsingGETAsync(String lang) {
        return getLastVotingUsingGETWithServiceResponseAsync(lang).map(new Func1<ServiceResponse<PlenaryVotingDetails>, PlenaryVotingDetails>() {
            @Override
            public PlenaryVotingDetails call(ServiceResponse<PlenaryVotingDetails> response) {
                return response.body();
            }
        });
    }

    /**
     * Viimane hääletus.
     *
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryVotingDetails object
     */
    public Observable<ServiceResponse<PlenaryVotingDetails>> getLastVotingUsingGETWithServiceResponseAsync(String lang) {
        return service.getLastVotingUsingGET(lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PlenaryVotingDetails>>>() {
                @Override
                public Observable<ServiceResponse<PlenaryVotingDetails>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PlenaryVotingDetails> clientResponse = getLastVotingUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PlenaryVotingDetails> getLastVotingUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PlenaryVotingDetails, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PlenaryVotingDetails>() { }.getType())
                .build(response);
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfPlenaryMemberSitting object if successful.
     */
    public PagedResourcesOfPlenaryMemberSitting getPlenaryMemberVotingsUsingGET(String uuid) {
        return getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfPlenaryMemberSitting> getPlenaryMemberVotingsUsingGETAsync(String uuid, final ServiceCallback<PagedResourcesOfPlenaryMemberSitting> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfPlenaryMemberSitting object
     */
    public Observable<PagedResourcesOfPlenaryMemberSitting> getPlenaryMemberVotingsUsingGETAsync(String uuid) {
        return getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<PagedResourcesOfPlenaryMemberSitting>, PagedResourcesOfPlenaryMemberSitting>() {
            @Override
            public PagedResourcesOfPlenaryMemberSitting call(ServiceResponse<PagedResourcesOfPlenaryMemberSitting> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfPlenaryMemberSitting object
     */
    public Observable<ServiceResponse<PagedResourcesOfPlenaryMemberSitting>> getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final LocalDate endDate = null;
        final String lang = null;
        final Long offset = null;
        final Integer pageNumber = null;
        final Integer pageSize = null;
        final Boolean paged = null;
        final Boolean sortsorted = null;
        final Boolean sortunsorted = null;
        final LocalDate startDate = null;
        final Boolean unpaged = null;
        return service.getPlenaryMemberVotingsUsingGET(uuid, endDate, lang, offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, startDate, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfPlenaryMemberSitting>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfPlenaryMemberSitting>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfPlenaryMemberSitting> clientResponse = getPlenaryMemberVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param startDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PagedResourcesOfPlenaryMemberSitting object if successful.
     */
    public PagedResourcesOfPlenaryMemberSitting getPlenaryMemberVotingsUsingGET(String uuid, LocalDate endDate, String lang, Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, LocalDate startDate, Boolean unpaged) {
        return getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(uuid, endDate, lang, offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, startDate, unpaged).toBlocking().single().body();
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param startDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param unpaged the Boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PagedResourcesOfPlenaryMemberSitting> getPlenaryMemberVotingsUsingGETAsync(String uuid, LocalDate endDate, String lang, Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, LocalDate startDate, Boolean unpaged, final ServiceCallback<PagedResourcesOfPlenaryMemberSitting> serviceCallback) {
        return ServiceFuture.fromResponse(getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(uuid, endDate, lang, offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, startDate, unpaged), serviceCallback);
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param startDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfPlenaryMemberSitting object
     */
    public Observable<PagedResourcesOfPlenaryMemberSitting> getPlenaryMemberVotingsUsingGETAsync(String uuid, LocalDate endDate, String lang, Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, LocalDate startDate, Boolean unpaged) {
        return getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(uuid, endDate, lang, offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, startDate, unpaged).map(new Func1<ServiceResponse<PagedResourcesOfPlenaryMemberSitting>, PagedResourcesOfPlenaryMemberSitting>() {
            @Override
            public PagedResourcesOfPlenaryMemberSitting call(ServiceResponse<PagedResourcesOfPlenaryMemberSitting> response) {
                return response.body();
            }
        });
    }

    /**
     * Riigikogu liikme hääletused.
     *
     * @param uuid Liikme UUID
     * @param endDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param offset the Long value
     * @param pageNumber the Integer value
     * @param pageSize the Integer value
     * @param paged the Boolean value
     * @param sortsorted the Boolean value
     * @param sortunsorted the Boolean value
     * @param startDate Kuupäevavahemiku lõpp (yyyy-MM-dd)
     * @param unpaged the Boolean value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PagedResourcesOfPlenaryMemberSitting object
     */
    public Observable<ServiceResponse<PagedResourcesOfPlenaryMemberSitting>> getPlenaryMemberVotingsUsingGETWithServiceResponseAsync(String uuid, LocalDate endDate, String lang, Long offset, Integer pageNumber, Integer pageSize, Boolean paged, Boolean sortsorted, Boolean sortunsorted, LocalDate startDate, Boolean unpaged) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getPlenaryMemberVotingsUsingGET(uuid, endDate, lang, offset, pageNumber, pageSize, paged, sortsorted, sortunsorted, startDate, unpaged)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PagedResourcesOfPlenaryMemberSitting>>>() {
                @Override
                public Observable<ServiceResponse<PagedResourcesOfPlenaryMemberSitting>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PagedResourcesOfPlenaryMemberSitting> clientResponse = getPlenaryMemberVotingsUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PagedResourcesOfPlenaryMemberSitting> getPlenaryMemberVotingsUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PagedResourcesOfPlenaryMemberSitting, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PagedResourcesOfPlenaryMemberSitting>() { }.getType())
                .build(response);
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PlenaryVotingDetails object if successful.
     */
    public PlenaryVotingDetails getVotingUsingGET(String uuid) {
        return getVotingUsingGETWithServiceResponseAsync(uuid).toBlocking().single().body();
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PlenaryVotingDetails> getVotingUsingGETAsync(String uuid, final ServiceCallback<PlenaryVotingDetails> serviceCallback) {
        return ServiceFuture.fromResponse(getVotingUsingGETWithServiceResponseAsync(uuid), serviceCallback);
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryVotingDetails object
     */
    public Observable<PlenaryVotingDetails> getVotingUsingGETAsync(String uuid) {
        return getVotingUsingGETWithServiceResponseAsync(uuid).map(new Func1<ServiceResponse<PlenaryVotingDetails>, PlenaryVotingDetails>() {
            @Override
            public PlenaryVotingDetails call(ServiceResponse<PlenaryVotingDetails> response) {
                return response.body();
            }
        });
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryVotingDetails object
     */
    public Observable<ServiceResponse<PlenaryVotingDetails>> getVotingUsingGETWithServiceResponseAsync(String uuid) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        final String lang = null;
        return service.getVotingUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PlenaryVotingDetails>>>() {
                @Override
                public Observable<ServiceResponse<PlenaryVotingDetails>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PlenaryVotingDetails> clientResponse = getVotingUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PlenaryVotingDetails object if successful.
     */
    public PlenaryVotingDetails getVotingUsingGET(String uuid, String lang) {
        return getVotingUsingGETWithServiceResponseAsync(uuid, lang).toBlocking().single().body();
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PlenaryVotingDetails> getVotingUsingGETAsync(String uuid, String lang, final ServiceCallback<PlenaryVotingDetails> serviceCallback) {
        return ServiceFuture.fromResponse(getVotingUsingGETWithServiceResponseAsync(uuid, lang), serviceCallback);
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryVotingDetails object
     */
    public Observable<PlenaryVotingDetails> getVotingUsingGETAsync(String uuid, String lang) {
        return getVotingUsingGETWithServiceResponseAsync(uuid, lang).map(new Func1<ServiceResponse<PlenaryVotingDetails>, PlenaryVotingDetails>() {
            @Override
            public PlenaryVotingDetails call(ServiceResponse<PlenaryVotingDetails> response) {
                return response.body();
            }
        });
    }

    /**
     * Hääletuse detailid.
     *
     * @param uuid Hääletuse UUID
     * @param lang Keel. Possible values include: 'et', 'ru', 'en'
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PlenaryVotingDetails object
     */
    public Observable<ServiceResponse<PlenaryVotingDetails>> getVotingUsingGETWithServiceResponseAsync(String uuid, String lang) {
        if (uuid == null) {
            throw new IllegalArgumentException("Parameter uuid is required and cannot be null.");
        }
        return service.getVotingUsingGET(uuid, lang)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PlenaryVotingDetails>>>() {
                @Override
                public Observable<ServiceResponse<PlenaryVotingDetails>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PlenaryVotingDetails> clientResponse = getVotingUsingGETDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PlenaryVotingDetails> getVotingUsingGETDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PlenaryVotingDetails, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PlenaryVotingDetails>() { }.getType())
                .build(response);
    }

}
